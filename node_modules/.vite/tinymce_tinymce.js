import {
  __commonJS
} from "./chunk-BWTIIPT6.js";

// node_modules/tinymce/tinymce.js
var require_tinymce = __commonJS({
  "node_modules/tinymce/tinymce.js"(exports, module) {
    (function() {
      (function(domGlobals) {
        "use strict";
        var noop = function() {
        };
        var compose = function(fa, fb) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return fa(fb.apply(null, args));
          };
        };
        var constant = function(value2) {
          return function() {
            return value2;
          };
        };
        var identity = function(x) {
          return x;
        };
        function curry(fn) {
          var initialArgs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            initialArgs[_i - 1] = arguments[_i];
          }
          return function() {
            var restArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              restArgs[_i2] = arguments[_i2];
            }
            var all2 = initialArgs.concat(restArgs);
            return fn.apply(null, all2);
          };
        }
        var not = function(f) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return !f.apply(null, args);
          };
        };
        var die = function(msg) {
          return function() {
            throw new Error(msg);
          };
        };
        var never = constant(false);
        var always = constant(true);
        var none = function() {
          return NONE;
        };
        var NONE = function() {
          var eq2 = function(o) {
            return o.isNone();
          };
          var call = function(thunk) {
            return thunk();
          };
          var id = function(n) {
            return n;
          };
          var me = {
            fold: function(n, s) {
              return n();
            },
            is: never,
            isSome: never,
            isNone: always,
            getOr: id,
            getOrThunk: call,
            getOrDie: function(msg) {
              throw new Error(msg || "error: getOrDie called on none.");
            },
            getOrNull: constant(null),
            getOrUndefined: constant(void 0),
            or: id,
            orThunk: call,
            map: none,
            each: noop,
            bind: none,
            exists: never,
            forall: always,
            filter: none,
            equals: eq2,
            equals_: eq2,
            toArray: function() {
              return [];
            },
            toString: constant("none()")
          };
          if (Object.freeze) {
            Object.freeze(me);
          }
          return me;
        }();
        var some = function(a) {
          var constant_a = constant(a);
          var self2 = function() {
            return me;
          };
          var bind2 = function(f) {
            return f(a);
          };
          var me = {
            fold: function(n, s) {
              return s(a);
            },
            is: function(v) {
              return a === v;
            },
            isSome: always,
            isNone: never,
            getOr: constant_a,
            getOrThunk: constant_a,
            getOrDie: constant_a,
            getOrNull: constant_a,
            getOrUndefined: constant_a,
            or: self2,
            orThunk: self2,
            map: function(f) {
              return some(f(a));
            },
            each: function(f) {
              f(a);
            },
            bind: bind2,
            exists: bind2,
            forall: bind2,
            filter: function(f) {
              return f(a) ? me : NONE;
            },
            toArray: function() {
              return [a];
            },
            toString: function() {
              return "some(" + a + ")";
            },
            equals: function(o) {
              return o.is(a);
            },
            equals_: function(o, elementEq) {
              return o.fold(never, function(b) {
                return elementEq(a, b);
              });
            }
          };
          return me;
        };
        var from = function(value2) {
          return value2 === null || value2 === void 0 ? NONE : some(value2);
        };
        var Option = {
          some,
          none,
          from
        };
        var typeOf = function(x) {
          if (x === null) {
            return "null";
          }
          var t = typeof x;
          if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
            return "array";
          }
          if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
            return "string";
          }
          return t;
        };
        var isType = function(type2) {
          return function(value2) {
            return typeOf(value2) === type2;
          };
        };
        var isString = isType("string");
        var isObject = isType("object");
        var isArray = isType("array");
        var isNull = isType("null");
        var isBoolean = isType("boolean");
        var isFunction = isType("function");
        var isNumber = isType("number");
        var nativeSlice = Array.prototype.slice;
        var nativeIndexOf = Array.prototype.indexOf;
        var nativePush = Array.prototype.push;
        var rawIndexOf = function(ts, t) {
          return nativeIndexOf.call(ts, t);
        };
        var indexOf = function(xs, x) {
          var r = rawIndexOf(xs, x);
          return r === -1 ? Option.none() : Option.some(r);
        };
        var contains = function(xs, x) {
          return rawIndexOf(xs, x) > -1;
        };
        var exists = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              return true;
            }
          }
          return false;
        };
        var map = function(xs, f) {
          var len = xs.length;
          var r = new Array(len);
          for (var i2 = 0; i2 < len; i2++) {
            var x = xs[i2];
            r[i2] = f(x, i2);
          }
          return r;
        };
        var each = function(xs, f) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            f(x, i2);
          }
        };
        var eachr = function(xs, f) {
          for (var i2 = xs.length - 1; i2 >= 0; i2--) {
            var x = xs[i2];
            f(x, i2);
          }
        };
        var partition = function(xs, pred) {
          var pass = [];
          var fail = [];
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            var arr2 = pred(x, i2) ? pass : fail;
            arr2.push(x);
          }
          return {
            pass,
            fail
          };
        };
        var filter = function(xs, pred) {
          var r = [];
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              r.push(x);
            }
          }
          return r;
        };
        var foldr = function(xs, f, acc) {
          eachr(xs, function(x) {
            acc = f(acc, x);
          });
          return acc;
        };
        var foldl = function(xs, f, acc) {
          each(xs, function(x) {
            acc = f(acc, x);
          });
          return acc;
        };
        var find = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              return Option.some(x);
            }
          }
          return Option.none();
        };
        var findIndex = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              return Option.some(i2);
            }
          }
          return Option.none();
        };
        var flatten = function(xs) {
          var r = [];
          for (var i2 = 0, len = xs.length; i2 < len; ++i2) {
            if (!isArray(xs[i2])) {
              throw new Error("Arr.flatten item " + i2 + " was not an array, input: " + xs);
            }
            nativePush.apply(r, xs[i2]);
          }
          return r;
        };
        var bind = function(xs, f) {
          var output = map(xs, f);
          return flatten(output);
        };
        var forall = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; ++i2) {
            var x = xs[i2];
            if (pred(x, i2) !== true) {
              return false;
            }
          }
          return true;
        };
        var reverse = function(xs) {
          var r = nativeSlice.call(xs, 0);
          r.reverse();
          return r;
        };
        var difference = function(a1, a2) {
          return filter(a1, function(x) {
            return !contains(a2, x);
          });
        };
        var mapToObject = function(xs, f) {
          var r = {};
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            r[String(x)] = f(x, i2);
          }
          return r;
        };
        var sort = function(xs, comparator) {
          var copy = nativeSlice.call(xs, 0);
          copy.sort(comparator);
          return copy;
        };
        var head = function(xs) {
          return xs.length === 0 ? Option.none() : Option.some(xs[0]);
        };
        var last = function(xs) {
          return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
        };
        var from$1 = isFunction(Array.from) ? Array.from : function(x) {
          return nativeSlice.call(x);
        };
        var Global = typeof domGlobals.window !== "undefined" ? domGlobals.window : Function("return this;")();
        var path = function(parts, scope) {
          var o = scope !== void 0 && scope !== null ? scope : Global;
          for (var i2 = 0; i2 < parts.length && o !== void 0 && o !== null; ++i2) {
            o = o[parts[i2]];
          }
          return o;
        };
        var resolve = function(p, scope) {
          var parts = p.split(".");
          return path(parts, scope);
        };
        var unsafe = function(name2, scope) {
          return resolve(name2, scope);
        };
        var getOrDie = function(name2, scope) {
          var actual = unsafe(name2, scope);
          if (actual === void 0 || actual === null) {
            throw new Error(name2 + " not available on this browser");
          }
          return actual;
        };
        var Global$1 = { getOrDie };
        var url = function() {
          return Global$1.getOrDie("URL");
        };
        var createObjectURL = function(blob) {
          return url().createObjectURL(blob);
        };
        var revokeObjectURL = function(u) {
          url().revokeObjectURL(u);
        };
        var URL = {
          createObjectURL,
          revokeObjectURL
        };
        var nav = domGlobals.navigator, userAgent = nav.userAgent;
        var opera, webkit, ie, ie11, ie12, gecko, mac, iDevice, android, fileApi, phone, tablet, windowsPhone;
        var matchMediaQuery = function(query) {
          return "matchMedia" in domGlobals.window ? domGlobals.matchMedia(query).matches : false;
        };
        opera = false;
        android = /Android/.test(userAgent);
        webkit = /WebKit/.test(userAgent);
        ie = !webkit && !opera && /MSIE/gi.test(userAgent) && /Explorer/gi.test(nav.appName);
        ie = ie && /MSIE (\w+)\./.exec(userAgent)[1];
        ie11 = userAgent.indexOf("Trident/") !== -1 && (userAgent.indexOf("rv:") !== -1 || nav.appName.indexOf("Netscape") !== -1) ? 11 : false;
        ie12 = userAgent.indexOf("Edge/") !== -1 && !ie && !ie11 ? 12 : false;
        ie = ie || ie11 || ie12;
        gecko = !webkit && !ie11 && /Gecko/.test(userAgent);
        mac = userAgent.indexOf("Mac") !== -1;
        iDevice = /(iPad|iPhone)/.test(userAgent);
        fileApi = "FormData" in domGlobals.window && "FileReader" in domGlobals.window && "URL" in domGlobals.window && !!URL.createObjectURL;
        phone = matchMediaQuery("only screen and (max-device-width: 480px)") && (android || iDevice);
        tablet = matchMediaQuery("only screen and (min-width: 800px)") && (android || iDevice);
        windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
        if (ie12) {
          webkit = false;
        }
        var contentEditable = !iDevice || fileApi || parseInt(userAgent.match(/AppleWebKit\/(\d*)/)[1], 10) >= 534;
        var Env = {
          opera,
          webkit,
          ie,
          gecko,
          mac,
          iOS: iDevice,
          android,
          contentEditable,
          transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          caretAfter: ie !== 8,
          range: domGlobals.window.getSelection && "Range" in domGlobals.window,
          documentMode: ie && !ie12 ? domGlobals.document.documentMode || 7 : 10,
          fileApi,
          ceFalse: ie === false || ie > 8,
          cacheSuffix: null,
          container: null,
          overrideViewPort: null,
          experimentalShadowDom: false,
          canHaveCSP: ie === false || ie > 11,
          desktop: !phone && !tablet,
          windowsPhone
        };
        var promise = function() {
          function bind2(fn, thisArg) {
            return function() {
              fn.apply(thisArg, arguments);
            };
          }
          var isArray2 = Array.isArray || function(value2) {
            return Object.prototype.toString.call(value2) === "[object Array]";
          };
          var Promise3 = function(fn) {
            if (typeof this !== "object") {
              throw new TypeError("Promises must be constructed via new");
            }
            if (typeof fn !== "function") {
              throw new TypeError("not a function");
            }
            this._state = null;
            this._value = null;
            this._deferreds = [];
            doResolve(fn, bind2(resolve2, this), bind2(reject, this));
          };
          var asap = Promise3.immediateFn || typeof setImmediate === "function" && setImmediate || function(fn) {
            setTimeout(fn, 1);
          };
          function handle2(deferred) {
            var me = this;
            if (this._state === null) {
              this._deferreds.push(deferred);
              return;
            }
            asap(function() {
              var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
              if (cb === null) {
                (me._state ? deferred.resolve : deferred.reject)(me._value);
                return;
              }
              var ret;
              try {
                ret = cb(me._value);
              } catch (e) {
                deferred.reject(e);
                return;
              }
              deferred.resolve(ret);
            });
          }
          function resolve2(newValue) {
            try {
              if (newValue === this) {
                throw new TypeError("A promise cannot be resolved with itself.");
              }
              if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                var then = newValue.then;
                if (typeof then === "function") {
                  doResolve(bind2(then, newValue), bind2(resolve2, this), bind2(reject, this));
                  return;
                }
              }
              this._state = true;
              this._value = newValue;
              finale.call(this);
            } catch (e) {
              reject.call(this, e);
            }
          }
          function reject(newValue) {
            this._state = false;
            this._value = newValue;
            finale.call(this);
          }
          function finale() {
            for (var i2 = 0, len = this._deferreds.length; i2 < len; i2++) {
              handle2.call(this, this._deferreds[i2]);
            }
            this._deferreds = null;
          }
          function Handler(onFulfilled, onRejected, resolve3, reject2) {
            this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
            this.onRejected = typeof onRejected === "function" ? onRejected : null;
            this.resolve = resolve3;
            this.reject = reject2;
          }
          function doResolve(fn, onFulfilled, onRejected) {
            var done2 = false;
            try {
              fn(function(value2) {
                if (done2) {
                  return;
                }
                done2 = true;
                onFulfilled(value2);
              }, function(reason) {
                if (done2) {
                  return;
                }
                done2 = true;
                onRejected(reason);
              });
            } catch (ex) {
              if (done2) {
                return;
              }
              done2 = true;
              onRejected(ex);
            }
          }
          Promise3.prototype.catch = function(onRejected) {
            return this.then(null, onRejected);
          };
          Promise3.prototype.then = function(onFulfilled, onRejected) {
            var me = this;
            return new Promise3(function(resolve3, reject2) {
              handle2.call(me, new Handler(onFulfilled, onRejected, resolve3, reject2));
            });
          };
          Promise3.all = function() {
            var args = Array.prototype.slice.call(arguments.length === 1 && isArray2(arguments[0]) ? arguments[0] : arguments);
            return new Promise3(function(resolve3, reject2) {
              if (args.length === 0) {
                return resolve3([]);
              }
              var remaining = args.length;
              function res(i3, val) {
                try {
                  if (val && (typeof val === "object" || typeof val === "function")) {
                    var then = val.then;
                    if (typeof then === "function") {
                      then.call(val, function(val2) {
                        res(i3, val2);
                      }, reject2);
                      return;
                    }
                  }
                  args[i3] = val;
                  if (--remaining === 0) {
                    resolve3(args);
                  }
                } catch (ex) {
                  reject2(ex);
                }
              }
              for (var i2 = 0; i2 < args.length; i2++) {
                res(i2, args[i2]);
              }
            });
          };
          Promise3.resolve = function(value2) {
            if (value2 && typeof value2 === "object" && value2.constructor === Promise3) {
              return value2;
            }
            return new Promise3(function(resolve3) {
              resolve3(value2);
            });
          };
          Promise3.reject = function(value2) {
            return new Promise3(function(resolve3, reject2) {
              reject2(value2);
            });
          };
          Promise3.race = function(values) {
            return new Promise3(function(resolve3, reject2) {
              for (var i2 = 0, len = values.length; i2 < len; i2++) {
                values[i2].then(resolve3, reject2);
              }
            });
          };
          return Promise3;
        };
        var promiseObj = window.Promise ? window.Promise : promise();
        var requestAnimationFramePromise;
        var requestAnimationFrame = function(callback, element) {
          var i2, requestAnimationFrameFunc = domGlobals.window.requestAnimationFrame;
          var vendors = [
            "ms",
            "moz",
            "webkit"
          ];
          var featurefill = function(callback2) {
            domGlobals.window.setTimeout(callback2, 0);
          };
          for (i2 = 0; i2 < vendors.length && !requestAnimationFrameFunc; i2++) {
            requestAnimationFrameFunc = domGlobals.window[vendors[i2] + "RequestAnimationFrame"];
          }
          if (!requestAnimationFrameFunc) {
            requestAnimationFrameFunc = featurefill;
          }
          requestAnimationFrameFunc(callback, element);
        };
        var wrappedSetTimeout = function(callback, time) {
          if (typeof time !== "number") {
            time = 0;
          }
          return setTimeout(callback, time);
        };
        var wrappedSetInterval = function(callback, time) {
          if (typeof time !== "number") {
            time = 1;
          }
          return setInterval(callback, time);
        };
        var wrappedClearTimeout = function(id) {
          return clearTimeout(id);
        };
        var wrappedClearInterval = function(id) {
          return clearInterval(id);
        };
        var debounce = function(callback, time) {
          var timer, func;
          func = function() {
            var args = arguments;
            clearTimeout(timer);
            timer = wrappedSetTimeout(function() {
              callback.apply(this, args);
            }, time);
          };
          func.stop = function() {
            clearTimeout(timer);
          };
          return func;
        };
        var Delay = {
          requestAnimationFrame: function(callback, element) {
            if (requestAnimationFramePromise) {
              requestAnimationFramePromise.then(callback);
              return;
            }
            requestAnimationFramePromise = new promiseObj(function(resolve2) {
              if (!element) {
                element = domGlobals.document.body;
              }
              requestAnimationFrame(resolve2, element);
            }).then(callback);
          },
          setTimeout: wrappedSetTimeout,
          setInterval: wrappedSetInterval,
          setEditorTimeout: function(editor, callback, time) {
            return wrappedSetTimeout(function() {
              if (!editor.removed) {
                callback();
              }
            }, time);
          },
          setEditorInterval: function(editor, callback, time) {
            var timer;
            timer = wrappedSetInterval(function() {
              if (!editor.removed) {
                callback();
              } else {
                clearInterval(timer);
              }
            }, time);
            return timer;
          },
          debounce,
          throttle: debounce,
          clearInterval: wrappedClearInterval,
          clearTimeout: wrappedClearTimeout
        };
        var eventExpandoPrefix = "mce-data-";
        var mouseEventRe = /^(?:mouse|contextmenu)|click/;
        var deprecated = {
          keyLocation: 1,
          layerX: 1,
          layerY: 1,
          returnValue: 1,
          webkitMovementX: 1,
          webkitMovementY: 1,
          keyIdentifier: 1
        };
        var hasIsDefaultPrevented = function(event) {
          return event.isDefaultPrevented === returnTrue || event.isDefaultPrevented === returnFalse;
        };
        var returnFalse = function() {
          return false;
        };
        var returnTrue = function() {
          return true;
        };
        var addEvent = function(target, name2, callback, capture) {
          if (target.addEventListener) {
            target.addEventListener(name2, callback, capture || false);
          } else if (target.attachEvent) {
            target.attachEvent("on" + name2, callback);
          }
        };
        var removeEvent = function(target, name2, callback, capture) {
          if (target.removeEventListener) {
            target.removeEventListener(name2, callback, capture || false);
          } else if (target.detachEvent) {
            target.detachEvent("on" + name2, callback);
          }
        };
        var getTargetFromShadowDom = function(event, defaultTarget) {
          if (event.composedPath) {
            var composedPath = event.composedPath();
            if (composedPath && composedPath.length > 0) {
              return composedPath[0];
            }
          }
          return defaultTarget;
        };
        var fix = function(originalEvent, data2) {
          var name2;
          var event = data2 || {};
          for (name2 in originalEvent) {
            if (!deprecated[name2]) {
              event[name2] = originalEvent[name2];
            }
          }
          if (!event.target) {
            event.target = event.srcElement || domGlobals.document;
          }
          if (Env.experimentalShadowDom) {
            event.target = getTargetFromShadowDom(originalEvent, event.target);
          }
          if (originalEvent && mouseEventRe.test(originalEvent.type) && originalEvent.pageX === void 0 && originalEvent.clientX !== void 0) {
            var eventDoc = event.target.ownerDocument || domGlobals.document;
            var doc2 = eventDoc.documentElement;
            var body = eventDoc.body;
            event.pageX = originalEvent.clientX + (doc2 && doc2.scrollLeft || body && body.scrollLeft || 0) - (doc2 && doc2.clientLeft || body && body.clientLeft || 0);
            event.pageY = originalEvent.clientY + (doc2 && doc2.scrollTop || body && body.scrollTop || 0) - (doc2 && doc2.clientTop || body && body.clientTop || 0);
          }
          event.preventDefault = function() {
            event.isDefaultPrevented = returnTrue;
            if (originalEvent) {
              if (originalEvent.preventDefault) {
                originalEvent.preventDefault();
              } else {
                originalEvent.returnValue = false;
              }
            }
          };
          event.stopPropagation = function() {
            event.isPropagationStopped = returnTrue;
            if (originalEvent) {
              if (originalEvent.stopPropagation) {
                originalEvent.stopPropagation();
              } else {
                originalEvent.cancelBubble = true;
              }
            }
          };
          event.stopImmediatePropagation = function() {
            event.isImmediatePropagationStopped = returnTrue;
            event.stopPropagation();
          };
          if (hasIsDefaultPrevented(event) === false) {
            event.isDefaultPrevented = returnFalse;
            event.isPropagationStopped = returnFalse;
            event.isImmediatePropagationStopped = returnFalse;
          }
          if (typeof event.metaKey === "undefined") {
            event.metaKey = false;
          }
          return event;
        };
        var bindOnReady = function(win, callback, eventUtils) {
          var doc2 = win.document, event = { type: "ready" };
          if (eventUtils.domLoaded) {
            callback(event);
            return;
          }
          var isDocReady = function() {
            return doc2.readyState === "complete" || doc2.readyState === "interactive" && doc2.body;
          };
          var readyHandler = function() {
            if (!eventUtils.domLoaded) {
              eventUtils.domLoaded = true;
              callback(event);
            }
          };
          var waitForDomLoaded = function() {
            if (isDocReady()) {
              removeEvent(doc2, "readystatechange", waitForDomLoaded);
              readyHandler();
            }
          };
          var tryScroll = function() {
            try {
              doc2.documentElement.doScroll("left");
            } catch (ex) {
              Delay.setTimeout(tryScroll);
              return;
            }
            readyHandler();
          };
          if (doc2.addEventListener && !(Env.ie && Env.ie < 11)) {
            if (isDocReady()) {
              readyHandler();
            } else {
              addEvent(win, "DOMContentLoaded", readyHandler);
            }
          } else {
            addEvent(doc2, "readystatechange", waitForDomLoaded);
            if (doc2.documentElement.doScroll && win.self === win.top) {
              tryScroll();
            }
          }
          addEvent(win, "load", readyHandler);
        };
        var EventUtils = function() {
          var self2 = this;
          var events = {}, count2, expando2, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;
          expando2 = eventExpandoPrefix + (+new Date()).toString(32);
          hasMouseEnterLeave = "onmouseenter" in domGlobals.document.documentElement;
          hasFocusIn = "onfocusin" in domGlobals.document.documentElement;
          mouseEnterLeave = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
          };
          count2 = 1;
          self2.domLoaded = false;
          self2.events = events;
          var executeHandlers = function(evt, id) {
            var callbackList, i2, l, callback;
            var container = events[id];
            callbackList = container && container[evt.type];
            if (callbackList) {
              for (i2 = 0, l = callbackList.length; i2 < l; i2++) {
                callback = callbackList[i2];
                if (callback && callback.func.call(callback.scope, evt) === false) {
                  evt.preventDefault();
                }
                if (evt.isImmediatePropagationStopped()) {
                  return;
                }
              }
            }
          };
          self2.bind = function(target, names, callback, scope) {
            var id, callbackList, i2, name2, fakeName, nativeHandler, capture;
            var win = domGlobals.window;
            var defaultNativeHandler = function(evt) {
              executeHandlers(fix(evt || win.event), id);
            };
            if (!target || target.nodeType === 3 || target.nodeType === 8) {
              return;
            }
            if (!target[expando2]) {
              id = count2++;
              target[expando2] = id;
              events[id] = {};
            } else {
              id = target[expando2];
            }
            scope = scope || target;
            names = names.split(" ");
            i2 = names.length;
            while (i2--) {
              name2 = names[i2];
              nativeHandler = defaultNativeHandler;
              fakeName = capture = false;
              if (name2 === "DOMContentLoaded") {
                name2 = "ready";
              }
              if (self2.domLoaded && name2 === "ready" && target.readyState === "complete") {
                callback.call(scope, fix({ type: name2 }));
                continue;
              }
              if (!hasMouseEnterLeave) {
                fakeName = mouseEnterLeave[name2];
                if (fakeName) {
                  nativeHandler = function(evt) {
                    var current, related;
                    current = evt.currentTarget;
                    related = evt.relatedTarget;
                    if (related && current.contains) {
                      related = current.contains(related);
                    } else {
                      while (related && related !== current) {
                        related = related.parentNode;
                      }
                    }
                    if (!related) {
                      evt = fix(evt || win.event);
                      evt.type = evt.type === "mouseout" ? "mouseleave" : "mouseenter";
                      evt.target = current;
                      executeHandlers(evt, id);
                    }
                  };
                }
              }
              if (!hasFocusIn && (name2 === "focusin" || name2 === "focusout")) {
                capture = true;
                fakeName = name2 === "focusin" ? "focus" : "blur";
                nativeHandler = function(evt) {
                  evt = fix(evt || win.event);
                  evt.type = evt.type === "focus" ? "focusin" : "focusout";
                  executeHandlers(evt, id);
                };
              }
              callbackList = events[id][name2];
              if (!callbackList) {
                events[id][name2] = callbackList = [{
                  func: callback,
                  scope
                }];
                callbackList.fakeName = fakeName;
                callbackList.capture = capture;
                callbackList.nativeHandler = nativeHandler;
                if (name2 === "ready") {
                  bindOnReady(target, nativeHandler, self2);
                } else {
                  addEvent(target, fakeName || name2, nativeHandler, capture);
                }
              } else {
                if (name2 === "ready" && self2.domLoaded) {
                  callback({ type: name2 });
                } else {
                  callbackList.push({
                    func: callback,
                    scope
                  });
                }
              }
            }
            target = callbackList = 0;
            return callback;
          };
          self2.unbind = function(target, names, callback) {
            var id, callbackList, i2, ci, name2, eventMap;
            if (!target || target.nodeType === 3 || target.nodeType === 8) {
              return self2;
            }
            id = target[expando2];
            if (id) {
              eventMap = events[id];
              if (names) {
                names = names.split(" ");
                i2 = names.length;
                while (i2--) {
                  name2 = names[i2];
                  callbackList = eventMap[name2];
                  if (callbackList) {
                    if (callback) {
                      ci = callbackList.length;
                      while (ci--) {
                        if (callbackList[ci].func === callback) {
                          var nativeHandler = callbackList.nativeHandler;
                          var fakeName = callbackList.fakeName, capture = callbackList.capture;
                          callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                          callbackList.nativeHandler = nativeHandler;
                          callbackList.fakeName = fakeName;
                          callbackList.capture = capture;
                          eventMap[name2] = callbackList;
                        }
                      }
                    }
                    if (!callback || callbackList.length === 0) {
                      delete eventMap[name2];
                      removeEvent(target, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
                    }
                  }
                }
              } else {
                for (name2 in eventMap) {
                  callbackList = eventMap[name2];
                  removeEvent(target, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
                }
                eventMap = {};
              }
              for (name2 in eventMap) {
                return self2;
              }
              delete events[id];
              try {
                delete target[expando2];
              } catch (ex) {
                target[expando2] = null;
              }
            }
            return self2;
          };
          self2.fire = function(target, name2, args) {
            var id;
            if (!target || target.nodeType === 3 || target.nodeType === 8) {
              return self2;
            }
            args = fix(null, args);
            args.type = name2;
            args.target = target;
            do {
              id = target[expando2];
              if (id) {
                executeHandlers(args, id);
              }
              target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
            } while (target && !args.isPropagationStopped());
            return self2;
          };
          self2.clean = function(target) {
            var i2, children2;
            var unbind = self2.unbind;
            if (!target || target.nodeType === 3 || target.nodeType === 8) {
              return self2;
            }
            if (target[expando2]) {
              unbind(target);
            }
            if (!target.getElementsByTagName) {
              target = target.document;
            }
            if (target && target.getElementsByTagName) {
              unbind(target);
              children2 = target.getElementsByTagName("*");
              i2 = children2.length;
              while (i2--) {
                target = children2[i2];
                if (target[expando2]) {
                  unbind(target);
                }
              }
            }
            return self2;
          };
          self2.destroy = function() {
            events = {};
          };
          self2.cancel = function(e) {
            if (e) {
              e.preventDefault();
              e.stopImmediatePropagation();
            }
            return false;
          };
        };
        EventUtils.Event = new EventUtils();
        EventUtils.Event.bind(domGlobals.window, "ready", function() {
        });
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains$1, expando = "sizzle" + -new Date(), preferredDoc = domGlobals.window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        }, strundefined = "undefined", MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf$1 = arr.indexOf || function(elem) {
          var i2 = 0, len = this.length;
          for (; i2 < len; i2++) {
            if (this[i2] === elem) {
              return i2;
            }
          }
          return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + `*([^\\]'"]*?)` + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 65536;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        };
        try {
          push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push = {
            apply: arr.length ? function(target, els) {
              push_native.apply(target, slice.call(els));
            } : function(target, els) {
              var j = target.length, i2 = 0;
              while (target[j++] = els[i2++]) {
              }
              target.length = j - 1;
            }
          };
        }
        var Sizzle = function(selector, context2, results, seed2) {
          var match2, elem, m, nodeType, i2, groups, old, nid, newContext, newSelector;
          if ((context2 ? context2.ownerDocument || context2 : preferredDoc) !== document) {
            setDocument(context2);
          }
          context2 = context2 || document;
          results = results || [];
          if (!selector || typeof selector !== "string") {
            return results;
          }
          if ((nodeType = context2.nodeType) !== 1 && nodeType !== 9) {
            return [];
          }
          if (documentIsHTML && !seed2) {
            if (match2 = rquickExpr.exec(selector)) {
              if (m = match2[1]) {
                if (nodeType === 9) {
                  elem = context2.getElementById(m);
                  if (elem && elem.parentNode) {
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }
                } else {
                  if (context2.ownerDocument && (elem = context2.ownerDocument.getElementById(m)) && contains$1(context2, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                }
              } else if (match2[2]) {
                push.apply(results, context2.getElementsByTagName(selector));
                return results;
              } else if ((m = match2[3]) && support.getElementsByClassName) {
                push.apply(results, context2.getElementsByClassName(m));
                return results;
              }
            }
            if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              nid = old = expando;
              newContext = context2;
              newSelector = nodeType === 9 && selector;
              if (nodeType === 1 && context2.nodeName.toLowerCase() !== "object") {
                groups = tokenize(selector);
                if (old = context2.getAttribute("id")) {
                  nid = old.replace(rescape, "\\$&");
                } else {
                  context2.setAttribute("id", nid);
                }
                nid = "[id='" + nid + "'] ";
                i2 = groups.length;
                while (i2--) {
                  groups[i2] = nid + toSelector(groups[i2]);
                }
                newContext = rsibling.test(selector) && testContext(context2.parentNode) || context2;
                newSelector = groups.join(",");
              }
              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                } finally {
                  if (!old) {
                    context2.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim, "$1"), context2, results, seed2);
        };
        function createCache() {
          var keys2 = [];
          function cache(key, value2) {
            if (keys2.push(key + " ") > Expr.cacheLength) {
              delete cache[keys2.shift()];
            }
            return cache[key + " "] = value2;
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function siblingCheck(a, b) {
          var cur = b && a, diff2 = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
          if (diff2) {
            return diff2;
          }
          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type2) {
          return function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return name2 === "input" && elem.type === type2;
          };
        }
        function createButtonPseudo(type2) {
          return function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return (name2 === "input" || name2 === "button") && elem.type === type2;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed2, matches2) {
              var j, matchIndexes = fn([], seed2.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed2[j = matchIndexes[i2]]) {
                  seed2[j] = !(matches2[j] = seed2[j]);
                }
              }
            });
          });
        }
        function testContext(context2) {
          return context2 && typeof context2.getElementsByTagName !== strundefined && context2;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
          var documentElement2 = elem && (elem.ownerDocument || elem).documentElement;
          return documentElement2 ? documentElement2.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node2) {
          var hasCompare, doc2 = node2 ? node2.ownerDocument || node2 : preferredDoc, parent2 = doc2.defaultView;
          function getTop(win) {
            try {
              return win.top;
            } catch (ex) {
            }
            return null;
          }
          if (doc2 === document || doc2.nodeType !== 9 || !doc2.documentElement) {
            return document;
          }
          document = doc2;
          docElem = doc2.documentElement;
          documentIsHTML = !isXML(doc2);
          if (parent2 && parent2 !== getTop(parent2)) {
            if (parent2.addEventListener) {
              parent2.addEventListener("unload", function() {
                setDocument();
              }, false);
            } else if (parent2.attachEvent) {
              parent2.attachEvent("onunload", function() {
                setDocument();
              });
            }
          }
          support.attributes = true;
          support.getElementsByTagName = true;
          support.getElementsByClassName = rnative.test(doc2.getElementsByClassName);
          support.getById = true;
          Expr.find.ID = function(id, context2) {
            if (typeof context2.getElementById !== strundefined && documentIsHTML) {
              var m = context2.getElementById(id);
              return m && m.parentNode ? [m] : [];
            }
          };
          Expr.filter.ID = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find.TAG = support.getElementsByTagName ? function(tag, context2) {
            if (typeof context2.getElementsByTagName !== strundefined) {
              return context2.getElementsByTagName(tag);
            }
          } : function(tag, context2) {
            var elem, tmp = [], i2 = 0, results = context2.getElementsByTagName(tag);
            if (tag === "*") {
              while (elem = results[i2++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find.CLASS = support.getElementsByClassName && function(className, context2) {
            if (documentIsHTML) {
              return context2.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          support.disconnectedMatch = true;
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains$1 = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while (b = b.parentNode) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
            if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
              if (a === doc2 || a.ownerDocument === preferredDoc && contains$1(preferredDoc, a)) {
                return -1;
              }
              if (b === doc2 || b.ownerDocument === preferredDoc && contains$1(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? indexOf$1.call(sortInput, a) - indexOf$1.call(sortInput, b) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
            if (!aup || !bup) {
              return a === doc2 ? -1 : b === doc2 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf$1.call(sortInput, a) - indexOf$1.call(sortInput, b) : 0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while (cur = cur.parentNode) {
              ap.unshift(cur);
            }
            cur = b;
            while (cur = cur.parentNode) {
              bp.unshift(cur);
            }
            while (ap[i2] === bp[i2]) {
              i2++;
            }
            return i2 ? siblingCheck(ap[i2], bp[i2]) : ap[i2] === preferredDoc ? -1 : bp[i2] === preferredDoc ? 1 : 0;
          };
          return doc2;
        };
        Sizzle.matches = function(expr, elements) {
          return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }
          expr = expr.replace(rattributeQuotes, "='$1']");
          if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
            }
          }
          return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function(context2, elem) {
          if ((context2.ownerDocument || context2) !== document) {
            setDocument(context2);
          }
          return contains$1(context2, elem);
        };
        Sizzle.attr = function(elem, name2) {
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
          return val !== void 0 ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i2 = 0;
          hasDuplicate = !support.detectDuplicates;
          sortInput = !support.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j = duplicates.push(i2);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle.getText = function(elem) {
          var node2, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node2 = elem[i2++]) {
              ret += getText(node2);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle.selectors = {
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": {
              dir: "parentNode",
              first: true
            },
            " ": { dir: "parentNode" },
            "+": {
              dir: "previousSibling",
              first: true
            },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match2) {
              match2[1] = match2[1].replace(runescape, funescape);
              match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
              if (match2[2] === "~=") {
                match2[3] = " " + match2[3] + " ";
              }
              return match2.slice(0, 4);
            },
            CHILD: function(match2) {
              match2[1] = match2[1].toLowerCase();
              if (match2[1].slice(0, 3) === "nth") {
                if (!match2[3]) {
                  Sizzle.error(match2[0]);
                }
                match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
                match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
              } else if (match2[3]) {
                Sizzle.error(match2[0]);
              }
              return match2;
            },
            PSEUDO: function(match2) {
              var excess, unquoted = !match2[6] && match2[2];
              if (matchExpr.CHILD.test(match2[0])) {
                return null;
              }
              if (match2[3]) {
                match2[2] = match2[4] || match2[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match2[0] = match2[0].slice(0, excess);
                match2[2] = unquoted.slice(0, excess);
              }
              return match2.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
              });
            },
            ATTR: function(name2, operator, check) {
              return function(elem) {
                var result = Sizzle.attr(elem, name2);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            CHILD: function(type2, what, argument, first2, last2) {
              var simple = type2.slice(0, 3) !== "nth", forward = type2.slice(-4) !== "last", ofType = what === "of-type";
              return first2 === 1 && last2 === 0 ? function(elem) {
                return !!elem.parentNode;
              } : function(elem, context2, xml) {
                var cache, outerCache, node2, diff2, nodeIndex2, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                if (parent2) {
                  if (simple) {
                    while (dir2) {
                      node2 = elem;
                      while (node2 = node2[dir2]) {
                        if (ofType ? node2.nodeName.toLowerCase() === name2 : node2.nodeType === 1) {
                          return false;
                        }
                      }
                      start2 = dir2 = type2 === "only" && !start2 && "nextSibling";
                    }
                    return true;
                  }
                  start2 = [forward ? parent2.firstChild : parent2.lastChild];
                  if (forward && useCache) {
                    outerCache = parent2[expando] || (parent2[expando] = {});
                    cache = outerCache[type2] || [];
                    nodeIndex2 = cache[0] === dirruns && cache[1];
                    diff2 = cache[0] === dirruns && cache[2];
                    node2 = nodeIndex2 && parent2.childNodes[nodeIndex2];
                    while (node2 = ++nodeIndex2 && node2 && node2[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                      if (node2.nodeType === 1 && ++diff2 && node2 === elem) {
                        outerCache[type2] = [
                          dirruns,
                          nodeIndex2,
                          diff2
                        ];
                        break;
                      }
                    }
                  } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type2]) && cache[0] === dirruns) {
                    diff2 = cache[1];
                  } else {
                    while (node2 = ++nodeIndex2 && node2 && node2[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                      if ((ofType ? node2.nodeName.toLowerCase() === name2 : node2.nodeType === 1) && ++diff2) {
                        if (useCache) {
                          (node2[expando] || (node2[expando] = {}))[type2] = [
                            dirruns,
                            diff2
                          ];
                        }
                        if (node2 === elem) {
                          break;
                        }
                      }
                    }
                  }
                  diff2 -= last2;
                  return diff2 === first2 || diff2 % first2 === 0 && diff2 / first2 >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [
                  pseudo,
                  pseudo,
                  "",
                  argument
                ];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed2, matches2) {
                  var idx, matched = fn(seed2, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf$1.call(seed2, matched[i2]);
                    seed2[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            not: markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
              return matcher[expando] ? markFunction(function(seed2, matches2, context2, xml) {
                var elem, unmatched = matcher(seed2, null, xml, []), i2 = seed2.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed2[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, context2, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return Sizzle(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
              };
            }),
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            target: function(elem) {
              var hash = domGlobals.window.location && domGlobals.window.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === docElem;
            },
            focus: function(elem) {
              return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            enabled: function(elem) {
              return elem.disabled === false;
            },
            disabled: function(elem) {
              return elem.disabled === true;
            },
            checked: function(elem) {
              var nodeName = elem.nodeName.toLowerCase();
              return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              var name2 = elem.nodeName.toLowerCase();
              return name2 === "input" && elem.type === "button" || name2 === "button";
            },
            text: function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 0;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 1;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; ++i2 < length; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
          submit: true,
          reset: true
        }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
          var matched, match2, tokens, type2, soFar, groups, preFilters, cached2 = tokenCache[selector + " "];
          if (cached2) {
            return parseOnly ? 0 : cached2.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match2 = rcomma.exec(soFar))) {
              if (match2) {
                soFar = soFar.slice(match2[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match2 = rcombinators.exec(soFar)) {
              matched = match2.shift();
              tokens.push({
                value: matched,
                type: match2[0].replace(rtrim, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type2 in Expr.filter) {
              if ((match2 = matchExpr[type2].exec(soFar)) && (!preFilters[type2] || (match2 = preFilters[type2](match2)))) {
                matched = match2.shift();
                tokens.push({
                  value: matched,
                  type: type2,
                  matches: match2
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, checkNonElements = base && dir2 === "parentNode", doneName = done++;
          return combinator.first ? function(elem, context2, xml) {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context2, xml);
              }
            }
          } : function(elem, context2, xml) {
            var oldCache, outerCache, newCache = [
              dirruns,
              doneName
            ];
            if (xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context2, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if ((oldCache = outerCache[dir2]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    return newCache[2] = oldCache[2];
                  } else {
                    outerCache[dir2] = newCache;
                    if (newCache[2] = matcher(elem, context2, xml)) {
                      return true;
                    }
                  }
                }
              }
            }
          };
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context2, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context2, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            Sizzle(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map2, filter2, context2, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter2 || filter2(elem, context2, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map2.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed2, results, context2, xml) {
            var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed2 || multipleContexts(selector || "*", context2.nodeType ? [context2] : context2, []), matcherIn = preFilter && (seed2 || !selector) ? condense(elems, preMap, preFilter, context2, xml) : elems, matcherOut = matcher ? postFinder || (seed2 ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context2, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context2, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed2) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf$1.call(seed2, elem) : preMap[i2]) > -1) {
                    seed2[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf$1.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context2, xml) {
            return !leadingRelative && (xml || context2 !== outermostContext) || ((checkContext = context2).nodeType ? matchContext(elem, context2, xml) : matchAnyContext(elem, context2, xml));
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j = ++i2;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(i2 > 1 && elementMatcher(matchers), i2 > 1 && toSelector(tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i2 < j && matcherFromTokens(tokens.slice(i2, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed2, context2, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed2 && [], setMatched = [], contextBackup = outermostContext, elems = seed2 || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context2 !== document && context2;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j = 0;
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context2, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed2) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context2, xml);
              }
              if (seed2) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed2 && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match2) {
          var i2, setMatchers = [], elementMatchers = [], cached2 = compilerCache[selector + " "];
          if (!cached2) {
            if (!match2) {
              match2 = tokenize(selector);
            }
            i2 = match2.length;
            while (i2--) {
              cached2 = matcherFromTokens(match2[i2]);
              if (cached2[expando]) {
                setMatchers.push(cached2);
              } else {
                elementMatchers.push(cached2);
              }
            }
            cached2 = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            cached2.selector = selector;
          }
          return cached2;
        };
        select = Sizzle.select = function(selector, context2, results, seed2) {
          var i2, tokens, token, type2, find2, compiled = typeof selector === "function" && selector, match2 = !seed2 && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match2.length === 1) {
            tokens = match2[0] = match2[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context2.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context2 = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context2) || [])[0];
              if (!context2) {
                return results;
              } else if (compiled) {
                context2 = context2.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i2--) {
              token = tokens[i2];
              if (Expr.relative[type2 = token.type]) {
                break;
              }
              if (find2 = Expr.find[type2]) {
                if (seed2 = find2(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context2.parentNode) || context2)) {
                  tokens.splice(i2, 1);
                  selector = seed2.length && toSelector(tokens);
                  if (!selector) {
                    push.apply(results, seed2);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match2))(seed2, context2, !documentIsHTML, results, rsibling.test(selector) && testContext(context2.parentNode) || context2);
          return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = true;
        var isArray$1 = Array.isArray;
        var toArray = function(obj) {
          var array = obj, i2, l;
          if (!isArray$1(obj)) {
            array = [];
            for (i2 = 0, l = obj.length; i2 < l; i2++) {
              array[i2] = obj[i2];
            }
          }
          return array;
        };
        var each$1 = function(o, cb, s) {
          var n, l;
          if (!o) {
            return 0;
          }
          s = s || o;
          if (o.length !== void 0) {
            for (n = 0, l = o.length; n < l; n++) {
              if (cb.call(s, o[n], n, o) === false) {
                return 0;
              }
            }
          } else {
            for (n in o) {
              if (o.hasOwnProperty(n)) {
                if (cb.call(s, o[n], n, o) === false) {
                  return 0;
                }
              }
            }
          }
          return 1;
        };
        var map$1 = function(array, callback) {
          var out = [];
          each$1(array, function(item, index) {
            out.push(callback(item, index, array));
          });
          return out;
        };
        var filter$1 = function(a, f) {
          var o = [];
          each$1(a, function(v, index) {
            if (!f || f(v, index, a)) {
              o.push(v);
            }
          });
          return o;
        };
        var indexOf$2 = function(a, v) {
          var i2, l;
          if (a) {
            for (i2 = 0, l = a.length; i2 < l; i2++) {
              if (a[i2] === v) {
                return i2;
              }
            }
          }
          return -1;
        };
        var reduce = function(collection, iteratee, accumulator, thisArg) {
          var i2 = 0;
          if (arguments.length < 3) {
            accumulator = collection[0];
          }
          for (; i2 < collection.length; i2++) {
            accumulator = iteratee.call(thisArg, accumulator, collection[i2], i2);
          }
          return accumulator;
        };
        var findIndex$1 = function(array, predicate, thisArg) {
          var i2, l;
          for (i2 = 0, l = array.length; i2 < l; i2++) {
            if (predicate.call(thisArg, array[i2], i2, array)) {
              return i2;
            }
          }
          return -1;
        };
        var find$1 = function(array, predicate, thisArg) {
          var idx = findIndex$1(array, predicate, thisArg);
          if (idx !== -1) {
            return array[idx];
          }
          return void 0;
        };
        var last$1 = function(collection) {
          return collection[collection.length - 1];
        };
        var ArrUtils = {
          isArray: isArray$1,
          toArray,
          each: each$1,
          map: map$1,
          filter: filter$1,
          indexOf: indexOf$2,
          reduce,
          findIndex: findIndex$1,
          find: find$1,
          last: last$1
        };
        var whiteSpaceRegExp = /^\s*|\s*$/g;
        var trim = function(str) {
          return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp, "");
        };
        var is = function(obj, type2) {
          if (!type2) {
            return obj !== void 0;
          }
          if (type2 === "array" && ArrUtils.isArray(obj)) {
            return true;
          }
          return typeof obj === type2;
        };
        var makeMap = function(items, delim, map2) {
          var i2;
          items = items || [];
          delim = delim || ",";
          if (typeof items === "string") {
            items = items.split(delim);
          }
          map2 = map2 || {};
          i2 = items.length;
          while (i2--) {
            map2[items[i2]] = {};
          }
          return map2;
        };
        var hasOwnProperty = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
        var create = function(s, p, root) {
          var self2 = this;
          var sp, ns, cn, scn, c, de = 0;
          s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
          cn = s[3].match(/(^|\.)(\w+)$/i)[2];
          ns = self2.createNS(s[3].replace(/\.\w+$/, ""), root);
          if (ns[cn]) {
            return;
          }
          if (s[2] === "static") {
            ns[cn] = p;
            if (this.onCreate) {
              this.onCreate(s[2], s[3], ns[cn]);
            }
            return;
          }
          if (!p[cn]) {
            p[cn] = function() {
            };
            de = 1;
          }
          ns[cn] = p[cn];
          self2.extend(ns[cn].prototype, p);
          if (s[5]) {
            sp = self2.resolve(s[5]).prototype;
            scn = s[5].match(/\.(\w+)$/i)[1];
            c = ns[cn];
            if (de) {
              ns[cn] = function() {
                return sp[scn].apply(this, arguments);
              };
            } else {
              ns[cn] = function() {
                this.parent = sp[scn];
                return c.apply(this, arguments);
              };
            }
            ns[cn].prototype[cn] = ns[cn];
            self2.each(sp, function(f, n) {
              ns[cn].prototype[n] = sp[n];
            });
            self2.each(p, function(f, n) {
              if (sp[n]) {
                ns[cn].prototype[n] = function() {
                  this.parent = sp[n];
                  return f.apply(this, arguments);
                };
              } else {
                if (n !== cn) {
                  ns[cn].prototype[n] = f;
                }
              }
            });
          }
          self2.each(p.static, function(f, n) {
            ns[cn][n] = f;
          });
        };
        var extend = function(obj, ext) {
          var x = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            x[_i - 2] = arguments[_i];
          }
          var i2, l, name2;
          var args = arguments;
          var value2;
          for (i2 = 1, l = args.length; i2 < l; i2++) {
            ext = args[i2];
            for (name2 in ext) {
              if (ext.hasOwnProperty(name2)) {
                value2 = ext[name2];
                if (value2 !== void 0) {
                  obj[name2] = value2;
                }
              }
            }
          }
          return obj;
        };
        var walk = function(o, f, n, s) {
          s = s || this;
          if (o) {
            if (n) {
              o = o[n];
            }
            ArrUtils.each(o, function(o2, i2) {
              if (f.call(s, o2, i2, n) === false) {
                return false;
              }
              walk(o2, f, n, s);
            });
          }
        };
        var createNS = function(n, o) {
          var i2, v;
          o = o || domGlobals.window;
          n = n.split(".");
          for (i2 = 0; i2 < n.length; i2++) {
            v = n[i2];
            if (!o[v]) {
              o[v] = {};
            }
            o = o[v];
          }
          return o;
        };
        var resolve$1 = function(n, o) {
          var i2, l;
          o = o || domGlobals.window;
          n = n.split(".");
          for (i2 = 0, l = n.length; i2 < l; i2++) {
            o = o[n[i2]];
            if (!o) {
              break;
            }
          }
          return o;
        };
        var explode = function(s, d) {
          if (!s || is(s, "array")) {
            return s;
          }
          return ArrUtils.map(s.split(d || ","), trim);
        };
        var _addCacheSuffix = function(url2) {
          var cacheSuffix = Env.cacheSuffix;
          if (cacheSuffix) {
            url2 += (url2.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
          }
          return url2;
        };
        var Tools = {
          trim,
          isArray: ArrUtils.isArray,
          is,
          toArray: ArrUtils.toArray,
          makeMap,
          each: ArrUtils.each,
          map: ArrUtils.map,
          grep: ArrUtils.filter,
          inArray: ArrUtils.indexOf,
          hasOwn: hasOwnProperty,
          extend,
          create,
          walk,
          createNS,
          resolve: resolve$1,
          explode,
          _addCacheSuffix
        };
        var doc = domGlobals.document, push$1 = Array.prototype.push, slice$1 = Array.prototype.slice;
        var rquickExpr$1 = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
        var Event = EventUtils.Event;
        var skipUniques = Tools.makeMap("children,contents,next,prev");
        var isDefined = function(obj) {
          return typeof obj !== "undefined";
        };
        var isString$1 = function(obj) {
          return typeof obj === "string";
        };
        var isWindow = function(obj) {
          return obj && obj === obj.window;
        };
        var createFragment = function(html, fragDoc) {
          var frag, node2, container;
          fragDoc = fragDoc || doc;
          container = fragDoc.createElement("div");
          frag = fragDoc.createDocumentFragment();
          container.innerHTML = html;
          while (node2 = container.firstChild) {
            frag.appendChild(node2);
          }
          return frag;
        };
        var domManipulate = function(targetNodes, sourceItem, callback, reverse2) {
          var i2;
          if (isString$1(sourceItem)) {
            sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
          } else if (sourceItem.length && !sourceItem.nodeType) {
            sourceItem = DomQuery.makeArray(sourceItem);
            if (reverse2) {
              for (i2 = sourceItem.length - 1; i2 >= 0; i2--) {
                domManipulate(targetNodes, sourceItem[i2], callback, reverse2);
              }
            } else {
              for (i2 = 0; i2 < sourceItem.length; i2++) {
                domManipulate(targetNodes, sourceItem[i2], callback, reverse2);
              }
            }
            return targetNodes;
          }
          if (sourceItem.nodeType) {
            i2 = targetNodes.length;
            while (i2--) {
              callback.call(targetNodes[i2], sourceItem);
            }
          }
          return targetNodes;
        };
        var hasClass = function(node2, className) {
          return node2 && className && (" " + node2.className + " ").indexOf(" " + className + " ") !== -1;
        };
        var wrap = function(elements, wrapper, all2) {
          var lastParent, newWrapper;
          wrapper = DomQuery(wrapper)[0];
          elements.each(function() {
            var self2 = this;
            if (!all2 || lastParent !== self2.parentNode) {
              lastParent = self2.parentNode;
              newWrapper = wrapper.cloneNode(false);
              self2.parentNode.insertBefore(newWrapper, self2);
              newWrapper.appendChild(self2);
            } else {
              newWrapper.appendChild(self2);
            }
          });
          return elements;
        };
        var numericCssMap = Tools.makeMap("fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom", " ");
        var booleanMap = Tools.makeMap("checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected", " ");
        var propFix = {
          for: "htmlFor",
          class: "className",
          readonly: "readOnly"
        };
        var cssFix = { float: "cssFloat" };
        var attrHooks = {}, cssHooks = {};
        var DomQuery = function(selector, context2) {
          return new DomQuery.fn.init(selector, context2);
        };
        var inArray = function(item, array) {
          var i2;
          if (array.indexOf) {
            return array.indexOf(item);
          }
          i2 = array.length;
          while (i2--) {
            if (array[i2] === item) {
              return i2;
            }
          }
          return -1;
        };
        var whiteSpaceRegExp$1 = /^\s*|\s*$/g;
        var trim$1 = function(str) {
          return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp$1, "");
        };
        var each$2 = function(obj, callback) {
          var length, key, i2, value2;
          if (obj) {
            length = obj.length;
            if (length === void 0) {
              for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                  value2 = obj[key];
                  if (callback.call(value2, key, value2) === false) {
                    break;
                  }
                }
              }
            } else {
              for (i2 = 0; i2 < length; i2++) {
                value2 = obj[i2];
                if (callback.call(value2, i2, value2) === false) {
                  break;
                }
              }
            }
          }
          return obj;
        };
        var grep = function(array, callback) {
          var out = [];
          each$2(array, function(i2, item) {
            if (callback(item, i2)) {
              out.push(item);
            }
          });
          return out;
        };
        var getElementDocument = function(element) {
          if (!element) {
            return doc;
          }
          if (element.nodeType === 9) {
            return element;
          }
          return element.ownerDocument;
        };
        DomQuery.fn = DomQuery.prototype = {
          constructor: DomQuery,
          selector: "",
          context: null,
          length: 0,
          init: function(selector, context2) {
            var self2 = this;
            var match2, node2;
            if (!selector) {
              return self2;
            }
            if (selector.nodeType) {
              self2.context = self2[0] = selector;
              self2.length = 1;
              return self2;
            }
            if (context2 && context2.nodeType) {
              self2.context = context2;
            } else {
              if (context2) {
                return DomQuery(selector).attr(context2);
              }
              self2.context = context2 = domGlobals.document;
            }
            if (isString$1(selector)) {
              self2.selector = selector;
              if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                match2 = [
                  null,
                  selector,
                  null
                ];
              } else {
                match2 = rquickExpr$1.exec(selector);
              }
              if (match2) {
                if (match2[1]) {
                  node2 = createFragment(selector, getElementDocument(context2)).firstChild;
                  while (node2) {
                    push$1.call(self2, node2);
                    node2 = node2.nextSibling;
                  }
                } else {
                  node2 = getElementDocument(context2).getElementById(match2[2]);
                  if (!node2) {
                    return self2;
                  }
                  if (node2.id !== match2[2]) {
                    return self2.find(selector);
                  }
                  self2.length = 1;
                  self2[0] = node2;
                }
              } else {
                return DomQuery(context2).find(selector);
              }
            } else {
              this.add(selector, false);
            }
            return self2;
          },
          toArray: function() {
            return Tools.toArray(this);
          },
          add: function(items, sort2) {
            var self2 = this;
            var nodes, i2;
            if (isString$1(items)) {
              return self2.add(DomQuery(items));
            }
            if (sort2 !== false) {
              nodes = DomQuery.unique(self2.toArray().concat(DomQuery.makeArray(items)));
              self2.length = nodes.length;
              for (i2 = 0; i2 < nodes.length; i2++) {
                self2[i2] = nodes[i2];
              }
            } else {
              push$1.apply(self2, DomQuery.makeArray(items));
            }
            return self2;
          },
          attr: function(name2, value2) {
            var self2 = this;
            var hook;
            if (typeof name2 === "object") {
              each$2(name2, function(name3, value3) {
                self2.attr(name3, value3);
              });
            } else if (isDefined(value2)) {
              this.each(function() {
                var hook2;
                if (this.nodeType === 1) {
                  hook2 = attrHooks[name2];
                  if (hook2 && hook2.set) {
                    hook2.set(this, value2);
                    return;
                  }
                  if (value2 === null) {
                    this.removeAttribute(name2, 2);
                  } else {
                    this.setAttribute(name2, value2, 2);
                  }
                }
              });
            } else {
              if (self2[0] && self2[0].nodeType === 1) {
                hook = attrHooks[name2];
                if (hook && hook.get) {
                  return hook.get(self2[0], name2);
                }
                if (booleanMap[name2]) {
                  return self2.prop(name2) ? name2 : void 0;
                }
                value2 = self2[0].getAttribute(name2, 2);
                if (value2 === null) {
                  value2 = void 0;
                }
              }
              return value2;
            }
            return self2;
          },
          removeAttr: function(name2) {
            return this.attr(name2, null);
          },
          prop: function(name2, value2) {
            var self2 = this;
            name2 = propFix[name2] || name2;
            if (typeof name2 === "object") {
              each$2(name2, function(name3, value3) {
                self2.prop(name3, value3);
              });
            } else if (isDefined(value2)) {
              this.each(function() {
                if (this.nodeType === 1) {
                  this[name2] = value2;
                }
              });
            } else {
              if (self2[0] && self2[0].nodeType && name2 in self2[0]) {
                return self2[0][name2];
              }
              return value2;
            }
            return self2;
          },
          css: function(name2, value2) {
            var self2 = this;
            var elm, hook;
            var camel = function(name3) {
              return name3.replace(/-(\D)/g, function(a, b) {
                return b.toUpperCase();
              });
            };
            var dashed = function(name3) {
              return name3.replace(/[A-Z]/g, function(a) {
                return "-" + a;
              });
            };
            if (typeof name2 === "object") {
              each$2(name2, function(name3, value3) {
                self2.css(name3, value3);
              });
            } else {
              if (isDefined(value2)) {
                name2 = camel(name2);
                if (typeof value2 === "number" && !numericCssMap[name2]) {
                  value2 = value2.toString() + "px";
                }
                self2.each(function() {
                  var style = this.style;
                  hook = cssHooks[name2];
                  if (hook && hook.set) {
                    hook.set(this, value2);
                    return;
                  }
                  try {
                    this.style[cssFix[name2] || name2] = value2;
                  } catch (ex) {
                  }
                  if (value2 === null || value2 === "") {
                    if (style.removeProperty) {
                      style.removeProperty(dashed(name2));
                    } else {
                      style.removeAttribute(name2);
                    }
                  }
                });
              } else {
                elm = self2[0];
                hook = cssHooks[name2];
                if (hook && hook.get) {
                  return hook.get(elm);
                }
                if (elm.ownerDocument.defaultView) {
                  try {
                    return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name2));
                  } catch (ex) {
                    return void 0;
                  }
                } else if (elm.currentStyle) {
                  return elm.currentStyle[camel(name2)];
                } else {
                  return "";
                }
              }
            }
            return self2;
          },
          remove: function() {
            var self2 = this;
            var node2, i2 = this.length;
            while (i2--) {
              node2 = self2[i2];
              Event.clean(node2);
              if (node2.parentNode) {
                node2.parentNode.removeChild(node2);
              }
            }
            return this;
          },
          empty: function() {
            var self2 = this;
            var node2, i2 = this.length;
            while (i2--) {
              node2 = self2[i2];
              while (node2.firstChild) {
                node2.removeChild(node2.firstChild);
              }
            }
            return this;
          },
          html: function(value2) {
            var self2 = this;
            var i2;
            if (isDefined(value2)) {
              i2 = self2.length;
              try {
                while (i2--) {
                  self2[i2].innerHTML = value2;
                }
              } catch (ex) {
                DomQuery(self2[i2]).empty().append(value2);
              }
              return self2;
            }
            return self2[0] ? self2[0].innerHTML : "";
          },
          text: function(value2) {
            var self2 = this;
            var i2;
            if (isDefined(value2)) {
              i2 = self2.length;
              while (i2--) {
                if ("innerText" in self2[i2]) {
                  self2[i2].innerText = value2;
                } else {
                  self2[0].textContent = value2;
                }
              }
              return self2;
            }
            return self2[0] ? self2[0].innerText || self2[0].textContent : "";
          },
          append: function() {
            return domManipulate(this, arguments, function(node2) {
              if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
                this.appendChild(node2);
              }
            });
          },
          prepend: function() {
            return domManipulate(this, arguments, function(node2) {
              if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
                this.insertBefore(node2, this.firstChild);
              }
            }, true);
          },
          before: function() {
            var self2 = this;
            if (self2[0] && self2[0].parentNode) {
              return domManipulate(self2, arguments, function(node2) {
                this.parentNode.insertBefore(node2, this);
              });
            }
            return self2;
          },
          after: function() {
            var self2 = this;
            if (self2[0] && self2[0].parentNode) {
              return domManipulate(self2, arguments, function(node2) {
                this.parentNode.insertBefore(node2, this.nextSibling);
              }, true);
            }
            return self2;
          },
          appendTo: function(val) {
            DomQuery(val).append(this);
            return this;
          },
          prependTo: function(val) {
            DomQuery(val).prepend(this);
            return this;
          },
          replaceWith: function(content) {
            return this.before(content).remove();
          },
          wrap: function(content) {
            return wrap(this, content);
          },
          wrapAll: function(content) {
            return wrap(this, content, true);
          },
          wrapInner: function(content) {
            this.each(function() {
              DomQuery(this).contents().wrapAll(content);
            });
            return this;
          },
          unwrap: function() {
            return this.parent().each(function() {
              DomQuery(this).replaceWith(this.childNodes);
            });
          },
          clone: function() {
            var result = [];
            this.each(function() {
              result.push(this.cloneNode(true));
            });
            return DomQuery(result);
          },
          addClass: function(className) {
            return this.toggleClass(className, true);
          },
          removeClass: function(className) {
            return this.toggleClass(className, false);
          },
          toggleClass: function(className, state) {
            var self2 = this;
            if (typeof className !== "string") {
              return self2;
            }
            if (className.indexOf(" ") !== -1) {
              each$2(className.split(" "), function() {
                self2.toggleClass(this, state);
              });
            } else {
              self2.each(function(index, node2) {
                var existingClassName, classState;
                classState = hasClass(node2, className);
                if (classState !== state) {
                  existingClassName = node2.className;
                  if (classState) {
                    node2.className = trim$1((" " + existingClassName + " ").replace(" " + className + " ", " "));
                  } else {
                    node2.className += existingClassName ? " " + className : className;
                  }
                }
              });
            }
            return self2;
          },
          hasClass: function(className) {
            return hasClass(this[0], className);
          },
          each: function(callback) {
            return each$2(this, callback);
          },
          on: function(name2, callback) {
            return this.each(function() {
              Event.bind(this, name2, callback);
            });
          },
          off: function(name2, callback) {
            return this.each(function() {
              Event.unbind(this, name2, callback);
            });
          },
          trigger: function(name2) {
            return this.each(function() {
              if (typeof name2 === "object") {
                Event.fire(this, name2.type, name2);
              } else {
                Event.fire(this, name2);
              }
            });
          },
          show: function() {
            return this.css("display", "");
          },
          hide: function() {
            return this.css("display", "none");
          },
          slice: function() {
            return new DomQuery(slice$1.apply(this, arguments));
          },
          eq: function(index) {
            return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          find: function(selector) {
            var i2, l;
            var ret = [];
            for (i2 = 0, l = this.length; i2 < l; i2++) {
              DomQuery.find(selector, this[i2], ret);
            }
            return DomQuery(ret);
          },
          filter: function(selector) {
            if (typeof selector === "function") {
              return DomQuery(grep(this.toArray(), function(item, i2) {
                return selector(i2, item);
              }));
            }
            return DomQuery(DomQuery.filter(selector, this.toArray()));
          },
          closest: function(selector) {
            var result = [];
            if (selector instanceof DomQuery) {
              selector = selector[0];
            }
            this.each(function(i2, node2) {
              while (node2) {
                if (typeof selector === "string" && DomQuery(node2).is(selector)) {
                  result.push(node2);
                  break;
                } else if (node2 === selector) {
                  result.push(node2);
                  break;
                }
                node2 = node2.parentNode;
              }
            });
            return DomQuery(result);
          },
          offset: function(offset) {
            var elm, doc2, docElm;
            var x = 0, y = 0, pos;
            if (!offset) {
              elm = this[0];
              if (elm) {
                doc2 = elm.ownerDocument;
                docElm = doc2.documentElement;
                if (elm.getBoundingClientRect) {
                  pos = elm.getBoundingClientRect();
                  x = pos.left + (docElm.scrollLeft || doc2.body.scrollLeft) - docElm.clientLeft;
                  y = pos.top + (docElm.scrollTop || doc2.body.scrollTop) - docElm.clientTop;
                }
              }
              return {
                left: x,
                top: y
              };
            }
            return this.css(offset);
          },
          push: push$1,
          sort: [].sort,
          splice: [].splice
        };
        Tools.extend(DomQuery, {
          extend: Tools.extend,
          makeArray: function(object) {
            if (isWindow(object) || object.nodeType) {
              return [object];
            }
            return Tools.toArray(object);
          },
          inArray,
          isArray: Tools.isArray,
          each: each$2,
          trim: trim$1,
          grep,
          find: Sizzle,
          expr: Sizzle.selectors,
          unique: Sizzle.uniqueSort,
          text: Sizzle.getText,
          contains: Sizzle.contains,
          filter: function(expr, elems, not2) {
            var i2 = elems.length;
            if (not2) {
              expr = ":not(" + expr + ")";
            }
            while (i2--) {
              if (elems[i2].nodeType !== 1) {
                elems.splice(i2, 1);
              }
            }
            if (elems.length === 1) {
              elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
            } else {
              elems = DomQuery.find.matches(expr, elems);
            }
            return elems;
          }
        });
        var dir = function(el, prop, until) {
          var matched = [];
          var cur = el[prop];
          if (typeof until !== "string" && until instanceof DomQuery) {
            until = until[0];
          }
          while (cur && cur.nodeType !== 9) {
            if (until !== void 0) {
              if (cur === until) {
                break;
              }
              if (typeof until === "string" && DomQuery(cur).is(until)) {
                break;
              }
            }
            if (cur.nodeType === 1) {
              matched.push(cur);
            }
            cur = cur[prop];
          }
          return matched;
        };
        var sibling = function(node2, siblingName, nodeType, until) {
          var result = [];
          if (until instanceof DomQuery) {
            until = until[0];
          }
          for (; node2; node2 = node2[siblingName]) {
            if (nodeType && node2.nodeType !== nodeType) {
              continue;
            }
            if (until !== void 0) {
              if (node2 === until) {
                break;
              }
              if (typeof until === "string" && DomQuery(node2).is(until)) {
                break;
              }
            }
            result.push(node2);
          }
          return result;
        };
        var firstSibling = function(node2, siblingName, nodeType) {
          for (node2 = node2[siblingName]; node2; node2 = node2[siblingName]) {
            if (node2.nodeType === nodeType) {
              return node2;
            }
          }
          return null;
        };
        each$2({
          parent: function(node2) {
            var parent2 = node2.parentNode;
            return parent2 && parent2.nodeType !== 11 ? parent2 : null;
          },
          parents: function(node2) {
            return dir(node2, "parentNode");
          },
          next: function(node2) {
            return firstSibling(node2, "nextSibling", 1);
          },
          prev: function(node2) {
            return firstSibling(node2, "previousSibling", 1);
          },
          children: function(node2) {
            return sibling(node2.firstChild, "nextSibling", 1);
          },
          contents: function(node2) {
            return Tools.toArray((node2.nodeName === "iframe" ? node2.contentDocument || node2.contentWindow.document : node2).childNodes);
          }
        }, function(name2, fn) {
          DomQuery.fn[name2] = function(selector) {
            var self2 = this;
            var result = [];
            self2.each(function() {
              var nodes = fn.call(result, this, selector, result);
              if (nodes) {
                if (DomQuery.isArray(nodes)) {
                  result.push.apply(result, nodes);
                } else {
                  result.push(nodes);
                }
              }
            });
            if (this.length > 1) {
              if (!skipUniques[name2]) {
                result = DomQuery.unique(result);
              }
              if (name2.indexOf("parents") === 0) {
                result = result.reverse();
              }
            }
            result = DomQuery(result);
            if (selector) {
              return result.filter(selector);
            }
            return result;
          };
        });
        each$2({
          parentsUntil: function(node2, until) {
            return dir(node2, "parentNode", until);
          },
          nextUntil: function(node2, until) {
            return sibling(node2, "nextSibling", 1, until).slice(1);
          },
          prevUntil: function(node2, until) {
            return sibling(node2, "previousSibling", 1, until).slice(1);
          }
        }, function(name2, fn) {
          DomQuery.fn[name2] = function(selector, filter2) {
            var self2 = this;
            var result = [];
            self2.each(function() {
              var nodes = fn.call(result, this, selector, result);
              if (nodes) {
                if (DomQuery.isArray(nodes)) {
                  result.push.apply(result, nodes);
                } else {
                  result.push(nodes);
                }
              }
            });
            if (this.length > 1) {
              result = DomQuery.unique(result);
              if (name2.indexOf("parents") === 0 || name2 === "prevUntil") {
                result = result.reverse();
              }
            }
            result = DomQuery(result);
            if (filter2) {
              return result.filter(filter2);
            }
            return result;
          };
        });
        DomQuery.fn.is = function(selector) {
          return !!selector && this.filter(selector).length > 0;
        };
        DomQuery.fn.init.prototype = DomQuery.fn;
        DomQuery.overrideDefaults = function(callback) {
          var defaults;
          var sub = function(selector, context2) {
            defaults = defaults || callback();
            if (arguments.length === 0) {
              selector = defaults.element;
            }
            if (!context2) {
              context2 = defaults.context;
            }
            return new sub.fn.init(selector, context2);
          };
          DomQuery.extend(sub, this);
          return sub;
        };
        var appendHooks = function(targetHooks, prop, hooks) {
          each$2(hooks, function(name2, func) {
            targetHooks[name2] = targetHooks[name2] || {};
            targetHooks[name2][prop] = func;
          });
        };
        if (Env.ie && Env.ie < 8) {
          appendHooks(attrHooks, "get", {
            maxlength: function(elm) {
              var value2 = elm.maxLength;
              if (value2 === 2147483647) {
                return void 0;
              }
              return value2;
            },
            size: function(elm) {
              var value2 = elm.size;
              if (value2 === 20) {
                return void 0;
              }
              return value2;
            },
            class: function(elm) {
              return elm.className;
            },
            style: function(elm) {
              var value2 = elm.style.cssText;
              if (value2.length === 0) {
                return void 0;
              }
              return value2;
            }
          });
          appendHooks(attrHooks, "set", {
            class: function(elm, value2) {
              elm.className = value2;
            },
            style: function(elm, value2) {
              elm.style.cssText = value2;
            }
          });
        }
        if (Env.ie && Env.ie < 9) {
          cssFix.float = "styleFloat";
          appendHooks(cssHooks, "set", {
            opacity: function(elm, value2) {
              var style = elm.style;
              if (value2 === null || value2 === "") {
                style.removeAttribute("filter");
              } else {
                style.zoom = 1;
                style.filter = "alpha(opacity=" + value2 * 100 + ")";
              }
            }
          });
        }
        DomQuery.attrHooks = attrHooks;
        DomQuery.cssHooks = cssHooks;
        var cached = function(f) {
          var called = false;
          var r;
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (!called) {
              called = true;
              r = f.apply(null, args);
            }
            return r;
          };
        };
        var firstMatch = function(regexes, s) {
          for (var i2 = 0; i2 < regexes.length; i2++) {
            var x = regexes[i2];
            if (x.test(s)) {
              return x;
            }
          }
          return void 0;
        };
        var find$2 = function(regexes, agent) {
          var r = firstMatch(regexes, agent);
          if (!r) {
            return {
              major: 0,
              minor: 0
            };
          }
          var group = function(i2) {
            return Number(agent.replace(r, "$" + i2));
          };
          return nu(group(1), group(2));
        };
        var detect = function(versionRegexes, agent) {
          var cleanedAgent = String(agent).toLowerCase();
          if (versionRegexes.length === 0) {
            return unknown();
          }
          return find$2(versionRegexes, cleanedAgent);
        };
        var unknown = function() {
          return nu(0, 0);
        };
        var nu = function(major, minor) {
          return {
            major,
            minor
          };
        };
        var Version = {
          nu,
          detect,
          unknown
        };
        var edge = "Edge";
        var chrome = "Chrome";
        var ie$1 = "IE";
        var opera$1 = "Opera";
        var firefox = "Firefox";
        var safari = "Safari";
        var isBrowser = function(name2, current) {
          return function() {
            return current === name2;
          };
        };
        var unknown$1 = function() {
          return nu$1({
            current: void 0,
            version: Version.unknown()
          });
        };
        var nu$1 = function(info) {
          var current = info.current;
          var version = info.version;
          return {
            current,
            version,
            isEdge: isBrowser(edge, current),
            isChrome: isBrowser(chrome, current),
            isIE: isBrowser(ie$1, current),
            isOpera: isBrowser(opera$1, current),
            isFirefox: isBrowser(firefox, current),
            isSafari: isBrowser(safari, current)
          };
        };
        var Browser = {
          unknown: unknown$1,
          nu: nu$1,
          edge: constant(edge),
          chrome: constant(chrome),
          ie: constant(ie$1),
          opera: constant(opera$1),
          firefox: constant(firefox),
          safari: constant(safari)
        };
        var windows = "Windows";
        var ios = "iOS";
        var android$1 = "Android";
        var linux = "Linux";
        var osx = "OSX";
        var solaris = "Solaris";
        var freebsd = "FreeBSD";
        var isOS = function(name2, current) {
          return function() {
            return current === name2;
          };
        };
        var unknown$2 = function() {
          return nu$2({
            current: void 0,
            version: Version.unknown()
          });
        };
        var nu$2 = function(info) {
          var current = info.current;
          var version = info.version;
          return {
            current,
            version,
            isWindows: isOS(windows, current),
            isiOS: isOS(ios, current),
            isAndroid: isOS(android$1, current),
            isOSX: isOS(osx, current),
            isLinux: isOS(linux, current),
            isSolaris: isOS(solaris, current),
            isFreeBSD: isOS(freebsd, current)
          };
        };
        var OperatingSystem = {
          unknown: unknown$2,
          nu: nu$2,
          windows: constant(windows),
          ios: constant(ios),
          android: constant(android$1),
          linux: constant(linux),
          osx: constant(osx),
          solaris: constant(solaris),
          freebsd: constant(freebsd)
        };
        var DeviceType = function(os, browser2, userAgent2) {
          var isiPad = os.isiOS() && /ipad/i.test(userAgent2) === true;
          var isiPhone = os.isiOS() && !isiPad;
          var isAndroid3 = os.isAndroid() && os.version.major === 3;
          var isAndroid4 = os.isAndroid() && os.version.major === 4;
          var isTablet = isiPad || isAndroid3 || isAndroid4 && /mobile/i.test(userAgent2) === true;
          var isTouch2 = os.isiOS() || os.isAndroid();
          var isPhone = isTouch2 && !isTablet;
          var iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent2) === false;
          return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet),
            isPhone: constant(isPhone),
            isTouch: constant(isTouch2),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant(iOSwebview)
          };
        };
        var detect$1 = function(candidates, userAgent2) {
          var agent = String(userAgent2).toLowerCase();
          return find(candidates, function(candidate) {
            return candidate.search(agent);
          });
        };
        var detectBrowser = function(browsers2, userAgent2) {
          return detect$1(browsers2, userAgent2).map(function(browser2) {
            var version = Version.detect(browser2.versionRegexes, userAgent2);
            return {
              current: browser2.name,
              version
            };
          });
        };
        var detectOs = function(oses2, userAgent2) {
          return detect$1(oses2, userAgent2).map(function(os) {
            var version = Version.detect(os.versionRegexes, userAgent2);
            return {
              current: os.name,
              version
            };
          });
        };
        var UaString = {
          detectBrowser,
          detectOs
        };
        var contains$2 = function(str, substr) {
          return str.indexOf(substr) !== -1;
        };
        var trim$2 = function(str) {
          return str.replace(/^\s+|\s+$/g, "");
        };
        var lTrim = function(str) {
          return str.replace(/^\s+/g, "");
        };
        var rTrim = function(str) {
          return str.replace(/\s+$/g, "");
        };
        var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
        var checkContains = function(target) {
          return function(uastring) {
            return contains$2(uastring, target);
          };
        };
        var browsers = [
          {
            name: "Edge",
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search: function(uastring) {
              return contains$2(uastring, "edge/") && contains$2(uastring, "chrome") && contains$2(uastring, "safari") && contains$2(uastring, "applewebkit");
            }
          },
          {
            name: "Chrome",
            versionRegexes: [
              /.*?chrome\/([0-9]+)\.([0-9]+).*/,
              normalVersionRegex
            ],
            search: function(uastring) {
              return contains$2(uastring, "chrome") && !contains$2(uastring, "chromeframe");
            }
          },
          {
            name: "IE",
            versionRegexes: [
              /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
              /.*?rv:([0-9]+)\.([0-9]+).*/
            ],
            search: function(uastring) {
              return contains$2(uastring, "msie") || contains$2(uastring, "trident");
            }
          },
          {
            name: "Opera",
            versionRegexes: [
              normalVersionRegex,
              /.*?opera\/([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains("opera")
          },
          {
            name: "Firefox",
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains("firefox")
          },
          {
            name: "Safari",
            versionRegexes: [
              normalVersionRegex,
              /.*?cpu os ([0-9]+)_([0-9]+).*/
            ],
            search: function(uastring) {
              return (contains$2(uastring, "safari") || contains$2(uastring, "mobile/")) && contains$2(uastring, "applewebkit");
            }
          }
        ];
        var oses = [
          {
            name: "Windows",
            search: checkContains("win"),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "iOS",
            search: function(uastring) {
              return contains$2(uastring, "iphone") || contains$2(uastring, "ipad");
            },
            versionRegexes: [
              /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
              /.*cpu os ([0-9]+)_([0-9]+).*/,
              /.*cpu iphone os ([0-9]+)_([0-9]+).*/
            ]
          },
          {
            name: "Android",
            search: checkContains("android"),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "OSX",
            search: checkContains("os x"),
            versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
          },
          {
            name: "Linux",
            search: checkContains("linux"),
            versionRegexes: []
          },
          {
            name: "Solaris",
            search: checkContains("sunos"),
            versionRegexes: []
          },
          {
            name: "FreeBSD",
            search: checkContains("freebsd"),
            versionRegexes: []
          }
        ];
        var PlatformInfo = {
          browsers: constant(browsers),
          oses: constant(oses)
        };
        var detect$2 = function(userAgent2) {
          var browsers2 = PlatformInfo.browsers();
          var oses2 = PlatformInfo.oses();
          var browser2 = UaString.detectBrowser(browsers2, userAgent2).fold(Browser.unknown, Browser.nu);
          var os = UaString.detectOs(oses2, userAgent2).fold(OperatingSystem.unknown, OperatingSystem.nu);
          var deviceType = DeviceType(os, browser2, userAgent2);
          return {
            browser: browser2,
            os,
            deviceType
          };
        };
        var PlatformDetection = { detect: detect$2 };
        var detect$3 = cached(function() {
          var userAgent2 = domGlobals.navigator.userAgent;
          return PlatformDetection.detect(userAgent2);
        });
        var PlatformDetection$1 = { detect: detect$3 };
        var fromHtml = function(html, scope) {
          var doc2 = scope || domGlobals.document;
          var div = doc2.createElement("div");
          div.innerHTML = html;
          if (!div.hasChildNodes() || div.childNodes.length > 1) {
            domGlobals.console.error("HTML does not have a single root node", html);
            throw new Error("HTML must have a single root node");
          }
          return fromDom(div.childNodes[0]);
        };
        var fromTag = function(tag, scope) {
          var doc2 = scope || domGlobals.document;
          var node2 = doc2.createElement(tag);
          return fromDom(node2);
        };
        var fromText = function(text, scope) {
          var doc2 = scope || domGlobals.document;
          var node2 = doc2.createTextNode(text);
          return fromDom(node2);
        };
        var fromDom = function(node2) {
          if (node2 === null || node2 === void 0) {
            throw new Error("Node cannot be null or undefined");
          }
          return { dom: constant(node2) };
        };
        var fromPoint = function(docElm, x, y) {
          var doc2 = docElm.dom();
          return Option.from(doc2.elementFromPoint(x, y)).map(fromDom);
        };
        var Element = {
          fromHtml,
          fromTag,
          fromText,
          fromDom,
          fromPoint
        };
        var ATTRIBUTE = domGlobals.Node.ATTRIBUTE_NODE;
        var CDATA_SECTION = domGlobals.Node.CDATA_SECTION_NODE;
        var COMMENT = domGlobals.Node.COMMENT_NODE;
        var DOCUMENT = domGlobals.Node.DOCUMENT_NODE;
        var DOCUMENT_TYPE = domGlobals.Node.DOCUMENT_TYPE_NODE;
        var DOCUMENT_FRAGMENT = domGlobals.Node.DOCUMENT_FRAGMENT_NODE;
        var ELEMENT = domGlobals.Node.ELEMENT_NODE;
        var TEXT = domGlobals.Node.TEXT_NODE;
        var PROCESSING_INSTRUCTION = domGlobals.Node.PROCESSING_INSTRUCTION_NODE;
        var ENTITY_REFERENCE = domGlobals.Node.ENTITY_REFERENCE_NODE;
        var ENTITY = domGlobals.Node.ENTITY_NODE;
        var NOTATION = domGlobals.Node.NOTATION_NODE;
        var name = function(element) {
          var r = element.dom().nodeName;
          return r.toLowerCase();
        };
        var type = function(element) {
          return element.dom().nodeType;
        };
        var isType$1 = function(t) {
          return function(element) {
            return type(element) === t;
          };
        };
        var isElement = isType$1(ELEMENT);
        var isText = isType$1(TEXT);
        var keys = Object.keys;
        var hasOwnProperty$1 = Object.hasOwnProperty;
        var each$3 = function(obj, f) {
          var props = keys(obj);
          for (var k = 0, len = props.length; k < len; k++) {
            var i2 = props[k];
            var x = obj[i2];
            f(x, i2);
          }
        };
        var map$2 = function(obj, f) {
          return tupleMap(obj, function(x, i2) {
            return {
              k: i2,
              v: f(x, i2)
            };
          });
        };
        var tupleMap = function(obj, f) {
          var r = {};
          each$3(obj, function(x, i2) {
            var tuple = f(x, i2);
            r[tuple.k] = tuple.v;
          });
          return r;
        };
        var bifilter = function(obj, pred) {
          var t = {};
          var f = {};
          each$3(obj, function(x, i2) {
            var branch = pred(x, i2) ? t : f;
            branch[i2] = x;
          });
          return {
            t,
            f
          };
        };
        var has = function(obj, key) {
          return hasOwnProperty$1.call(obj, key);
        };
        var isSupported = function(dom2) {
          return dom2.style !== void 0 && isFunction(dom2.style.getPropertyValue);
        };
        var inBody = function(element) {
          var dom2 = isText(element) ? element.dom().parentNode : element.dom();
          return dom2 !== void 0 && dom2 !== null && dom2.ownerDocument.body.contains(dom2);
        };
        var rawSet = function(dom2, key, value2) {
          if (isString(value2) || isBoolean(value2) || isNumber(value2)) {
            dom2.setAttribute(key, value2 + "");
          } else {
            domGlobals.console.error("Invalid call to Attr.set. Key ", key, ":: Value ", value2, ":: Element ", dom2);
            throw new Error("Attribute value was not simple");
          }
        };
        var set = function(element, key, value2) {
          rawSet(element.dom(), key, value2);
        };
        var setAll = function(element, attrs) {
          var dom2 = element.dom();
          each$3(attrs, function(v, k) {
            rawSet(dom2, k, v);
          });
        };
        var get = function(element, key) {
          var v = element.dom().getAttribute(key);
          return v === null ? void 0 : v;
        };
        var has$1 = function(element, key) {
          var dom2 = element.dom();
          return dom2 && dom2.hasAttribute ? dom2.hasAttribute(key) : false;
        };
        var remove = function(element, key) {
          element.dom().removeAttribute(key);
        };
        var internalSet = function(dom2, property, value2) {
          if (!isString(value2)) {
            domGlobals.console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom2);
            throw new Error("CSS value must be a string: " + value2);
          }
          if (isSupported(dom2)) {
            dom2.style.setProperty(property, value2);
          }
        };
        var setAll$1 = function(element, css) {
          var dom2 = element.dom();
          each$3(css, function(v, k) {
            internalSet(dom2, k, v);
          });
        };
        var get$1 = function(element, property) {
          var dom2 = element.dom();
          var styles = domGlobals.window.getComputedStyle(dom2);
          var r = styles.getPropertyValue(property);
          var v = r === "" && !inBody(element) ? getUnsafeProperty(dom2, property) : r;
          return v === null ? void 0 : v;
        };
        var getUnsafeProperty = function(dom2, property) {
          return isSupported(dom2) ? dom2.style.getPropertyValue(property) : "";
        };
        var getRaw = function(element, property) {
          var dom2 = element.dom();
          var raw = getUnsafeProperty(dom2, property);
          return Option.from(raw).filter(function(r) {
            return r.length > 0;
          });
        };
        var getAllRaw = function(element) {
          var css = {};
          var dom2 = element.dom();
          if (isSupported(dom2)) {
            for (var i2 = 0; i2 < dom2.style.length; i2++) {
              var ruleName = dom2.style.item(i2);
              css[ruleName] = dom2.style[ruleName];
            }
          }
          return css;
        };
        var Immutable = function() {
          var fields = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            fields[_i] = arguments[_i];
          }
          return function() {
            var values = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              values[_i2] = arguments[_i2];
            }
            if (fields.length !== values.length) {
              throw new Error('Wrong number of arguments to struct. Expected "[' + fields.length + ']", got ' + values.length + " arguments");
            }
            var struct = {};
            each(fields, function(name2, i2) {
              struct[name2] = constant(values[i2]);
            });
            return struct;
          };
        };
        var toArray$1 = function(target, f) {
          var r = [];
          var recurse = function(e) {
            r.push(e);
            return f(e);
          };
          var cur = f(target);
          do {
            cur = cur.bind(recurse);
          } while (cur.isSome());
          return r;
        };
        var Recurse = { toArray: toArray$1 };
        var node = function() {
          var f = Global$1.getOrDie("Node");
          return f;
        };
        var compareDocumentPosition = function(a, b, match2) {
          return (a.compareDocumentPosition(b) & match2) !== 0;
        };
        var documentPositionPreceding = function(a, b) {
          return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
        };
        var documentPositionContainedBy = function(a, b) {
          return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
        };
        var Node = {
          documentPositionPreceding,
          documentPositionContainedBy
        };
        var ELEMENT$1 = ELEMENT;
        var DOCUMENT$1 = DOCUMENT;
        var is$1 = function(element, selector) {
          var dom2 = element.dom();
          if (dom2.nodeType !== ELEMENT$1) {
            return false;
          } else {
            var elem = dom2;
            if (elem.matches !== void 0) {
              return elem.matches(selector);
            } else if (elem.msMatchesSelector !== void 0) {
              return elem.msMatchesSelector(selector);
            } else if (elem.webkitMatchesSelector !== void 0) {
              return elem.webkitMatchesSelector(selector);
            } else if (elem.mozMatchesSelector !== void 0) {
              return elem.mozMatchesSelector(selector);
            } else {
              throw new Error("Browser lacks native selectors");
            }
          }
        };
        var bypassSelector = function(dom2) {
          return dom2.nodeType !== ELEMENT$1 && dom2.nodeType !== DOCUMENT$1 || dom2.childElementCount === 0;
        };
        var all = function(selector, scope) {
          var base = scope === void 0 ? domGlobals.document : scope.dom();
          return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), Element.fromDom);
        };
        var one = function(selector, scope) {
          var base = scope === void 0 ? domGlobals.document : scope.dom();
          return bypassSelector(base) ? Option.none() : Option.from(base.querySelector(selector)).map(Element.fromDom);
        };
        var eq = function(e1, e2) {
          return e1.dom() === e2.dom();
        };
        var regularContains = function(e1, e2) {
          var d1 = e1.dom();
          var d2 = e2.dom();
          return d1 === d2 ? false : d1.contains(d2);
        };
        var ieContains = function(e1, e2) {
          return Node.documentPositionContainedBy(e1.dom(), e2.dom());
        };
        var browser = PlatformDetection$1.detect().browser;
        var contains$3 = browser.isIE() ? ieContains : regularContains;
        var owner = function(element) {
          return Element.fromDom(element.dom().ownerDocument);
        };
        var documentElement = function(element) {
          return Element.fromDom(element.dom().ownerDocument.documentElement);
        };
        var defaultView = function(element) {
          return Element.fromDom(element.dom().ownerDocument.defaultView);
        };
        var parent = function(element) {
          return Option.from(element.dom().parentNode).map(Element.fromDom);
        };
        var parents = function(element, isRoot) {
          var stop2 = isFunction(isRoot) ? isRoot : never;
          var dom2 = element.dom();
          var ret = [];
          while (dom2.parentNode !== null && dom2.parentNode !== void 0) {
            var rawParent = dom2.parentNode;
            var p = Element.fromDom(rawParent);
            ret.push(p);
            if (stop2(p) === true) {
              break;
            } else {
              dom2 = rawParent;
            }
          }
          return ret;
        };
        var prevSibling = function(element) {
          return Option.from(element.dom().previousSibling).map(Element.fromDom);
        };
        var nextSibling = function(element) {
          return Option.from(element.dom().nextSibling).map(Element.fromDom);
        };
        var prevSiblings = function(element) {
          return reverse(Recurse.toArray(element, prevSibling));
        };
        var nextSiblings = function(element) {
          return Recurse.toArray(element, nextSibling);
        };
        var children = function(element) {
          return map(element.dom().childNodes, Element.fromDom);
        };
        var child = function(element, index) {
          var cs = element.dom().childNodes;
          return Option.from(cs[index]).map(Element.fromDom);
        };
        var firstChild = function(element) {
          return child(element, 0);
        };
        var lastChild = function(element) {
          return child(element, element.dom().childNodes.length - 1);
        };
        var childNodesCount = function(element) {
          return element.dom().childNodes.length;
        };
        var spot = Immutable("element", "offset");
        var browser$1 = PlatformDetection$1.detect().browser;
        var firstElement = function(nodes) {
          return find(nodes, isElement);
        };
        var getTableCaptionDeltaY = function(elm) {
          if (browser$1.isFirefox() && name(elm) === "table") {
            return firstElement(children(elm)).filter(function(elm2) {
              return name(elm2) === "caption";
            }).bind(function(caption) {
              return firstElement(nextSiblings(caption)).map(function(body) {
                var bodyTop = body.dom().offsetTop;
                var captionTop = caption.dom().offsetTop;
                var captionHeight = caption.dom().offsetHeight;
                return bodyTop <= captionTop ? -captionHeight : 0;
              });
            }).getOr(0);
          } else {
            return 0;
          }
        };
        var getPos = function(body, elm, rootElm) {
          var x = 0, y = 0, offsetParent;
          var doc2 = body.ownerDocument;
          var pos;
          rootElm = rootElm ? rootElm : body;
          if (elm) {
            if (rootElm === body && elm.getBoundingClientRect && get$1(Element.fromDom(body), "position") === "static") {
              pos = elm.getBoundingClientRect();
              x = pos.left + (doc2.documentElement.scrollLeft || body.scrollLeft) - doc2.documentElement.clientLeft;
              y = pos.top + (doc2.documentElement.scrollTop || body.scrollTop) - doc2.documentElement.clientTop;
              return {
                x,
                y
              };
            }
            offsetParent = elm;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType) {
              x += offsetParent.offsetLeft || 0;
              y += offsetParent.offsetTop || 0;
              offsetParent = offsetParent.offsetParent;
            }
            offsetParent = elm.parentNode;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType) {
              x -= offsetParent.scrollLeft || 0;
              y -= offsetParent.scrollTop || 0;
              offsetParent = offsetParent.parentNode;
            }
            y += getTableCaptionDeltaY(Element.fromDom(elm));
          }
          return {
            x,
            y
          };
        };
        var Position = { getPos };
        var exports$1 = {}, module$1 = { exports: exports$1 };
        (function(define, exports2, module2, require2) {
          (function(f) {
            if (typeof exports2 === "object" && typeof module2 !== "undefined") {
              module2.exports = f();
            } else if (typeof define === "function" && define.amd) {
              define([], f);
            } else {
              var g;
              if (typeof window !== "undefined") {
                g = window;
              } else if (typeof global !== "undefined") {
                g = global;
              } else if (typeof self !== "undefined") {
                g = self;
              } else {
                g = this;
              }
              g.EphoxContactWrapper = f();
            }
          })(function() {
            return function() {
              function r(e, n, t) {
                function o(i3, f) {
                  if (!n[i3]) {
                    if (!e[i3]) {
                      var c = typeof require2 == "function" && require2;
                      if (!f && c)
                        return c(i3, true);
                      if (u)
                        return u(i3, true);
                      var a = new Error("Cannot find module '" + i3 + "'");
                      throw a.code = "MODULE_NOT_FOUND", a;
                    }
                    var p = n[i3] = { exports: {} };
                    e[i3][0].call(p.exports, function(r2) {
                      var n2 = e[i3][1][r2];
                      return o(n2 || r2);
                    }, p, p.exports, r, e, n, t);
                  }
                  return n[i3].exports;
                }
                for (var u = typeof require2 == "function" && require2, i2 = 0; i2 < t.length; i2++)
                  o(t[i2]);
                return o;
              }
              return r;
            }()({
              1: [
                function(require3, module3, exports3) {
                  var process2 = module3.exports = {};
                  var cachedSetTimeout;
                  var cachedClearTimeout;
                  function defaultSetTimout() {
                    throw new Error("setTimeout has not been defined");
                  }
                  function defaultClearTimeout() {
                    throw new Error("clearTimeout has not been defined");
                  }
                  (function() {
                    try {
                      if (typeof setTimeout === "function") {
                        cachedSetTimeout = setTimeout;
                      } else {
                        cachedSetTimeout = defaultSetTimout;
                      }
                    } catch (e) {
                      cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                      if (typeof clearTimeout === "function") {
                        cachedClearTimeout = clearTimeout;
                      } else {
                        cachedClearTimeout = defaultClearTimeout;
                      }
                    } catch (e) {
                      cachedClearTimeout = defaultClearTimeout;
                    }
                  })();
                  function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                      return setTimeout(fun, 0);
                    }
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                      cachedSetTimeout = setTimeout;
                      return setTimeout(fun, 0);
                    }
                    try {
                      return cachedSetTimeout(fun, 0);
                    } catch (e) {
                      try {
                        return cachedSetTimeout.call(null, fun, 0);
                      } catch (e2) {
                        return cachedSetTimeout.call(this, fun, 0);
                      }
                    }
                  }
                  function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                      return clearTimeout(marker);
                    }
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                      cachedClearTimeout = clearTimeout;
                      return clearTimeout(marker);
                    }
                    try {
                      return cachedClearTimeout(marker);
                    } catch (e) {
                      try {
                        return cachedClearTimeout.call(null, marker);
                      } catch (e2) {
                        return cachedClearTimeout.call(this, marker);
                      }
                    }
                  }
                  var queue = [];
                  var draining = false;
                  var currentQueue;
                  var queueIndex = -1;
                  function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                      return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                      queue = currentQueue.concat(queue);
                    } else {
                      queueIndex = -1;
                    }
                    if (queue.length) {
                      drainQueue();
                    }
                  }
                  function drainQueue() {
                    if (draining) {
                      return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while (len) {
                      currentQueue = queue;
                      queue = [];
                      while (++queueIndex < len) {
                        if (currentQueue) {
                          currentQueue[queueIndex].run();
                        }
                      }
                      queueIndex = -1;
                      len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                  }
                  process2.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                      for (var i2 = 1; i2 < arguments.length; i2++) {
                        args[i2 - 1] = arguments[i2];
                      }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                      runTimeout(drainQueue);
                    }
                  };
                  function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                  }
                  Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                  };
                  process2.title = "browser";
                  process2.browser = true;
                  process2.env = {};
                  process2.argv = [];
                  process2.version = "";
                  process2.versions = {};
                  function noop2() {
                  }
                  process2.on = noop2;
                  process2.addListener = noop2;
                  process2.once = noop2;
                  process2.off = noop2;
                  process2.removeListener = noop2;
                  process2.removeAllListeners = noop2;
                  process2.emit = noop2;
                  process2.prependListener = noop2;
                  process2.prependOnceListener = noop2;
                  process2.listeners = function(name2) {
                    return [];
                  };
                  process2.binding = function(name2) {
                    throw new Error("process.binding is not supported");
                  };
                  process2.cwd = function() {
                    return "/";
                  };
                  process2.chdir = function(dir2) {
                    throw new Error("process.chdir is not supported");
                  };
                  process2.umask = function() {
                    return 0;
                  };
                },
                {}
              ],
              2: [
                function(require3, module3, exports3) {
                  (function(setImmediate2) {
                    (function(root) {
                      var setTimeoutFunc = setTimeout;
                      function noop2() {
                      }
                      function bind2(fn, thisArg) {
                        return function() {
                          fn.apply(thisArg, arguments);
                        };
                      }
                      function Promise3(fn) {
                        if (typeof this !== "object")
                          throw new TypeError("Promises must be constructed via new");
                        if (typeof fn !== "function")
                          throw new TypeError("not a function");
                        this._state = 0;
                        this._handled = false;
                        this._value = void 0;
                        this._deferreds = [];
                        doResolve(fn, this);
                      }
                      function handle2(self2, deferred) {
                        while (self2._state === 3) {
                          self2 = self2._value;
                        }
                        if (self2._state === 0) {
                          self2._deferreds.push(deferred);
                          return;
                        }
                        self2._handled = true;
                        Promise3._immediateFn(function() {
                          var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                          if (cb === null) {
                            (self2._state === 1 ? resolve2 : reject)(deferred.promise, self2._value);
                            return;
                          }
                          var ret;
                          try {
                            ret = cb(self2._value);
                          } catch (e) {
                            reject(deferred.promise, e);
                            return;
                          }
                          resolve2(deferred.promise, ret);
                        });
                      }
                      function resolve2(self2, newValue) {
                        try {
                          if (newValue === self2)
                            throw new TypeError("A promise cannot be resolved with itself.");
                          if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                            var then = newValue.then;
                            if (newValue instanceof Promise3) {
                              self2._state = 3;
                              self2._value = newValue;
                              finale(self2);
                              return;
                            } else if (typeof then === "function") {
                              doResolve(bind2(then, newValue), self2);
                              return;
                            }
                          }
                          self2._state = 1;
                          self2._value = newValue;
                          finale(self2);
                        } catch (e) {
                          reject(self2, e);
                        }
                      }
                      function reject(self2, newValue) {
                        self2._state = 2;
                        self2._value = newValue;
                        finale(self2);
                      }
                      function finale(self2) {
                        if (self2._state === 2 && self2._deferreds.length === 0) {
                          Promise3._immediateFn(function() {
                            if (!self2._handled) {
                              Promise3._unhandledRejectionFn(self2._value);
                            }
                          });
                        }
                        for (var i2 = 0, len = self2._deferreds.length; i2 < len; i2++) {
                          handle2(self2, self2._deferreds[i2]);
                        }
                        self2._deferreds = null;
                      }
                      function Handler(onFulfilled, onRejected, promise2) {
                        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
                        this.onRejected = typeof onRejected === "function" ? onRejected : null;
                        this.promise = promise2;
                      }
                      function doResolve(fn, self2) {
                        var done2 = false;
                        try {
                          fn(function(value2) {
                            if (done2)
                              return;
                            done2 = true;
                            resolve2(self2, value2);
                          }, function(reason) {
                            if (done2)
                              return;
                            done2 = true;
                            reject(self2, reason);
                          });
                        } catch (ex) {
                          if (done2)
                            return;
                          done2 = true;
                          reject(self2, ex);
                        }
                      }
                      Promise3.prototype["catch"] = function(onRejected) {
                        return this.then(null, onRejected);
                      };
                      Promise3.prototype.then = function(onFulfilled, onRejected) {
                        var prom = new this.constructor(noop2);
                        handle2(this, new Handler(onFulfilled, onRejected, prom));
                        return prom;
                      };
                      Promise3.all = function(arr2) {
                        var args = Array.prototype.slice.call(arr2);
                        return new Promise3(function(resolve3, reject2) {
                          if (args.length === 0)
                            return resolve3([]);
                          var remaining = args.length;
                          function res(i3, val) {
                            try {
                              if (val && (typeof val === "object" || typeof val === "function")) {
                                var then = val.then;
                                if (typeof then === "function") {
                                  then.call(val, function(val2) {
                                    res(i3, val2);
                                  }, reject2);
                                  return;
                                }
                              }
                              args[i3] = val;
                              if (--remaining === 0) {
                                resolve3(args);
                              }
                            } catch (ex) {
                              reject2(ex);
                            }
                          }
                          for (var i2 = 0; i2 < args.length; i2++) {
                            res(i2, args[i2]);
                          }
                        });
                      };
                      Promise3.resolve = function(value2) {
                        if (value2 && typeof value2 === "object" && value2.constructor === Promise3) {
                          return value2;
                        }
                        return new Promise3(function(resolve3) {
                          resolve3(value2);
                        });
                      };
                      Promise3.reject = function(value2) {
                        return new Promise3(function(resolve3, reject2) {
                          reject2(value2);
                        });
                      };
                      Promise3.race = function(values) {
                        return new Promise3(function(resolve3, reject2) {
                          for (var i2 = 0, len = values.length; i2 < len; i2++) {
                            values[i2].then(resolve3, reject2);
                          }
                        });
                      };
                      Promise3._immediateFn = typeof setImmediate2 === "function" ? function(fn) {
                        setImmediate2(fn);
                      } : function(fn) {
                        setTimeoutFunc(fn, 0);
                      };
                      Promise3._unhandledRejectionFn = function _unhandledRejectionFn(err) {
                        if (typeof console !== "undefined" && console) {
                          console.warn("Possible Unhandled Promise Rejection:", err);
                        }
                      };
                      Promise3._setImmediateFn = function _setImmediateFn(fn) {
                        Promise3._immediateFn = fn;
                      };
                      Promise3._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
                        Promise3._unhandledRejectionFn = fn;
                      };
                      if (typeof module3 !== "undefined" && module3.exports) {
                        module3.exports = Promise3;
                      } else if (!root.Promise) {
                        root.Promise = Promise3;
                      }
                    })(this);
                  }).call(this, require3("timers").setImmediate);
                },
                { "timers": 3 }
              ],
              3: [
                function(require3, module3, exports3) {
                  (function(setImmediate2, clearImmediate) {
                    var nextTick = require3("process/browser.js").nextTick;
                    var apply = Function.prototype.apply;
                    var slice2 = Array.prototype.slice;
                    var immediateIds = {};
                    var nextImmediateId = 0;
                    exports3.setTimeout = function() {
                      return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
                    };
                    exports3.setInterval = function() {
                      return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
                    };
                    exports3.clearTimeout = exports3.clearInterval = function(timeout) {
                      timeout.close();
                    };
                    function Timeout(id, clearFn) {
                      this._id = id;
                      this._clearFn = clearFn;
                    }
                    Timeout.prototype.unref = Timeout.prototype.ref = function() {
                    };
                    Timeout.prototype.close = function() {
                      this._clearFn.call(window, this._id);
                    };
                    exports3.enroll = function(item, msecs) {
                      clearTimeout(item._idleTimeoutId);
                      item._idleTimeout = msecs;
                    };
                    exports3.unenroll = function(item) {
                      clearTimeout(item._idleTimeoutId);
                      item._idleTimeout = -1;
                    };
                    exports3._unrefActive = exports3.active = function(item) {
                      clearTimeout(item._idleTimeoutId);
                      var msecs = item._idleTimeout;
                      if (msecs >= 0) {
                        item._idleTimeoutId = setTimeout(function onTimeout() {
                          if (item._onTimeout)
                            item._onTimeout();
                        }, msecs);
                      }
                    };
                    exports3.setImmediate = typeof setImmediate2 === "function" ? setImmediate2 : function(fn) {
                      var id = nextImmediateId++;
                      var args = arguments.length < 2 ? false : slice2.call(arguments, 1);
                      immediateIds[id] = true;
                      nextTick(function onNextTick() {
                        if (immediateIds[id]) {
                          if (args) {
                            fn.apply(null, args);
                          } else {
                            fn.call(null);
                          }
                          exports3.clearImmediate(id);
                        }
                      });
                      return id;
                    };
                    exports3.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
                      delete immediateIds[id];
                    };
                  }).call(this, require3("timers").setImmediate, require3("timers").clearImmediate);
                },
                {
                  "process/browser.js": 1,
                  "timers": 3
                }
              ],
              4: [
                function(require3, module3, exports3) {
                  var promisePolyfill = require3("promise-polyfill");
                  var Global2 = function() {
                    if (typeof window !== "undefined") {
                      return window;
                    } else {
                      return Function("return this;")();
                    }
                  }();
                  module3.exports = { boltExport: Global2.Promise || promisePolyfill };
                },
                { "promise-polyfill": 2 }
              ]
            }, {}, [4])(4);
          });
        })(void 0, exports$1, module$1, void 0);
        var Promise2 = module$1.exports.boltExport;
        var nu$3 = function(baseFn) {
          var data2 = Option.none();
          var callbacks = [];
          var map2 = function(f) {
            return nu$3(function(nCallback) {
              get2(function(data3) {
                nCallback(f(data3));
              });
            });
          };
          var get2 = function(nCallback) {
            if (isReady()) {
              call(nCallback);
            } else {
              callbacks.push(nCallback);
            }
          };
          var set2 = function(x) {
            data2 = Option.some(x);
            run(callbacks);
            callbacks = [];
          };
          var isReady = function() {
            return data2.isSome();
          };
          var run = function(cbs) {
            each(cbs, call);
          };
          var call = function(cb) {
            data2.each(function(x) {
              domGlobals.setTimeout(function() {
                cb(x);
              }, 0);
            });
          };
          baseFn(set2);
          return {
            get: get2,
            map: map2,
            isReady
          };
        };
        var pure = function(a) {
          return nu$3(function(callback) {
            callback(a);
          });
        };
        var LazyValue = {
          nu: nu$3,
          pure
        };
        var errorReporter = function(err) {
          domGlobals.setTimeout(function() {
            throw err;
          }, 0);
        };
        var make = function(run) {
          var get2 = function(callback) {
            run().then(callback, errorReporter);
          };
          var map2 = function(fab) {
            return make(function() {
              return run().then(fab);
            });
          };
          var bind2 = function(aFutureB) {
            return make(function() {
              return run().then(function(v) {
                return aFutureB(v).toPromise();
              });
            });
          };
          var anonBind = function(futureB) {
            return make(function() {
              return run().then(function() {
                return futureB.toPromise();
              });
            });
          };
          var toLazy = function() {
            return LazyValue.nu(get2);
          };
          var toCached = function() {
            var cache = null;
            return make(function() {
              if (cache === null) {
                cache = run();
              }
              return cache;
            });
          };
          var toPromise = run;
          return {
            map: map2,
            bind: bind2,
            anonBind,
            toLazy,
            toCached,
            toPromise,
            get: get2
          };
        };
        var nu$4 = function(baseFn) {
          return make(function() {
            return new Promise2(baseFn);
          });
        };
        var pure$1 = function(a) {
          return make(function() {
            return Promise2.resolve(a);
          });
        };
        var Future = {
          nu: nu$4,
          pure: pure$1
        };
        var par = function(asyncValues, nu2) {
          return nu2(function(callback) {
            var r = [];
            var count2 = 0;
            var cb = function(i2) {
              return function(value2) {
                r[i2] = value2;
                count2++;
                if (count2 >= asyncValues.length) {
                  callback(r);
                }
              };
            };
            if (asyncValues.length === 0) {
              callback([]);
            } else {
              each(asyncValues, function(asyncValue, i2) {
                asyncValue.get(cb(i2));
              });
            }
          });
        };
        var par$1 = function(futures) {
          return par(futures, Future.nu);
        };
        var value = function(o) {
          var is2 = function(v) {
            return o === v;
          };
          var or2 = function(opt) {
            return value(o);
          };
          var orThunk = function(f) {
            return value(o);
          };
          var map2 = function(f) {
            return value(f(o));
          };
          var mapError = function(f) {
            return value(o);
          };
          var each2 = function(f) {
            f(o);
          };
          var bind2 = function(f) {
            return f(o);
          };
          var fold = function(_, onValue) {
            return onValue(o);
          };
          var exists2 = function(f) {
            return f(o);
          };
          var forall2 = function(f) {
            return f(o);
          };
          var toOption = function() {
            return Option.some(o);
          };
          return {
            is: is2,
            isValue: always,
            isError: never,
            getOr: constant(o),
            getOrThunk: constant(o),
            getOrDie: constant(o),
            or: or2,
            orThunk,
            fold,
            map: map2,
            mapError,
            each: each2,
            bind: bind2,
            exists: exists2,
            forall: forall2,
            toOption
          };
        };
        var error = function(message) {
          var getOrThunk = function(f) {
            return f();
          };
          var getOrDie2 = function() {
            return die(String(message))();
          };
          var or2 = function(opt) {
            return opt;
          };
          var orThunk = function(f) {
            return f();
          };
          var map2 = function(f) {
            return error(message);
          };
          var mapError = function(f) {
            return error(f(message));
          };
          var bind2 = function(f) {
            return error(message);
          };
          var fold = function(onError, _) {
            return onError(message);
          };
          return {
            is: never,
            isValue: never,
            isError: always,
            getOr: identity,
            getOrThunk,
            getOrDie: getOrDie2,
            or: or2,
            orThunk,
            fold,
            map: map2,
            mapError,
            each: noop,
            bind: bind2,
            exists: never,
            forall: always,
            toOption: Option.none
          };
        };
        var fromOption = function(opt, err) {
          return opt.fold(function() {
            return error(err);
          }, value);
        };
        var Result = {
          value,
          error,
          fromOption
        };
        function StyleSheetLoader(document2, settings) {
          if (settings === void 0) {
            settings = {};
          }
          var idCount = 0;
          var loadedStates = {};
          var maxLoadTime;
          maxLoadTime = settings.maxLoadTime || 5e3;
          var appendToHead = function(node2) {
            document2.getElementsByTagName("head")[0].appendChild(node2);
          };
          var load = function(url2, loadedCallback, errorCallback) {
            var link, style, startTime, state;
            var passed = function() {
              var callbacks = state.passed;
              var i2 = callbacks.length;
              while (i2--) {
                callbacks[i2]();
              }
              state.status = 2;
              state.passed = [];
              state.failed = [];
            };
            var failed = function() {
              var callbacks = state.failed;
              var i2 = callbacks.length;
              while (i2--) {
                callbacks[i2]();
              }
              state.status = 3;
              state.passed = [];
              state.failed = [];
            };
            var isOldWebKit = function() {
              var webKitChunks = domGlobals.navigator.userAgent.match(/WebKit\/(\d*)/);
              return !!(webKitChunks && parseInt(webKitChunks[1], 10) < 536);
            };
            var wait = function(testCallback, waitCallback) {
              if (!testCallback()) {
                if (new Date().getTime() - startTime < maxLoadTime) {
                  Delay.setTimeout(waitCallback);
                } else {
                  failed();
                }
              }
            };
            var waitForWebKitLinkLoaded = function() {
              wait(function() {
                var styleSheets = document2.styleSheets;
                var styleSheet, i2 = styleSheets.length, owner2;
                while (i2--) {
                  styleSheet = styleSheets[i2];
                  owner2 = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
                  if (owner2 && owner2.id === link.id) {
                    passed();
                    return true;
                  }
                }
              }, waitForWebKitLinkLoaded);
            };
            var waitForGeckoLinkLoaded = function() {
              wait(function() {
                try {
                  var cssRules = style.sheet.cssRules;
                  passed();
                  return !!cssRules;
                } catch (ex) {
                }
              }, waitForGeckoLinkLoaded);
            };
            url2 = Tools._addCacheSuffix(url2);
            if (!loadedStates[url2]) {
              state = {
                passed: [],
                failed: []
              };
              loadedStates[url2] = state;
            } else {
              state = loadedStates[url2];
            }
            if (loadedCallback) {
              state.passed.push(loadedCallback);
            }
            if (errorCallback) {
              state.failed.push(errorCallback);
            }
            if (state.status === 1) {
              return;
            }
            if (state.status === 2) {
              passed();
              return;
            }
            if (state.status === 3) {
              failed();
              return;
            }
            state.status = 1;
            link = document2.createElement("link");
            link.rel = "stylesheet";
            link.type = "text/css";
            link.id = "u" + idCount++;
            link.async = false;
            link.defer = false;
            startTime = new Date().getTime();
            if (settings.contentCssCors) {
              link.crossOrigin = "anonymous";
            }
            if ("onload" in link && !isOldWebKit()) {
              link.onload = waitForWebKitLinkLoaded;
              link.onerror = failed;
            } else {
              if (domGlobals.navigator.userAgent.indexOf("Firefox") > 0) {
                style = document2.createElement("style");
                style.textContent = '@import "' + url2 + '"';
                waitForGeckoLinkLoaded();
                appendToHead(style);
                return;
              }
              waitForWebKitLinkLoaded();
            }
            appendToHead(link);
            link.href = url2;
          };
          var loadF = function(url2) {
            return Future.nu(function(resolve2) {
              load(url2, compose(resolve2, constant(Result.value(url2))), compose(resolve2, constant(Result.error(url2))));
            });
          };
          var unbox = function(result) {
            return result.fold(identity, identity);
          };
          var loadAll = function(urls, success, failure) {
            par$1(map(urls, loadF)).get(function(result) {
              var parts = partition(result, function(r) {
                return r.isValue();
              });
              if (parts.fail.length > 0) {
                failure(parts.fail.map(unbox));
              } else {
                success(parts.pass.map(unbox));
              }
            });
          };
          return {
            load,
            loadAll
          };
        }
        function TreeWalker(startNode, rootNode) {
          var node2 = startNode;
          var findSibling2 = function(node3, startName, siblingName, shallow2) {
            var sibling2, parent2;
            if (node3) {
              if (!shallow2 && node3[startName]) {
                return node3[startName];
              }
              if (node3 !== rootNode) {
                sibling2 = node3[siblingName];
                if (sibling2) {
                  return sibling2;
                }
                for (parent2 = node3.parentNode; parent2 && parent2 !== rootNode; parent2 = parent2.parentNode) {
                  sibling2 = parent2[siblingName];
                  if (sibling2) {
                    return sibling2;
                  }
                }
              }
            }
          };
          var findPreviousNode = function(node3, startName, siblingName, shallow2) {
            var sibling2, parent2, child2;
            if (node3) {
              sibling2 = node3[siblingName];
              if (rootNode && sibling2 === rootNode) {
                return;
              }
              if (sibling2) {
                if (!shallow2) {
                  for (child2 = sibling2[startName]; child2; child2 = child2[startName]) {
                    if (!child2[startName]) {
                      return child2;
                    }
                  }
                }
                return sibling2;
              }
              parent2 = node3.parentNode;
              if (parent2 && parent2 !== rootNode) {
                return parent2;
              }
            }
          };
          this.current = function() {
            return node2;
          };
          this.next = function(shallow2) {
            node2 = findSibling2(node2, "firstChild", "nextSibling", shallow2);
            return node2;
          };
          this.prev = function(shallow2) {
            node2 = findSibling2(node2, "lastChild", "previousSibling", shallow2);
            return node2;
          };
          this.prev2 = function(shallow2) {
            node2 = findPreviousNode(node2, "lastChild", "previousSibling", shallow2);
            return node2;
          };
        }
        var blocks = [
          "article",
          "aside",
          "details",
          "div",
          "dt",
          "figcaption",
          "footer",
          "form",
          "fieldset",
          "header",
          "hgroup",
          "html",
          "main",
          "nav",
          "section",
          "summary",
          "body",
          "p",
          "dl",
          "multicol",
          "dd",
          "figure",
          "address",
          "center",
          "blockquote",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "listing",
          "xmp",
          "pre",
          "plaintext",
          "menu",
          "dir",
          "ul",
          "ol",
          "li",
          "hr",
          "table",
          "tbody",
          "thead",
          "tfoot",
          "th",
          "tr",
          "td",
          "caption"
        ];
        var voids = [
          "area",
          "base",
          "basefont",
          "br",
          "col",
          "frame",
          "hr",
          "img",
          "input",
          "isindex",
          "link",
          "meta",
          "param",
          "embed",
          "source",
          "wbr",
          "track"
        ];
        var tableCells = [
          "td",
          "th"
        ];
        var tableSections = [
          "thead",
          "tbody",
          "tfoot"
        ];
        var textBlocks = [
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "p",
          "div",
          "address",
          "pre",
          "form",
          "blockquote",
          "center",
          "dir",
          "fieldset",
          "header",
          "footer",
          "article",
          "section",
          "hgroup",
          "aside",
          "nav",
          "figure"
        ];
        var headings = [
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6"
        ];
        var listItems = [
          "li",
          "dd",
          "dt"
        ];
        var lists = [
          "ul",
          "ol",
          "dl"
        ];
        var wsElements = [
          "pre",
          "script",
          "textarea",
          "style"
        ];
        var lazyLookup = function(items) {
          var lookup;
          return function(node2) {
            lookup = lookup ? lookup : mapToObject(items, constant(true));
            return lookup.hasOwnProperty(name(node2));
          };
        };
        var isHeading = lazyLookup(headings);
        var isBlock = lazyLookup(blocks);
        var isInline = function(node2) {
          return isElement(node2) && !isBlock(node2);
        };
        var isBr = function(node2) {
          return isElement(node2) && name(node2) === "br";
        };
        var isTextBlock = lazyLookup(textBlocks);
        var isList = lazyLookup(lists);
        var isListItem = lazyLookup(listItems);
        var isVoid = lazyLookup(voids);
        var isTableSection = lazyLookup(tableSections);
        var isTableCell = lazyLookup(tableCells);
        var isWsPreserveElement = lazyLookup(wsElements);
        var isNodeType = function(type2) {
          return function(node2) {
            return !!node2 && node2.nodeType === type2;
          };
        };
        var isRestrictedNode = function(node2) {
          return !!node2 && !Object.getPrototypeOf(node2);
        };
        var isElement$1 = isNodeType(1);
        var matchNodeNames = function(names) {
          var items = names.toLowerCase().split(" ");
          return function(node2) {
            var i2, name2;
            if (node2 && node2.nodeType) {
              name2 = node2.nodeName.toLowerCase();
              for (i2 = 0; i2 < items.length; i2++) {
                if (name2 === items[i2]) {
                  return true;
                }
              }
            }
            return false;
          };
        };
        var matchStyleValues = function(name2, values) {
          var items = values.toLowerCase().split(" ");
          return function(node2) {
            var i2, cssValue;
            if (isElement$1(node2)) {
              for (i2 = 0; i2 < items.length; i2++) {
                var computed = node2.ownerDocument.defaultView.getComputedStyle(node2, null);
                cssValue = computed ? computed.getPropertyValue(name2) : null;
                if (cssValue === items[i2]) {
                  return true;
                }
              }
            }
            return false;
          };
        };
        var hasPropValue = function(propName, propValue) {
          return function(node2) {
            return isElement$1(node2) && node2[propName] === propValue;
          };
        };
        var hasAttribute = function(attrName, attrValue) {
          return function(node2) {
            return isElement$1(node2) && node2.hasAttribute(attrName);
          };
        };
        var hasAttributeValue = function(attrName, attrValue) {
          return function(node2) {
            return isElement$1(node2) && node2.getAttribute(attrName) === attrValue;
          };
        };
        var isBogus = function(node2) {
          return isElement$1(node2) && node2.hasAttribute("data-mce-bogus");
        };
        var isBogusAll = function(node2) {
          return isElement$1(node2) && node2.getAttribute("data-mce-bogus") === "all";
        };
        var isTable = function(node2) {
          return isElement$1(node2) && node2.tagName === "TABLE";
        };
        var hasContentEditableState = function(value2) {
          return function(node2) {
            if (isElement$1(node2)) {
              if (node2.contentEditable === value2) {
                return true;
              }
              if (node2.getAttribute("data-mce-contenteditable") === value2) {
                return true;
              }
            }
            return false;
          };
        };
        var isText$1 = isNodeType(3);
        var isComment = isNodeType(8);
        var isDocument = isNodeType(9);
        var isDocumentFragment = isNodeType(11);
        var isBr$1 = matchNodeNames("br");
        var isContentEditableTrue = hasContentEditableState("true");
        var isContentEditableFalse = hasContentEditableState("false");
        var NodeType = {
          isText: isText$1,
          isElement: isElement$1,
          isComment,
          isDocument,
          isDocumentFragment,
          isBr: isBr$1,
          isContentEditableTrue,
          isContentEditableFalse,
          isRestrictedNode,
          matchNodeNames,
          hasPropValue,
          hasAttribute,
          hasAttributeValue,
          matchStyleValues,
          isBogus,
          isBogusAll,
          isTable
        };
        var surroundedBySpans = function(node2) {
          var previousIsSpan = node2.previousSibling && node2.previousSibling.nodeName === "SPAN";
          var nextIsSpan = node2.nextSibling && node2.nextSibling.nodeName === "SPAN";
          return previousIsSpan && nextIsSpan;
        };
        var isBookmarkNode = function(node2) {
          return node2 && node2.tagName === "SPAN" && node2.getAttribute("data-mce-type") === "bookmark";
        };
        var trimNode = function(dom2, node2) {
          var i2, children2 = node2.childNodes;
          if (NodeType.isElement(node2) && isBookmarkNode(node2)) {
            return;
          }
          for (i2 = children2.length - 1; i2 >= 0; i2--) {
            trimNode(dom2, children2[i2]);
          }
          if (NodeType.isDocument(node2) === false) {
            if (NodeType.isText(node2) && node2.nodeValue.length > 0) {
              var trimmedLength = Tools.trim(node2.nodeValue).length;
              if (dom2.isBlock(node2.parentNode) || trimmedLength > 0) {
                return;
              }
              if (trimmedLength === 0 && surroundedBySpans(node2)) {
                return;
              }
            } else if (NodeType.isElement(node2)) {
              children2 = node2.childNodes;
              if (children2.length === 1 && isBookmarkNode(children2[0])) {
                node2.parentNode.insertBefore(children2[0], node2);
              }
              if (children2.length || isVoid(Element.fromDom(node2))) {
                return;
              }
            }
            dom2.remove(node2);
          }
          return node2;
        };
        var TrimNode = { trimNode };
        var makeMap$1 = Tools.makeMap;
        var namedEntities, baseEntities, reverseEntities;
        var attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var rawCharsRegExp = /[<>&\"\']/g;
        var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
        var asciiMap = {
          128: "\u20AC",
          130: "\u201A",
          131: "\u0192",
          132: "\u201E",
          133: "\u2026",
          134: "\u2020",
          135: "\u2021",
          136: "\u02C6",
          137: "\u2030",
          138: "\u0160",
          139: "\u2039",
          140: "\u0152",
          142: "\u017D",
          145: "\u2018",
          146: "\u2019",
          147: "\u201C",
          148: "\u201D",
          149: "\u2022",
          150: "\u2013",
          151: "\u2014",
          152: "\u02DC",
          153: "\u2122",
          154: "\u0161",
          155: "\u203A",
          156: "\u0153",
          158: "\u017E",
          159: "\u0178"
        };
        baseEntities = {
          '"': "&quot;",
          "'": "&#39;",
          "<": "&lt;",
          ">": "&gt;",
          "&": "&amp;",
          "`": "&#96;"
        };
        reverseEntities = {
          "&lt;": "<",
          "&gt;": ">",
          "&amp;": "&",
          "&quot;": '"',
          "&apos;": "'"
        };
        var nativeDecode = function(text) {
          var elm;
          elm = Element.fromTag("div").dom();
          elm.innerHTML = text;
          return elm.textContent || elm.innerText || text;
        };
        var buildEntitiesLookup = function(items, radix) {
          var i2, chr, entity;
          var lookup = {};
          if (items) {
            items = items.split(",");
            radix = radix || 10;
            for (i2 = 0; i2 < items.length; i2 += 2) {
              chr = String.fromCharCode(parseInt(items[i2], radix));
              if (!baseEntities[chr]) {
                entity = "&" + items[i2 + 1] + ";";
                lookup[chr] = entity;
                lookup[entity] = chr;
              }
            }
            return lookup;
          }
        };
        namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
        var encodeRaw = function(text, attr) {
          return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
            return baseEntities[chr] || chr;
          });
        };
        var encodeAllRaw = function(text) {
          return ("" + text).replace(rawCharsRegExp, function(chr) {
            return baseEntities[chr] || chr;
          });
        };
        var encodeNumeric = function(text, attr) {
          return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
            if (chr.length > 1) {
              return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
            }
            return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
          });
        };
        var encodeNamed = function(text, attr, entities) {
          entities = entities || namedEntities;
          return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
            return baseEntities[chr] || entities[chr] || chr;
          });
        };
        var getEncodeFunc = function(name2, entities) {
          var entitiesMap = buildEntitiesLookup(entities) || namedEntities;
          var encodeNamedAndNumeric = function(text, attr) {
            return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
              if (baseEntities[chr] !== void 0) {
                return baseEntities[chr];
              }
              if (entitiesMap[chr] !== void 0) {
                return entitiesMap[chr];
              }
              if (chr.length > 1) {
                return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
              }
              return "&#" + chr.charCodeAt(0) + ";";
            });
          };
          var encodeCustomNamed = function(text, attr) {
            return encodeNamed(text, attr, entitiesMap);
          };
          var nameMap = makeMap$1(name2.replace(/\+/g, ","));
          if (nameMap.named && nameMap.numeric) {
            return encodeNamedAndNumeric;
          }
          if (nameMap.named) {
            if (entities) {
              return encodeCustomNamed;
            }
            return encodeNamed;
          }
          if (nameMap.numeric) {
            return encodeNumeric;
          }
          return encodeRaw;
        };
        var decode = function(text) {
          return text.replace(entityRegExp, function(all2, numeric) {
            if (numeric) {
              if (numeric.charAt(0).toLowerCase() === "x") {
                numeric = parseInt(numeric.substr(1), 16);
              } else {
                numeric = parseInt(numeric, 10);
              }
              if (numeric > 65535) {
                numeric -= 65536;
                return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
              }
              return asciiMap[numeric] || String.fromCharCode(numeric);
            }
            return reverseEntities[all2] || namedEntities[all2] || nativeDecode(all2);
          });
        };
        var Entities = {
          encodeRaw,
          encodeAllRaw,
          encodeNumeric,
          encodeNamed,
          getEncodeFunc,
          decode
        };
        var mapCache = {}, dummyObj = {};
        var makeMap$2 = Tools.makeMap, each$4 = Tools.each, extend$1 = Tools.extend, explode$1 = Tools.explode, inArray$1 = Tools.inArray;
        var split = function(items, delim) {
          items = Tools.trim(items);
          return items ? items.split(delim || " ") : [];
        };
        var compileSchema = function(type2) {
          var schema = {};
          var globalAttributes, blockContent;
          var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
          var add2 = function(name2, attributes2, children2) {
            var ni, attributesOrder, element;
            var arrayToMap = function(array, obj) {
              var map2 = {};
              var i2, l;
              for (i2 = 0, l = array.length; i2 < l; i2++) {
                map2[array[i2]] = obj || {};
              }
              return map2;
            };
            children2 = children2 || [];
            attributes2 = attributes2 || "";
            if (typeof children2 === "string") {
              children2 = split(children2);
            }
            name2 = split(name2);
            ni = name2.length;
            while (ni--) {
              attributesOrder = split([
                globalAttributes,
                attributes2
              ].join(" "));
              element = {
                attributes: arrayToMap(attributesOrder),
                attributesOrder,
                children: arrayToMap(children2, dummyObj)
              };
              schema[name2[ni]] = element;
            }
          };
          var addAttrs = function(name2, attributes2) {
            var ni, schemaItem, i2, l;
            name2 = split(name2);
            ni = name2.length;
            attributes2 = split(attributes2);
            while (ni--) {
              schemaItem = schema[name2[ni]];
              for (i2 = 0, l = attributes2.length; i2 < l; i2++) {
                schemaItem.attributes[attributes2[i2]] = {};
                schemaItem.attributesOrder.push(attributes2[i2]);
              }
            }
          };
          if (mapCache[type2]) {
            return mapCache[type2];
          }
          globalAttributes = "id accesskey class dir lang style tabindex title role";
          blockContent = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
          phrasingContent = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment";
          if (type2 !== "html4") {
            globalAttributes += " contenteditable contextmenu draggable dropzone hidden spellcheck translate";
            blockContent += " article aside details dialog figure main header footer hgroup section nav";
            phrasingContent += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen";
          }
          if (type2 !== "html5-strict") {
            globalAttributes += " xml:lang";
            html4PhrasingContent = "acronym applet basefont big font strike tt";
            phrasingContent = [
              phrasingContent,
              html4PhrasingContent
            ].join(" ");
            each$4(split(html4PhrasingContent), function(name2) {
              add2(name2, "", phrasingContent);
            });
            html4BlockContent = "center dir isindex noframes";
            blockContent = [
              blockContent,
              html4BlockContent
            ].join(" ");
            flowContent = [
              blockContent,
              phrasingContent
            ].join(" ");
            each$4(split(html4BlockContent), function(name2) {
              add2(name2, "", flowContent);
            });
          }
          flowContent = flowContent || [
            blockContent,
            phrasingContent
          ].join(" ");
          add2("html", "manifest", "head body");
          add2("head", "", "base command link meta noscript script style title");
          add2("title hr noscript br");
          add2("base", "href target");
          add2("link", "href rel media hreflang type sizes hreflang");
          add2("meta", "name http-equiv content charset");
          add2("style", "media type scoped");
          add2("script", "src async defer type charset");
          add2("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", flowContent);
          add2("address dt dd div caption", "", flowContent);
          add2("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
          add2("blockquote", "cite", flowContent);
          add2("ol", "reversed start type", "li");
          add2("ul", "", "li");
          add2("li", "value", flowContent);
          add2("dl", "", "dt dd");
          add2("a", "href target rel media hreflang type", phrasingContent);
          add2("q", "cite", phrasingContent);
          add2("ins del", "cite datetime", flowContent);
          add2("img", "src sizes srcset alt usemap ismap width height");
          add2("iframe", "src name width height", flowContent);
          add2("embed", "src type width height");
          add2("object", "data type typemustmatch name usemap form width height", [
            flowContent,
            "param"
          ].join(" "));
          add2("param", "name value");
          add2("map", "name", [
            flowContent,
            "area"
          ].join(" "));
          add2("area", "alt coords shape href target rel media hreflang type");
          add2("table", "border", "caption colgroup thead tfoot tbody tr" + (type2 === "html4" ? " col" : ""));
          add2("colgroup", "span", "col");
          add2("col", "span");
          add2("tbody thead tfoot", "", "tr");
          add2("tr", "", "td th");
          add2("td", "colspan rowspan headers", flowContent);
          add2("th", "colspan rowspan headers scope abbr", flowContent);
          add2("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
          add2("fieldset", "disabled form name", [
            flowContent,
            "legend"
          ].join(" "));
          add2("label", "form for", phrasingContent);
          add2("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width");
          add2("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", type2 === "html4" ? flowContent : phrasingContent);
          add2("select", "disabled form multiple name required size", "option optgroup");
          add2("optgroup", "disabled label", "option");
          add2("option", "disabled label selected value");
          add2("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
          add2("menu", "type label", [
            flowContent,
            "li"
          ].join(" "));
          add2("noscript", "", flowContent);
          if (type2 !== "html4") {
            add2("wbr");
            add2("ruby", "", [
              phrasingContent,
              "rt rp"
            ].join(" "));
            add2("figcaption", "", flowContent);
            add2("mark rt rp summary bdi", "", phrasingContent);
            add2("canvas", "width height", flowContent);
            add2("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
              flowContent,
              "track source"
            ].join(" "));
            add2("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
              flowContent,
              "track source"
            ].join(" "));
            add2("picture", "", "img source");
            add2("source", "src srcset type media sizes");
            add2("track", "kind src srclang label default");
            add2("datalist", "", [
              phrasingContent,
              "option"
            ].join(" "));
            add2("article section nav aside main header footer", "", flowContent);
            add2("hgroup", "", "h1 h2 h3 h4 h5 h6");
            add2("figure", "", [
              flowContent,
              "figcaption"
            ].join(" "));
            add2("time", "datetime", phrasingContent);
            add2("dialog", "open", flowContent);
            add2("command", "type label icon disabled checked radiogroup command");
            add2("output", "for form name", phrasingContent);
            add2("progress", "value max", phrasingContent);
            add2("meter", "value min max low high optimum", phrasingContent);
            add2("details", "open", [
              flowContent,
              "summary"
            ].join(" "));
            add2("keygen", "autofocus challenge disabled form keytype name");
          }
          if (type2 !== "html5-strict") {
            addAttrs("script", "language xml:space");
            addAttrs("style", "xml:space");
            addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
            addAttrs("embed", "align name hspace vspace");
            addAttrs("param", "valuetype type");
            addAttrs("a", "charset name rev shape coords");
            addAttrs("br", "clear");
            addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
            addAttrs("img", "name longdesc align border hspace vspace");
            addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
            addAttrs("font basefont", "size color face");
            addAttrs("input", "usemap align");
            addAttrs("select", "onchange");
            addAttrs("textarea");
            addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
            addAttrs("ul", "type compact");
            addAttrs("li", "type");
            addAttrs("ol dl menu dir", "compact");
            addAttrs("pre", "width xml:space");
            addAttrs("hr", "align noshade size width");
            addAttrs("isindex", "prompt");
            addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
            addAttrs("col", "width align char charoff valign");
            addAttrs("colgroup", "width align char charoff valign");
            addAttrs("thead", "align char charoff valign");
            addAttrs("tr", "align char charoff valign bgcolor");
            addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
            addAttrs("form", "accept");
            addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
            addAttrs("tfoot", "align char charoff valign");
            addAttrs("tbody", "align char charoff valign");
            addAttrs("area", "nohref");
            addAttrs("body", "background bgcolor text link vlink alink");
          }
          if (type2 !== "html4") {
            addAttrs("input button select textarea", "autofocus");
            addAttrs("input textarea", "placeholder");
            addAttrs("a", "download");
            addAttrs("link script img", "crossorigin");
            addAttrs("iframe", "sandbox seamless allowfullscreen");
          }
          each$4(split("a form meter progress dfn"), function(name2) {
            if (schema[name2]) {
              delete schema[name2].children[name2];
            }
          });
          delete schema.caption.children.table;
          delete schema.script;
          mapCache[type2] = schema;
          return schema;
        };
        var compileElementMap = function(value2, mode) {
          var styles;
          if (value2) {
            styles = {};
            if (typeof value2 === "string") {
              value2 = { "*": value2 };
            }
            each$4(value2, function(value3, key) {
              styles[key] = styles[key.toUpperCase()] = mode === "map" ? makeMap$2(value3, /[, ]/) : explode$1(value3, /[, ]/);
            });
          }
          return styles;
        };
        function Schema(settings) {
          var elements = {};
          var children2 = {};
          var patternElements = [];
          var validStyles;
          var invalidStyles;
          var schemaItems;
          var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
          var blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
          var customElementsMap = {}, specialElements = {};
          var createLookupTable = function(option, defaultValue, extendWith) {
            var value2 = settings[option];
            if (!value2) {
              value2 = mapCache[option];
              if (!value2) {
                value2 = makeMap$2(defaultValue, " ", makeMap$2(defaultValue.toUpperCase(), " "));
                value2 = extend$1(value2, extendWith);
                mapCache[option] = value2;
              }
            } else {
              value2 = makeMap$2(value2, /[, ]/, makeMap$2(value2.toUpperCase(), /[, ]/));
            }
            return value2;
          };
          settings = settings || {};
          schemaItems = compileSchema(settings.schema);
          if (settings.verify_html === false) {
            settings.valid_elements = "*[*]";
          }
          validStyles = compileElementMap(settings.valid_styles);
          invalidStyles = compileElementMap(settings.invalid_styles, "map");
          validClasses = compileElementMap(settings.valid_classes, "map");
          whiteSpaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea video audio iframe object code");
          selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
          shortEndedElementsMap = createLookupTable("short_ended_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track");
          boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls");
          nonEmptyElementsMap = createLookupTable("non_empty_elements", "td th iframe video audio object script pre code", shortEndedElementsMap);
          moveCaretBeforeOnEnterElementsMap = createLookupTable("move_caret_before_on_enter_elements", "table", nonEmptyElementsMap);
          textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure");
          blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", textBlockElementsMap);
          textInlineElementsMap = createLookupTable("text_inline_elements", "span strong b em i font strike u var cite dfn code mark q sup sub samp");
          each$4((settings.special || "script noscript iframe noframes noembed title style textarea xmp").split(" "), function(name2) {
            specialElements[name2] = new RegExp("</" + name2 + "[^>]*>", "gi");
          });
          var patternToRegExp = function(str) {
            return new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
          };
          var addValidElements = function(validElements) {
            var ei, el, ai, al, matches2, element, attr, attrData, elementName, attrName, attrType, attributes2, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, key, value2;
            var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
            if (validElements) {
              validElements = split(validElements, ",");
              if (elements["@"]) {
                globalAttributes = elements["@"].attributes;
                globalAttributesOrder = elements["@"].attributesOrder;
              }
              for (ei = 0, el = validElements.length; ei < el; ei++) {
                matches2 = elementRuleRegExp.exec(validElements[ei]);
                if (matches2) {
                  prefix = matches2[1];
                  elementName = matches2[2];
                  outputName = matches2[3];
                  attrData = matches2[5];
                  attributes2 = {};
                  attributesOrder = [];
                  element = {
                    attributes: attributes2,
                    attributesOrder
                  };
                  if (prefix === "#") {
                    element.paddEmpty = true;
                  }
                  if (prefix === "-") {
                    element.removeEmpty = true;
                  }
                  if (matches2[4] === "!") {
                    element.removeEmptyAttrs = true;
                  }
                  if (globalAttributes) {
                    for (key in globalAttributes) {
                      attributes2[key] = globalAttributes[key];
                    }
                    attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
                  }
                  if (attrData) {
                    attrData = split(attrData, "|");
                    for (ai = 0, al = attrData.length; ai < al; ai++) {
                      matches2 = attrRuleRegExp.exec(attrData[ai]);
                      if (matches2) {
                        attr = {};
                        attrType = matches2[1];
                        attrName = matches2[2].replace(/[\\:]:/g, ":");
                        prefix = matches2[3];
                        value2 = matches2[4];
                        if (attrType === "!") {
                          element.attributesRequired = element.attributesRequired || [];
                          element.attributesRequired.push(attrName);
                          attr.required = true;
                        }
                        if (attrType === "-") {
                          delete attributes2[attrName];
                          attributesOrder.splice(inArray$1(attributesOrder, attrName), 1);
                          continue;
                        }
                        if (prefix) {
                          if (prefix === "=") {
                            element.attributesDefault = element.attributesDefault || [];
                            element.attributesDefault.push({
                              name: attrName,
                              value: value2
                            });
                            attr.defaultValue = value2;
                          }
                          if (prefix === ":") {
                            element.attributesForced = element.attributesForced || [];
                            element.attributesForced.push({
                              name: attrName,
                              value: value2
                            });
                            attr.forcedValue = value2;
                          }
                          if (prefix === "<") {
                            attr.validValues = makeMap$2(value2, "?");
                          }
                        }
                        if (hasPatternsRegExp.test(attrName)) {
                          element.attributePatterns = element.attributePatterns || [];
                          attr.pattern = patternToRegExp(attrName);
                          element.attributePatterns.push(attr);
                        } else {
                          if (!attributes2[attrName]) {
                            attributesOrder.push(attrName);
                          }
                          attributes2[attrName] = attr;
                        }
                      }
                    }
                  }
                  if (!globalAttributes && elementName === "@") {
                    globalAttributes = attributes2;
                    globalAttributesOrder = attributesOrder;
                  }
                  if (outputName) {
                    element.outputName = elementName;
                    elements[outputName] = element;
                  }
                  if (hasPatternsRegExp.test(elementName)) {
                    element.pattern = patternToRegExp(elementName);
                    patternElements.push(element);
                  } else {
                    elements[elementName] = element;
                  }
                }
              }
            }
          };
          var setValidElements = function(validElements) {
            elements = {};
            patternElements = [];
            addValidElements(validElements);
            each$4(schemaItems, function(element, name2) {
              children2[name2] = element.children;
            });
          };
          var addCustomElements = function(customElements) {
            var customElementRegExp = /^(~)?(.+)$/;
            if (customElements) {
              mapCache.text_block_elements = mapCache.block_elements = null;
              each$4(split(customElements, ","), function(rule) {
                var matches2 = customElementRegExp.exec(rule), inline = matches2[1] === "~", cloneName = inline ? "span" : "div", name2 = matches2[2];
                children2[name2] = children2[cloneName];
                customElementsMap[name2] = cloneName;
                if (!inline) {
                  blockElementsMap[name2.toUpperCase()] = {};
                  blockElementsMap[name2] = {};
                }
                if (!elements[name2]) {
                  var customRule = elements[cloneName];
                  customRule = extend$1({}, customRule);
                  delete customRule.removeEmptyAttrs;
                  delete customRule.removeEmpty;
                  elements[name2] = customRule;
                }
                each$4(children2, function(element, elmName) {
                  if (element[cloneName]) {
                    children2[elmName] = element = extend$1({}, children2[elmName]);
                    element[name2] = element[cloneName];
                  }
                });
              });
            }
          };
          var addValidChildren = function(validChildren) {
            var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
            mapCache[settings.schema] = null;
            if (validChildren) {
              each$4(split(validChildren, ","), function(rule) {
                var matches2 = childRuleRegExp.exec(rule);
                var parent2, prefix;
                if (matches2) {
                  prefix = matches2[1];
                  if (prefix) {
                    parent2 = children2[matches2[2]];
                  } else {
                    parent2 = children2[matches2[2]] = { "#comment": {} };
                  }
                  parent2 = children2[matches2[2]];
                  each$4(split(matches2[3], "|"), function(child2) {
                    if (prefix === "-") {
                      delete parent2[child2];
                    } else {
                      parent2[child2] = {};
                    }
                  });
                }
              });
            }
          };
          var getElementRule = function(name2) {
            var element = elements[name2], i2;
            if (element) {
              return element;
            }
            i2 = patternElements.length;
            while (i2--) {
              element = patternElements[i2];
              if (element.pattern.test(name2)) {
                return element;
              }
            }
          };
          if (!settings.valid_elements) {
            each$4(schemaItems, function(element, name2) {
              elements[name2] = {
                attributes: element.attributes,
                attributesOrder: element.attributesOrder
              };
              children2[name2] = element.children;
            });
            if (settings.schema !== "html5") {
              each$4(split("strong/b em/i"), function(item) {
                item = split(item, "/");
                elements[item[1]].outputName = item[0];
              });
            }
            each$4(split("ol ul sub sup blockquote span font a table tbody tr strong em b i"), function(name2) {
              if (elements[name2]) {
                elements[name2].removeEmpty = true;
              }
            });
            each$4(split("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), function(name2) {
              elements[name2].paddEmpty = true;
            });
            each$4(split("span"), function(name2) {
              elements[name2].removeEmptyAttrs = true;
            });
          } else {
            setValidElements(settings.valid_elements);
          }
          addCustomElements(settings.custom_elements);
          addValidChildren(settings.valid_children);
          addValidElements(settings.extended_valid_elements);
          addValidChildren("+ol[ul|ol],+ul[ul|ol]");
          each$4({
            dd: "dl",
            dt: "dl",
            li: "ul ol",
            td: "tr",
            th: "tr",
            tr: "tbody thead tfoot",
            tbody: "table",
            thead: "table",
            tfoot: "table",
            legend: "fieldset",
            area: "map",
            param: "video audio object"
          }, function(parents2, item) {
            if (elements[item]) {
              elements[item].parentsRequired = split(parents2);
            }
          });
          if (settings.invalid_elements) {
            each$4(explode$1(settings.invalid_elements), function(item) {
              if (elements[item]) {
                delete elements[item];
              }
            });
          }
          if (!getElementRule("span")) {
            addValidElements("span[!data-mce-type|*]");
          }
          var getValidStyles = function() {
            return validStyles;
          };
          var getInvalidStyles = function() {
            return invalidStyles;
          };
          var getValidClasses = function() {
            return validClasses;
          };
          var getBoolAttrs = function() {
            return boolAttrMap;
          };
          var getBlockElements = function() {
            return blockElementsMap;
          };
          var getTextBlockElements = function() {
            return textBlockElementsMap;
          };
          var getTextInlineElements = function() {
            return textInlineElementsMap;
          };
          var getShortEndedElements = function() {
            return shortEndedElementsMap;
          };
          var getSelfClosingElements = function() {
            return selfClosingElementsMap;
          };
          var getNonEmptyElements = function() {
            return nonEmptyElementsMap;
          };
          var getMoveCaretBeforeOnEnterElements = function() {
            return moveCaretBeforeOnEnterElementsMap;
          };
          var getWhiteSpaceElements = function() {
            return whiteSpaceElementsMap;
          };
          var getSpecialElements = function() {
            return specialElements;
          };
          var isValidChild = function(name2, child2) {
            var parent2 = children2[name2.toLowerCase()];
            return !!(parent2 && parent2[child2.toLowerCase()]);
          };
          var isValid2 = function(name2, attr) {
            var attrPatterns, i2;
            var rule = getElementRule(name2);
            if (rule) {
              if (attr) {
                if (rule.attributes[attr]) {
                  return true;
                }
                attrPatterns = rule.attributePatterns;
                if (attrPatterns) {
                  i2 = attrPatterns.length;
                  while (i2--) {
                    if (attrPatterns[i2].pattern.test(name2)) {
                      return true;
                    }
                  }
                }
              } else {
                return true;
              }
            }
            return false;
          };
          var getCustomElements = function() {
            return customElementsMap;
          };
          return {
            children: children2,
            elements,
            getValidStyles,
            getValidClasses,
            getBlockElements,
            getInvalidStyles,
            getShortEndedElements,
            getTextBlockElements,
            getTextInlineElements,
            getBoolAttrs,
            getElementRule,
            getSelfClosingElements,
            getNonEmptyElements,
            getMoveCaretBeforeOnEnterElements,
            getWhiteSpaceElements,
            getSpecialElements,
            isValidChild,
            isValid: isValid2,
            getCustomElements,
            addValidElements,
            setValidElements,
            addCustomElements,
            addValidChildren
          };
        }
        var toHex = function(match2, r, g, b) {
          var hex = function(val) {
            val = parseInt(val, 10).toString(16);
            return val.length > 1 ? val : "0" + val;
          };
          return "#" + hex(r) + hex(g) + hex(b);
        };
        function Styles(settings, schema) {
          var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
          var urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
          var styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
          var trimRightRegExp = /\s+$/;
          var i2;
          var encodingLookup = {};
          var encodingItems;
          var validStyles;
          var invalidStyles;
          var invisibleChar = "\uFEFF";
          settings = settings || {};
          if (schema) {
            validStyles = schema.getValidStyles();
            invalidStyles = schema.getInvalidStyles();
          }
          encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(" ");
          for (i2 = 0; i2 < encodingItems.length; i2++) {
            encodingLookup[encodingItems[i2]] = invisibleChar + i2;
            encodingLookup[invisibleChar + i2] = encodingItems[i2];
          }
          return {
            toHex: function(color) {
              return color.replace(rgbRegExp, toHex);
            },
            parse: function(css) {
              var styles = {};
              var matches2, name2, value2, isEncoded;
              var urlConverter = settings.url_converter;
              var urlConverterScope = settings.url_converter_scope || this;
              var compress = function(prefix, suffix, noJoin) {
                var top, right, bottom, left;
                top = styles[prefix + "-top" + suffix];
                if (!top) {
                  return;
                }
                right = styles[prefix + "-right" + suffix];
                if (!right) {
                  return;
                }
                bottom = styles[prefix + "-bottom" + suffix];
                if (!bottom) {
                  return;
                }
                left = styles[prefix + "-left" + suffix];
                if (!left) {
                  return;
                }
                var box = [
                  top,
                  right,
                  bottom,
                  left
                ];
                i2 = box.length - 1;
                while (i2--) {
                  if (box[i2] !== box[i2 + 1]) {
                    break;
                  }
                }
                if (i2 > -1 && noJoin) {
                  return;
                }
                styles[prefix + suffix] = i2 === -1 ? box[0] : box.join(" ");
                delete styles[prefix + "-top" + suffix];
                delete styles[prefix + "-right" + suffix];
                delete styles[prefix + "-bottom" + suffix];
                delete styles[prefix + "-left" + suffix];
              };
              var canCompress = function(key) {
                var value3 = styles[key], i3;
                if (!value3) {
                  return;
                }
                value3 = value3.split(" ");
                i3 = value3.length;
                while (i3--) {
                  if (value3[i3] !== value3[0]) {
                    return false;
                  }
                }
                styles[key] = value3[0];
                return true;
              };
              var compress2 = function(target, a, b, c) {
                if (!canCompress(a)) {
                  return;
                }
                if (!canCompress(b)) {
                  return;
                }
                if (!canCompress(c)) {
                  return;
                }
                styles[target] = styles[a] + " " + styles[b] + " " + styles[c];
                delete styles[a];
                delete styles[b];
                delete styles[c];
              };
              var encode = function(str) {
                isEncoded = true;
                return encodingLookup[str];
              };
              var decode2 = function(str, keepSlashes) {
                if (isEncoded) {
                  str = str.replace(/\uFEFF[0-9]/g, function(str2) {
                    return encodingLookup[str2];
                  });
                }
                if (!keepSlashes) {
                  str = str.replace(/\\([\'\";:])/g, "$1");
                }
                return str;
              };
              var decodeSingleHexSequence = function(escSeq) {
                return String.fromCharCode(parseInt(escSeq.slice(1), 16));
              };
              var decodeHexSequences = function(value3) {
                return value3.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
              };
              var processUrl = function(match2, url2, url22, url3, str, str2) {
                str = str || str2;
                if (str) {
                  str = decode2(str);
                  return "'" + str.replace(/\'/g, "\\'") + "'";
                }
                url2 = decode2(url2 || url22 || url3);
                if (!settings.allow_script_urls) {
                  var scriptUrl = url2.replace(/[\s\r\n]+/g, "");
                  if (/(java|vb)script:/i.test(scriptUrl)) {
                    return "";
                  }
                  if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                    return "";
                  }
                }
                if (urlConverter) {
                  url2 = urlConverter.call(urlConverterScope, url2, "style");
                }
                return "url('" + url2.replace(/\'/g, "\\'") + "')";
              };
              if (css) {
                css = css.replace(/[\u0000-\u001F]/g, "");
                css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
                  return str.replace(/[;:]/g, encode);
                });
                while (matches2 = styleRegExp.exec(css)) {
                  styleRegExp.lastIndex = matches2.index + matches2[0].length;
                  name2 = matches2[1].replace(trimRightRegExp, "").toLowerCase();
                  value2 = matches2[2].replace(trimRightRegExp, "");
                  if (name2 && value2) {
                    name2 = decodeHexSequences(name2);
                    value2 = decodeHexSequences(value2);
                    if (name2.indexOf(invisibleChar) !== -1 || name2.indexOf('"') !== -1) {
                      continue;
                    }
                    if (!settings.allow_script_urls && (name2 === "behavior" || /expression\s*\(|\/\*|\*\//.test(value2))) {
                      continue;
                    }
                    if (name2 === "font-weight" && value2 === "700") {
                      value2 = "bold";
                    } else if (name2 === "color" || name2 === "background-color") {
                      value2 = value2.toLowerCase();
                    }
                    value2 = value2.replace(rgbRegExp, toHex);
                    value2 = value2.replace(urlOrStrRegExp, processUrl);
                    styles[name2] = isEncoded ? decode2(value2, true) : value2;
                  }
                }
                compress("border", "", true);
                compress("border", "-width");
                compress("border", "-color");
                compress("border", "-style");
                compress("padding", "");
                compress("margin", "");
                compress2("border", "border-width", "border-style", "border-color");
                if (styles.border === "medium none") {
                  delete styles.border;
                }
                if (styles["border-image"] === "none") {
                  delete styles["border-image"];
                }
              }
              return styles;
            },
            serialize: function(styles, elementName) {
              var css = "", name2, value2;
              var serializeStyles = function(name3) {
                var styleList, i3, l, value3;
                styleList = validStyles[name3];
                if (styleList) {
                  for (i3 = 0, l = styleList.length; i3 < l; i3++) {
                    name3 = styleList[i3];
                    value3 = styles[name3];
                    if (value3) {
                      css += (css.length > 0 ? " " : "") + name3 + ": " + value3 + ";";
                    }
                  }
                }
              };
              var isValid2 = function(name3, elementName2) {
                var styleMap;
                styleMap = invalidStyles["*"];
                if (styleMap && styleMap[name3]) {
                  return false;
                }
                styleMap = invalidStyles[elementName2];
                if (styleMap && styleMap[name3]) {
                  return false;
                }
                return true;
              };
              if (elementName && validStyles) {
                serializeStyles("*");
                serializeStyles(elementName);
              } else {
                for (name2 in styles) {
                  value2 = styles[name2];
                  if (value2 && (!invalidStyles || isValid2(name2, elementName))) {
                    css += (css.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
                  }
                }
              }
              return css;
            }
          };
        }
        var each$5 = Tools.each;
        var grep$1 = Tools.grep;
        var isIE = Env.ie;
        var simpleSelectorRe = /^([a-z0-9],?)+$/i;
        var whiteSpaceRegExp$2 = /^[ \t\r\n]*$/;
        var setupAttrHooks = function(styles, settings, getContext) {
          var attrHooks2 = {};
          var keepValues = settings.keep_values;
          var keepUrlHook = {
            set: function($elm, value2, name2) {
              if (settings.url_converter) {
                value2 = settings.url_converter.call(settings.url_converter_scope || getContext(), value2, name2, $elm[0]);
              }
              $elm.attr("data-mce-" + name2, value2).attr(name2, value2);
            },
            get: function($elm, name2) {
              return $elm.attr("data-mce-" + name2) || $elm.attr(name2);
            }
          };
          attrHooks2 = {
            style: {
              set: function($elm, value2) {
                if (value2 !== null && typeof value2 === "object") {
                  $elm.css(value2);
                  return;
                }
                if (keepValues) {
                  $elm.attr("data-mce-style", value2);
                }
                $elm.attr("style", value2);
              },
              get: function($elm) {
                var value2 = $elm.attr("data-mce-style") || $elm.attr("style");
                value2 = styles.serialize(styles.parse(value2), $elm[0].nodeName);
                return value2;
              }
            }
          };
          if (keepValues) {
            attrHooks2.href = attrHooks2.src = keepUrlHook;
          }
          return attrHooks2;
        };
        var updateInternalStyleAttr = function(styles, $elm) {
          var rawValue = $elm.attr("style");
          var value2 = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);
          if (!value2) {
            value2 = null;
          }
          $elm.attr("data-mce-style", value2);
        };
        var findNodeIndex = function(node2, normalized) {
          var idx = 0, lastNodeType, nodeType;
          if (node2) {
            for (lastNodeType = node2.nodeType, node2 = node2.previousSibling; node2; node2 = node2.previousSibling) {
              nodeType = node2.nodeType;
              if (normalized && nodeType === 3) {
                if (nodeType === lastNodeType || !node2.nodeValue.length) {
                  continue;
                }
              }
              idx++;
              lastNodeType = nodeType;
            }
          }
          return idx;
        };
        function DOMUtils(doc2, settings) {
          var _this = this;
          if (settings === void 0) {
            settings = {};
          }
          var attrHooks2;
          var addedStyles = {};
          var win = domGlobals.window;
          var files = {};
          var counter = 0;
          var stdMode = true;
          var boxModel = true;
          var styleSheetLoader = StyleSheetLoader(doc2, { contentCssCors: settings.contentCssCors });
          var boundEvents = [];
          var schema = settings.schema ? settings.schema : Schema({});
          var styles = Styles({
            url_converter: settings.url_converter,
            url_converter_scope: settings.url_converter_scope
          }, settings.schema);
          var events = settings.ownEvents ? new EventUtils(settings.proxy) : EventUtils.Event;
          var blockElementsMap = schema.getBlockElements();
          var $ = DomQuery.overrideDefaults(function() {
            return {
              context: doc2,
              element: self2.getRoot()
            };
          });
          var isBlock2 = function(node2) {
            if (typeof node2 === "string") {
              return !!blockElementsMap[node2];
            } else if (node2) {
              var type2 = node2.nodeType;
              if (type2) {
                return !!(type2 === 1 && blockElementsMap[node2.nodeName]);
              }
            }
            return false;
          };
          var get2 = function(elm) {
            if (elm && doc2 && typeof elm === "string") {
              var node2 = doc2.getElementById(elm);
              if (node2 && node2.id !== elm) {
                return doc2.getElementsByName(elm)[1];
              } else {
                return node2;
              }
            }
            return elm;
          };
          var $$ = function(elm) {
            if (typeof elm === "string") {
              elm = get2(elm);
            }
            return $(elm);
          };
          var getAttrib = function(elm, name2, defaultVal) {
            var hook, value2;
            var $elm = $$(elm);
            if ($elm.length) {
              hook = attrHooks2[name2];
              if (hook && hook.get) {
                value2 = hook.get($elm, name2);
              } else {
                value2 = $elm.attr(name2);
              }
            }
            if (typeof value2 === "undefined") {
              value2 = defaultVal || "";
            }
            return value2;
          };
          var getAttribs = function(elm) {
            var node2 = get2(elm);
            if (!node2) {
              return [];
            }
            return node2.attributes;
          };
          var setAttrib = function(elm, name2, value2) {
            var originalValue, hook;
            if (value2 === "") {
              value2 = null;
            }
            var $elm = $$(elm);
            originalValue = $elm.attr(name2);
            if (!$elm.length) {
              return;
            }
            hook = attrHooks2[name2];
            if (hook && hook.set) {
              hook.set($elm, value2, name2);
            } else {
              $elm.attr(name2, value2);
            }
            if (originalValue !== value2 && settings.onSetAttrib) {
              settings.onSetAttrib({
                attrElm: $elm,
                attrName: name2,
                attrValue: value2
              });
            }
          };
          var clone2 = function(node2, deep2) {
            if (!isIE || node2.nodeType !== 1 || deep2) {
              return node2.cloneNode(deep2);
            }
            if (!deep2) {
              var clone_1 = doc2.createElement(node2.nodeName);
              each$5(getAttribs(node2), function(attr) {
                setAttrib(clone_1, attr.nodeName, getAttrib(node2, attr.nodeName));
              });
              return clone_1;
            }
            return null;
          };
          var getRoot = function() {
            return settings.root_element || doc2.body;
          };
          var getViewPort = function(argWin) {
            var actWin = !argWin ? win : argWin;
            var doc3 = actWin.document;
            var rootElm = doc3.documentElement;
            return {
              x: actWin.pageXOffset || rootElm.scrollLeft,
              y: actWin.pageYOffset || rootElm.scrollTop,
              w: actWin.innerWidth || rootElm.clientWidth,
              h: actWin.innerHeight || rootElm.clientHeight
            };
          };
          var getPos2 = function(elm, rootElm) {
            return Position.getPos(doc2.body, get2(elm), rootElm);
          };
          var setStyle = function(elm, name2, value2) {
            var $elm = $$(elm).css(name2, value2);
            if (settings.update_styles) {
              updateInternalStyleAttr(styles, $elm);
            }
          };
          var setStyles = function(elm, stylesArg) {
            var $elm = $$(elm).css(stylesArg);
            if (settings.update_styles) {
              updateInternalStyleAttr(styles, $elm);
            }
          };
          var getStyle2 = function(elm, name2, computed) {
            var $elm = $$(elm);
            if (computed) {
              return $elm.css(name2);
            }
            name2 = name2.replace(/-(\D)/g, function(a, b) {
              return b.toUpperCase();
            });
            if (name2 === "float") {
              name2 = Env.ie && Env.ie < 12 ? "styleFloat" : "cssFloat";
            }
            return $elm[0] && $elm[0].style ? $elm[0].style[name2] : void 0;
          };
          var getSize = function(elm) {
            var w, h;
            elm = get2(elm);
            w = getStyle2(elm, "width");
            h = getStyle2(elm, "height");
            if (w.indexOf("px") === -1) {
              w = 0;
            }
            if (h.indexOf("px") === -1) {
              h = 0;
            }
            return {
              w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
              h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
            };
          };
          var getRect = function(elm) {
            var pos, size;
            elm = get2(elm);
            pos = getPos2(elm);
            size = getSize(elm);
            return {
              x: pos.x,
              y: pos.y,
              w: size.w,
              h: size.h
            };
          };
          var is2 = function(elm, selector) {
            var i2;
            if (!elm) {
              return false;
            }
            if (!Array.isArray(elm)) {
              if (selector === "*") {
                return elm.nodeType === 1;
              }
              if (simpleSelectorRe.test(selector)) {
                var selectors = selector.toLowerCase().split(/,/);
                var elmName = elm.nodeName.toLowerCase();
                for (i2 = selectors.length - 1; i2 >= 0; i2--) {
                  if (selectors[i2] === elmName) {
                    return true;
                  }
                }
                return false;
              }
              if (elm.nodeType && elm.nodeType !== 1) {
                return false;
              }
            }
            var elms = !Array.isArray(elm) ? [elm] : elm;
            return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
          };
          var getParents2 = function(elm, selector, root, collect) {
            var result = [];
            var selectorVal;
            var node2 = get2(elm);
            collect = collect === void 0;
            root = root || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
            if (Tools.is(selector, "string")) {
              selectorVal = selector;
              if (selector === "*") {
                selector = function(node3) {
                  return node3.nodeType === 1;
                };
              } else {
                selector = function(node3) {
                  return is2(node3, selectorVal);
                };
              }
            }
            while (node2) {
              if (node2 === root || !node2.nodeType || node2.nodeType === 9) {
                break;
              }
              if (!selector || typeof selector === "function" && selector(node2)) {
                if (collect) {
                  result.push(node2);
                } else {
                  return [node2];
                }
              }
              node2 = node2.parentNode;
            }
            return collect ? result : null;
          };
          var getParent = function(node2, selector, root) {
            var parents2 = getParents2(node2, selector, root, false);
            return parents2 && parents2.length > 0 ? parents2[0] : null;
          };
          var _findSib = function(node2, selector, name2) {
            var func = selector;
            if (node2) {
              if (typeof selector === "string") {
                func = function(node3) {
                  return is2(node3, selector);
                };
              }
              for (node2 = node2[name2]; node2; node2 = node2[name2]) {
                if (typeof func === "function" && func(node2)) {
                  return node2;
                }
              }
            }
            return null;
          };
          var getNext = function(node2, selector) {
            return _findSib(node2, selector, "nextSibling");
          };
          var getPrev = function(node2, selector) {
            return _findSib(node2, selector, "previousSibling");
          };
          var select2 = function(selector, scope) {
            return Sizzle(selector, get2(scope) || settings.root_element || doc2, []);
          };
          var run = function(elm, func, scope) {
            var result;
            var node2 = typeof elm === "string" ? get2(elm) : elm;
            if (!node2) {
              return false;
            }
            if (Tools.isArray(node2) && (node2.length || node2.length === 0)) {
              result = [];
              each$5(node2, function(elm2, i2) {
                if (elm2) {
                  if (typeof elm2 === "string") {
                    elm2 = get2(elm2);
                  }
                  result.push(func.call(scope, elm2, i2));
                }
              });
              return result;
            }
            var context2 = scope ? scope : _this;
            return func.call(context2, node2);
          };
          var setAttribs = function(elm, attrs) {
            $$(elm).each(function(i2, node2) {
              each$5(attrs, function(value2, name2) {
                setAttrib(node2, name2, value2);
              });
            });
          };
          var setHTML = function(elm, html) {
            var $elm = $$(elm);
            if (isIE) {
              $elm.each(function(i2, target) {
                if (target.canHaveHTML === false) {
                  return;
                }
                while (target.firstChild) {
                  target.removeChild(target.firstChild);
                }
                try {
                  target.innerHTML = "<br>" + html;
                  target.removeChild(target.firstChild);
                } catch (ex) {
                  DomQuery("<div></div>").html("<br>" + html).contents().slice(1).appendTo(target);
                }
                return html;
              });
            } else {
              $elm.html(html);
            }
          };
          var add2 = function(parentElm, name2, attrs, html, create3) {
            return run(parentElm, function(parentElm2) {
              var newElm = typeof name2 === "string" ? doc2.createElement(name2) : name2;
              setAttribs(newElm, attrs);
              if (html) {
                if (typeof html !== "string" && html.nodeType) {
                  newElm.appendChild(html);
                } else if (typeof html === "string") {
                  setHTML(newElm, html);
                }
              }
              return !create3 ? parentElm2.appendChild(newElm) : newElm;
            });
          };
          var create2 = function(name2, attrs, html) {
            return add2(doc2.createElement(name2), name2, attrs, html, true);
          };
          var decode2 = Entities.decode;
          var encode = Entities.encodeAllRaw;
          var createHTML = function(name2, attrs, html) {
            var outHtml = "", key;
            outHtml += "<" + name2;
            for (key in attrs) {
              if (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] !== "undefined") {
                outHtml += " " + key + '="' + encode(attrs[key]) + '"';
              }
            }
            if (typeof html !== "undefined") {
              return outHtml + ">" + html + "</" + name2 + ">";
            }
            return outHtml + " />";
          };
          var createFragment2 = function(html) {
            var node2;
            var container = doc2.createElement("div");
            var frag = doc2.createDocumentFragment();
            frag.appendChild(container);
            if (html) {
              container.innerHTML = html;
            }
            while (node2 = container.firstChild) {
              frag.appendChild(node2);
            }
            frag.removeChild(container);
            return frag;
          };
          var remove2 = function(node2, keepChildren) {
            var $node = $$(node2);
            if (keepChildren) {
              $node.each(function() {
                var child2;
                while (child2 = this.firstChild) {
                  if (child2.nodeType === 3 && child2.data.length === 0) {
                    this.removeChild(child2);
                  } else {
                    this.parentNode.insertBefore(child2, this);
                  }
                }
              }).remove();
            } else {
              $node.remove();
            }
            return $node.length > 1 ? $node.toArray() : $node[0];
          };
          var removeAllAttribs = function(e) {
            return run(e, function(e2) {
              var i2;
              var attrs = e2.attributes;
              for (i2 = attrs.length - 1; i2 >= 0; i2--) {
                e2.removeAttributeNode(attrs.item(i2));
              }
            });
          };
          var parseStyle = function(cssText) {
            return styles.parse(cssText);
          };
          var serializeStyle = function(stylesArg, name2) {
            return styles.serialize(stylesArg, name2);
          };
          var addStyle = function(cssText) {
            var head2, styleElm;
            if (self2 !== DOMUtils.DOM && doc2 === domGlobals.document) {
              if (addedStyles[cssText]) {
                return;
              }
              addedStyles[cssText] = true;
            }
            styleElm = doc2.getElementById("mceDefaultStyles");
            if (!styleElm) {
              styleElm = doc2.createElement("style");
              styleElm.id = "mceDefaultStyles";
              styleElm.type = "text/css";
              head2 = doc2.getElementsByTagName("head")[0];
              if (head2.firstChild) {
                head2.insertBefore(styleElm, head2.firstChild);
              } else {
                head2.appendChild(styleElm);
              }
            }
            if (styleElm.styleSheet) {
              styleElm.styleSheet.cssText += cssText;
            } else {
              styleElm.appendChild(doc2.createTextNode(cssText));
            }
          };
          var loadCSS = function(url2) {
            var head2;
            if (self2 !== DOMUtils.DOM && doc2 === domGlobals.document) {
              DOMUtils.DOM.loadCSS(url2);
              return;
            }
            if (!url2) {
              url2 = "";
            }
            head2 = doc2.getElementsByTagName("head")[0];
            each$5(url2.split(","), function(url3) {
              var link;
              url3 = Tools._addCacheSuffix(url3);
              if (files[url3]) {
                return;
              }
              files[url3] = true;
              link = create2("link", {
                rel: "stylesheet",
                href: url3
              });
              head2.appendChild(link);
            });
          };
          var toggleClass2 = function(elm, cls, state) {
            $$(elm).toggleClass(cls, state).each(function() {
              if (this.className === "") {
                DomQuery(this).attr("class", null);
              }
            });
          };
          var addClass = function(elm, cls) {
            $$(elm).addClass(cls);
          };
          var removeClass = function(elm, cls) {
            toggleClass2(elm, cls, false);
          };
          var hasClass2 = function(elm, cls) {
            return $$(elm).hasClass(cls);
          };
          var show = function(elm) {
            $$(elm).show();
          };
          var hide = function(elm) {
            $$(elm).hide();
          };
          var isHidden = function(elm) {
            return $$(elm).css("display") === "none";
          };
          var uniqueId2 = function(prefix) {
            return (!prefix ? "mce_" : prefix) + counter++;
          };
          var getOuterHTML = function(elm) {
            var node2 = typeof elm === "string" ? get2(elm) : elm;
            return NodeType.isElement(node2) ? node2.outerHTML : DomQuery("<div></div>").append(DomQuery(node2).clone()).html();
          };
          var setOuterHTML = function(elm, html) {
            $$(elm).each(function() {
              try {
                if ("outerHTML" in this) {
                  this.outerHTML = html;
                  return;
                }
              } catch (ex) {
              }
              remove2(DomQuery(this).html(html), true);
            });
          };
          var insertAfter2 = function(node2, reference) {
            var referenceNode = get2(reference);
            return run(node2, function(node3) {
              var parent2, nextSibling2;
              parent2 = referenceNode.parentNode;
              nextSibling2 = referenceNode.nextSibling;
              if (nextSibling2) {
                parent2.insertBefore(node3, nextSibling2);
              } else {
                parent2.appendChild(node3);
              }
              return node3;
            });
          };
          var replace = function(newElm, oldElm, keepChildren) {
            return run(oldElm, function(oldElm2) {
              if (Tools.is(oldElm2, "array")) {
                newElm = newElm.cloneNode(true);
              }
              if (keepChildren) {
                each$5(grep$1(oldElm2.childNodes), function(node2) {
                  newElm.appendChild(node2);
                });
              }
              return oldElm2.parentNode.replaceChild(newElm, oldElm2);
            });
          };
          var rename = function(elm, name2) {
            var newElm;
            if (elm.nodeName !== name2.toUpperCase()) {
              newElm = create2(name2);
              each$5(getAttribs(elm), function(attrNode) {
                setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
              });
              replace(newElm, elm, true);
            }
            return newElm || elm;
          };
          var findCommonAncestor = function(a, b) {
            var ps = a, pe;
            while (ps) {
              pe = b;
              while (pe && ps !== pe) {
                pe = pe.parentNode;
              }
              if (ps === pe) {
                break;
              }
              ps = ps.parentNode;
            }
            if (!ps && a.ownerDocument) {
              return a.ownerDocument.documentElement;
            }
            return ps;
          };
          var toHex2 = function(rgbVal) {
            return styles.toHex(Tools.trim(rgbVal));
          };
          var isEmpty2 = function(node2, elements) {
            var i2, attributes2, type2, whitespace2, walker, name2, brCount = 0;
            node2 = node2.firstChild;
            if (node2) {
              walker = new TreeWalker(node2, node2.parentNode);
              elements = elements || (schema ? schema.getNonEmptyElements() : null);
              whitespace2 = schema ? schema.getWhiteSpaceElements() : {};
              do {
                type2 = node2.nodeType;
                if (NodeType.isElement(node2)) {
                  var bogusVal = node2.getAttribute("data-mce-bogus");
                  if (bogusVal) {
                    node2 = walker.next(bogusVal === "all");
                    continue;
                  }
                  name2 = node2.nodeName.toLowerCase();
                  if (elements && elements[name2]) {
                    if (name2 === "br") {
                      brCount++;
                      node2 = walker.next();
                      continue;
                    }
                    return false;
                  }
                  attributes2 = getAttribs(node2);
                  i2 = attributes2.length;
                  while (i2--) {
                    name2 = attributes2[i2].nodeName;
                    if (name2 === "name" || name2 === "data-mce-bookmark") {
                      return false;
                    }
                  }
                }
                if (type2 === 8) {
                  return false;
                }
                if (type2 === 3 && !whiteSpaceRegExp$2.test(node2.nodeValue)) {
                  return false;
                }
                if (type2 === 3 && node2.parentNode && whitespace2[node2.parentNode.nodeName] && whiteSpaceRegExp$2.test(node2.nodeValue)) {
                  return false;
                }
                node2 = walker.next();
              } while (node2);
            }
            return brCount <= 1;
          };
          var createRng = function() {
            return doc2.createRange();
          };
          var split2 = function(parentElm, splitElm, replacementElm) {
            var r = createRng(), bef, aft, pa;
            if (parentElm && splitElm) {
              r.setStart(parentElm.parentNode, findNodeIndex(parentElm));
              r.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
              bef = r.extractContents();
              r = createRng();
              r.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
              r.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);
              aft = r.extractContents();
              pa = parentElm.parentNode;
              pa.insertBefore(TrimNode.trimNode(self2, bef), parentElm);
              if (replacementElm) {
                pa.insertBefore(replacementElm, parentElm);
              } else {
                pa.insertBefore(splitElm, parentElm);
              }
              pa.insertBefore(TrimNode.trimNode(self2, aft), parentElm);
              remove2(parentElm);
              return replacementElm || splitElm;
            }
          };
          var bind2 = function(target, name2, func, scope) {
            if (Tools.isArray(target)) {
              var i2 = target.length;
              while (i2--) {
                target[i2] = bind2(target[i2], name2, func, scope);
              }
              return target;
            }
            if (settings.collect && (target === doc2 || target === win)) {
              boundEvents.push([
                target,
                name2,
                func,
                scope
              ]);
            }
            return events.bind(target, name2, func, scope || self2);
          };
          var unbind = function(target, name2, func) {
            var i2;
            if (Tools.isArray(target)) {
              i2 = target.length;
              while (i2--) {
                target[i2] = unbind(target[i2], name2, func);
              }
              return target;
            }
            if (boundEvents && (target === doc2 || target === win)) {
              i2 = boundEvents.length;
              while (i2--) {
                var item = boundEvents[i2];
                if (target === item[0] && (!name2 || name2 === item[1]) && (!func || func === item[2])) {
                  events.unbind(item[0], item[1], item[2]);
                }
              }
            }
            return events.unbind(target, name2, func);
          };
          var fire = function(target, name2, evt) {
            return events.fire(target, name2, evt);
          };
          var getContentEditable = function(node2) {
            if (node2 && NodeType.isElement(node2)) {
              var contentEditable2 = node2.getAttribute("data-mce-contenteditable");
              if (contentEditable2 && contentEditable2 !== "inherit") {
                return contentEditable2;
              }
              return node2.contentEditable !== "inherit" ? node2.contentEditable : null;
            } else {
              return null;
            }
          };
          var getContentEditableParent = function(node2) {
            var root = getRoot();
            var state = null;
            for (; node2 && node2 !== root; node2 = node2.parentNode) {
              state = getContentEditable(node2);
              if (state !== null) {
                break;
              }
            }
            return state;
          };
          var destroy2 = function() {
            if (boundEvents) {
              var i2 = boundEvents.length;
              while (i2--) {
                var item = boundEvents[i2];
                events.unbind(item[0], item[1], item[2]);
              }
            }
            if (Sizzle.setDocument) {
              Sizzle.setDocument();
            }
          };
          var isChildOf = function(node2, parent2) {
            while (node2) {
              if (parent2 === node2) {
                return true;
              }
              node2 = node2.parentNode;
            }
            return false;
          };
          var dumpRng = function(r) {
            return "startContainer: " + r.startContainer.nodeName + ", startOffset: " + r.startOffset + ", endContainer: " + r.endContainer.nodeName + ", endOffset: " + r.endOffset;
          };
          var self2 = {
            doc: doc2,
            settings,
            win,
            files,
            stdMode,
            boxModel,
            styleSheetLoader,
            boundEvents,
            styles,
            schema,
            events,
            isBlock: isBlock2,
            $,
            $$,
            root: null,
            clone: clone2,
            getRoot,
            getViewPort,
            getRect,
            getSize,
            getParent,
            getParents: getParents2,
            get: get2,
            getNext,
            getPrev,
            select: select2,
            is: is2,
            add: add2,
            create: create2,
            createHTML,
            createFragment: createFragment2,
            remove: remove2,
            setStyle,
            getStyle: getStyle2,
            setStyles,
            removeAllAttribs,
            setAttrib,
            setAttribs,
            getAttrib,
            getPos: getPos2,
            parseStyle,
            serializeStyle,
            addStyle,
            loadCSS,
            addClass,
            removeClass,
            hasClass: hasClass2,
            toggleClass: toggleClass2,
            show,
            hide,
            isHidden,
            uniqueId: uniqueId2,
            setHTML,
            getOuterHTML,
            setOuterHTML,
            decode: decode2,
            encode,
            insertAfter: insertAfter2,
            replace,
            rename,
            findCommonAncestor,
            toHex: toHex2,
            run,
            getAttribs,
            isEmpty: isEmpty2,
            createRng,
            nodeIndex: findNodeIndex,
            split: split2,
            bind: bind2,
            unbind,
            fire,
            getContentEditable,
            getContentEditableParent,
            destroy: destroy2,
            isChildOf,
            dumpRng
          };
          attrHooks2 = setupAttrHooks(styles, settings, function() {
            return self2;
          });
          return self2;
        }
        (function(DOMUtils2) {
          DOMUtils2.DOM = DOMUtils2(domGlobals.document);
          DOMUtils2.nodeIndex = findNodeIndex;
        })(DOMUtils || (DOMUtils = {}));
        var DOMUtils$1 = DOMUtils;
        var DOM = DOMUtils$1.DOM;
        var each$6 = Tools.each, grep$2 = Tools.grep;
        var isFunction$1 = function(f) {
          return typeof f === "function";
        };
        var ScriptLoader = function() {
          var QUEUED = 0;
          var LOADING = 1;
          var LOADED = 2;
          var FAILED = 3;
          var states = {};
          var queue = [];
          var scriptLoadedCallbacks = {};
          var queueLoadedCallbacks = [];
          var loading = 0;
          var loadScript = function(url2, success, failure) {
            var dom2 = DOM;
            var elm, id;
            var done2 = function() {
              dom2.remove(id);
              if (elm) {
                elm.onreadystatechange = elm.onload = elm = null;
              }
              success();
            };
            var error2 = function() {
              if (isFunction$1(failure)) {
                failure();
              } else {
                if (typeof console !== "undefined" && console.log) {
                  console.log("Failed to load script: " + url2);
                }
              }
            };
            id = dom2.uniqueId();
            elm = domGlobals.document.createElement("script");
            elm.id = id;
            elm.type = "text/javascript";
            elm.src = Tools._addCacheSuffix(url2);
            elm.onload = done2;
            elm.onerror = error2;
            (domGlobals.document.getElementsByTagName("head")[0] || domGlobals.document.body).appendChild(elm);
          };
          this.isDone = function(url2) {
            return states[url2] === LOADED;
          };
          this.markDone = function(url2) {
            states[url2] = LOADED;
          };
          this.add = this.load = function(url2, success, scope, failure) {
            var state = states[url2];
            if (state === void 0) {
              queue.push(url2);
              states[url2] = QUEUED;
            }
            if (success) {
              if (!scriptLoadedCallbacks[url2]) {
                scriptLoadedCallbacks[url2] = [];
              }
              scriptLoadedCallbacks[url2].push({
                success,
                failure,
                scope: scope || this
              });
            }
          };
          this.remove = function(url2) {
            delete states[url2];
            delete scriptLoadedCallbacks[url2];
          };
          this.loadQueue = function(success, scope, failure) {
            this.loadScripts(queue, success, scope, failure);
          };
          this.loadScripts = function(scripts, success, scope, failure) {
            var loadScripts2;
            var failures = [];
            var execCallbacks = function(name2, url2) {
              each$6(scriptLoadedCallbacks[url2], function(callback) {
                if (isFunction$1(callback[name2])) {
                  callback[name2].call(callback.scope);
                }
              });
              scriptLoadedCallbacks[url2] = void 0;
            };
            queueLoadedCallbacks.push({
              success,
              failure,
              scope: scope || this
            });
            loadScripts2 = function() {
              var loadingScripts = grep$2(scripts);
              scripts.length = 0;
              each$6(loadingScripts, function(url2) {
                if (states[url2] === LOADED) {
                  execCallbacks("success", url2);
                  return;
                }
                if (states[url2] === FAILED) {
                  execCallbacks("failure", url2);
                  return;
                }
                if (states[url2] !== LOADING) {
                  states[url2] = LOADING;
                  loading++;
                  loadScript(url2, function() {
                    states[url2] = LOADED;
                    loading--;
                    execCallbacks("success", url2);
                    loadScripts2();
                  }, function() {
                    states[url2] = FAILED;
                    loading--;
                    failures.push(url2);
                    execCallbacks("failure", url2);
                    loadScripts2();
                  });
                }
              });
              if (!loading) {
                var notifyCallbacks = queueLoadedCallbacks.slice(0);
                queueLoadedCallbacks.length = 0;
                each$6(notifyCallbacks, function(callback) {
                  if (failures.length === 0) {
                    if (isFunction$1(callback.success)) {
                      callback.success.call(callback.scope);
                    }
                  } else {
                    if (isFunction$1(callback.failure)) {
                      callback.failure.call(callback.scope, failures);
                    }
                  }
                });
              }
            };
            loadScripts2();
          };
        };
        ScriptLoader.ScriptLoader = new ScriptLoader();
        var each$7 = Tools.each;
        function AddOnManager() {
          var _this = this;
          var items = [];
          var urls = {};
          var lookup = {};
          var _listeners = [];
          var get2 = function(name2) {
            if (lookup[name2]) {
              return lookup[name2].instance;
            }
            return void 0;
          };
          var dependencies = function(name2) {
            var result;
            if (lookup[name2]) {
              result = lookup[name2].dependencies;
            }
            return result || [];
          };
          var requireLangPack = function(name2, languages) {
            var language = AddOnManager.language;
            if (language && AddOnManager.languageLoad !== false) {
              if (languages) {
                languages = "," + languages + ",";
                if (languages.indexOf("," + language.substr(0, 2) + ",") !== -1) {
                  language = language.substr(0, 2);
                } else if (languages.indexOf("," + language + ",") === -1) {
                  return;
                }
              }
              ScriptLoader.ScriptLoader.add(urls[name2] + "/langs/" + language + ".js");
            }
          };
          var add2 = function(id, addOn, dependencies2) {
            items.push(addOn);
            lookup[id] = {
              instance: addOn,
              dependencies: dependencies2
            };
            var result = partition(_listeners, function(listener) {
              return listener.name === id;
            });
            _listeners = result.fail;
            each$7(result.pass, function(listener) {
              listener.callback();
            });
            return addOn;
          };
          var remove2 = function(name2) {
            delete urls[name2];
            delete lookup[name2];
          };
          var createUrl = function(baseUrl, dep) {
            if (typeof dep === "object") {
              return dep;
            }
            return typeof baseUrl === "string" ? {
              prefix: "",
              resource: dep,
              suffix: ""
            } : {
              prefix: baseUrl.prefix,
              resource: dep,
              suffix: baseUrl.suffix
            };
          };
          var addComponents = function(pluginName, scripts) {
            var pluginUrl = _this.urls[pluginName];
            each$7(scripts, function(script) {
              ScriptLoader.ScriptLoader.add(pluginUrl + "/" + script);
            });
          };
          var loadDependencies = function(name2, addOnUrl, success, scope) {
            var deps = dependencies(name2);
            each$7(deps, function(dep) {
              var newUrl = createUrl(addOnUrl, dep);
              load(newUrl.resource, newUrl, void 0, void 0);
            });
            if (success) {
              if (scope) {
                success.call(scope);
              } else {
                success.call(ScriptLoader);
              }
            }
          };
          var load = function(name2, addOnUrl, success, scope, failure) {
            if (urls[name2]) {
              return;
            }
            var urlString = typeof addOnUrl === "string" ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
            if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) {
              urlString = AddOnManager.baseURL + "/" + urlString;
            }
            urls[name2] = urlString.substring(0, urlString.lastIndexOf("/"));
            if (lookup[name2]) {
              loadDependencies(name2, addOnUrl, success, scope);
            } else {
              ScriptLoader.ScriptLoader.add(urlString, function() {
                return loadDependencies(name2, addOnUrl, success, scope);
              }, scope, failure);
            }
          };
          var waitFor = function(name2, callback) {
            if (lookup.hasOwnProperty(name2)) {
              callback();
            } else {
              _listeners.push({
                name: name2,
                callback
              });
            }
          };
          return {
            items,
            urls,
            lookup,
            _listeners,
            get: get2,
            dependencies,
            requireLangPack,
            add: add2,
            remove: remove2,
            createUrl,
            addComponents,
            load,
            waitFor
          };
        }
        (function(AddOnManager2) {
          AddOnManager2.PluginManager = AddOnManager2();
          AddOnManager2.ThemeManager = AddOnManager2();
        })(AddOnManager || (AddOnManager = {}));
        var before = function(marker, element) {
          var parent$1 = parent(marker);
          parent$1.each(function(v) {
            v.dom().insertBefore(element.dom(), marker.dom());
          });
        };
        var after = function(marker, element) {
          var sibling2 = nextSibling(marker);
          sibling2.fold(function() {
            var parent$1 = parent(marker);
            parent$1.each(function(v) {
              append(v, element);
            });
          }, function(v) {
            before(v, element);
          });
        };
        var prepend = function(parent2, element) {
          var firstChild$1 = firstChild(parent2);
          firstChild$1.fold(function() {
            append(parent2, element);
          }, function(v) {
            parent2.dom().insertBefore(element.dom(), v.dom());
          });
        };
        var append = function(parent2, element) {
          parent2.dom().appendChild(element.dom());
        };
        var wrap$1 = function(element, wrapper) {
          before(element, wrapper);
          append(wrapper, element);
        };
        var before$1 = function(marker, elements) {
          each(elements, function(x) {
            before(marker, x);
          });
        };
        var append$1 = function(parent2, elements) {
          each(elements, function(x) {
            append(parent2, x);
          });
        };
        var empty = function(element) {
          element.dom().textContent = "";
          each(children(element), function(rogue) {
            remove$1(rogue);
          });
        };
        var remove$1 = function(element) {
          var dom2 = element.dom();
          if (dom2.parentNode !== null) {
            dom2.parentNode.removeChild(dom2);
          }
        };
        var unwrap = function(wrapper) {
          var children$1 = children(wrapper);
          if (children$1.length > 0) {
            before$1(wrapper, children$1);
          }
          remove$1(wrapper);
        };
        var first = function(fn, rate) {
          var timer = null;
          var cancel = function() {
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
              timer = null;
            }
          };
          var throttle = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (timer === null) {
              timer = domGlobals.setTimeout(function() {
                fn.apply(null, args);
                timer = null;
              }, rate);
            }
          };
          return {
            cancel,
            throttle
          };
        };
        var last$2 = function(fn, rate) {
          var timer = null;
          var cancel = function() {
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
              timer = null;
            }
          };
          var throttle = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
            }
            timer = domGlobals.setTimeout(function() {
              fn.apply(null, args);
              timer = null;
            }, rate);
          };
          return {
            cancel,
            throttle
          };
        };
        var Cell = function(initial) {
          var value2 = initial;
          var get2 = function() {
            return value2;
          };
          var set2 = function(v) {
            value2 = v;
          };
          var clone2 = function() {
            return Cell(get2());
          };
          return {
            get: get2,
            set: set2,
            clone: clone2
          };
        };
        var read = function(element, attr) {
          var value2 = get(element, attr);
          return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
        };
        var add = function(element, attr, id) {
          var old = read(element, attr);
          var nu2 = old.concat([id]);
          set(element, attr, nu2.join(" "));
          return true;
        };
        var remove$2 = function(element, attr, id) {
          var nu2 = filter(read(element, attr), function(v) {
            return v !== id;
          });
          if (nu2.length > 0) {
            set(element, attr, nu2.join(" "));
          } else {
            remove(element, attr);
          }
          return false;
        };
        var supports = function(element) {
          return element.dom().classList !== void 0;
        };
        var get$2 = function(element) {
          return read(element, "class");
        };
        var add$1 = function(element, clazz) {
          return add(element, "class", clazz);
        };
        var remove$3 = function(element, clazz) {
          return remove$2(element, "class", clazz);
        };
        var add$2 = function(element, clazz) {
          if (supports(element)) {
            element.dom().classList.add(clazz);
          } else {
            add$1(element, clazz);
          }
        };
        var cleanClass = function(element) {
          var classList = supports(element) ? element.dom().classList : get$2(element);
          if (classList.length === 0) {
            remove(element, "class");
          }
        };
        var remove$4 = function(element, clazz) {
          if (supports(element)) {
            var classList = element.dom().classList;
            classList.remove(clazz);
          } else {
            remove$3(element, clazz);
          }
          cleanClass(element);
        };
        var has$2 = function(element, clazz) {
          return supports(element) && element.dom().classList.contains(clazz);
        };
        var descendants = function(scope, predicate) {
          var result = [];
          each(children(scope), function(x) {
            if (predicate(x)) {
              result = result.concat([x]);
            }
            result = result.concat(descendants(x, predicate));
          });
          return result;
        };
        var descendants$1 = function(scope, selector) {
          return all(selector, scope);
        };
        function ClosestOrAncestor(is2, ancestor2, scope, a, isRoot) {
          return is2(scope, a) ? Option.some(scope) : isFunction(isRoot) && isRoot(scope) ? Option.none() : ancestor2(scope, a, isRoot);
        }
        var ancestor = function(scope, predicate, isRoot) {
          var element = scope.dom();
          var stop2 = isFunction(isRoot) ? isRoot : constant(false);
          while (element.parentNode) {
            element = element.parentNode;
            var el = Element.fromDom(element);
            if (predicate(el)) {
              return Option.some(el);
            } else if (stop2(el)) {
              break;
            }
          }
          return Option.none();
        };
        var closest = function(scope, predicate, isRoot) {
          var is2 = function(s, test) {
            return test(s);
          };
          return ClosestOrAncestor(is2, ancestor, scope, predicate, isRoot);
        };
        var ancestor$1 = function(scope, selector, isRoot) {
          return ancestor(scope, function(e) {
            return is$1(e, selector);
          }, isRoot);
        };
        var descendant = function(scope, selector) {
          return one(selector, scope);
        };
        var closest$1 = function(scope, selector, isRoot) {
          return ClosestOrAncestor(is$1, ancestor$1, scope, selector, isRoot);
        };
        var annotation = constant("mce-annotation");
        var dataAnnotation = constant("data-mce-annotation");
        var dataAnnotationId = constant("data-mce-annotation-uid");
        var identify = function(editor, annotationName) {
          var rng = editor.selection.getRng();
          var start2 = Element.fromDom(rng.startContainer);
          var root = Element.fromDom(editor.getBody());
          var selector = annotationName.fold(function() {
            return "." + annotation();
          }, function(an) {
            return "[" + dataAnnotation() + '="' + an + '"]';
          });
          var newStart = child(start2, rng.startOffset).getOr(start2);
          var closest2 = closest$1(newStart, selector, function(n) {
            return eq(n, root);
          });
          var getAttr = function(c, property) {
            if (has$1(c, property)) {
              return Option.some(get(c, property));
            } else {
              return Option.none();
            }
          };
          return closest2.bind(function(c) {
            return getAttr(c, "" + dataAnnotationId()).bind(function(uid) {
              return getAttr(c, "" + dataAnnotation()).map(function(name2) {
                var elements = findMarkers(editor, uid);
                return {
                  uid,
                  name: name2,
                  elements
                };
              });
            });
          });
        };
        var isAnnotation = function(elem) {
          return isElement(elem) && has$2(elem, annotation());
        };
        var findMarkers = function(editor, uid) {
          var body = Element.fromDom(editor.getBody());
          return descendants$1(body, "[" + dataAnnotationId() + '="' + uid + '"]');
        };
        var findAll = function(editor, name2) {
          var body = Element.fromDom(editor.getBody());
          var markers = descendants$1(body, "[" + dataAnnotation() + '="' + name2 + '"]');
          var directory = {};
          each(markers, function(m) {
            var uid = get(m, dataAnnotationId());
            var nodesAlready = directory.hasOwnProperty(uid) ? directory[uid] : [];
            directory[uid] = nodesAlready.concat([m]);
          });
          return directory;
        };
        var setup = function(editor, registry) {
          var changeCallbacks = Cell({});
          var initData = function() {
            return {
              listeners: [],
              previous: Cell(Option.none())
            };
          };
          var withCallbacks = function(name2, f) {
            updateCallbacks(name2, function(data2) {
              f(data2);
              return data2;
            });
          };
          var updateCallbacks = function(name2, f) {
            var callbackMap = changeCallbacks.get();
            var data2 = callbackMap.hasOwnProperty(name2) ? callbackMap[name2] : initData();
            var outputData = f(data2);
            callbackMap[name2] = outputData;
            changeCallbacks.set(callbackMap);
          };
          var fireCallbacks = function(name2, uid, elements) {
            withCallbacks(name2, function(data2) {
              each(data2.listeners, function(f) {
                return f(true, name2, {
                  uid,
                  nodes: map(elements, function(elem) {
                    return elem.dom();
                  })
                });
              });
            });
          };
          var fireNoAnnotation = function(name2) {
            withCallbacks(name2, function(data2) {
              each(data2.listeners, function(f) {
                return f(false, name2);
              });
            });
          };
          var onNodeChange = last$2(function() {
            var callbackMap = changeCallbacks.get();
            var annotations = sort(keys(callbackMap));
            each(annotations, function(name2) {
              updateCallbacks(name2, function(data2) {
                var prev = data2.previous.get();
                identify(editor, Option.some(name2)).fold(function() {
                  if (prev.isSome()) {
                    fireNoAnnotation(name2);
                    data2.previous.set(Option.none());
                  }
                }, function(_a) {
                  var uid = _a.uid, name3 = _a.name, elements = _a.elements;
                  if (!prev.is(uid)) {
                    fireCallbacks(name3, uid, elements);
                    data2.previous.set(Option.some(uid));
                  }
                });
                return {
                  previous: data2.previous,
                  listeners: data2.listeners
                };
              });
            });
          }, 30);
          editor.on("remove", function() {
            onNodeChange.cancel();
          });
          editor.on("nodeChange", function() {
            onNodeChange.throttle();
          });
          var addListener = function(name2, f) {
            updateCallbacks(name2, function(data2) {
              return {
                previous: data2.previous,
                listeners: data2.listeners.concat([f])
              };
            });
          };
          return { addListener };
        };
        var setup$1 = function(editor, registry) {
          var identifyParserNode = function(span) {
            var optAnnotation = Option.from(span.attributes.map[dataAnnotation()]);
            return optAnnotation.bind(registry.lookup);
          };
          editor.on("init", function() {
            editor.serializer.addNodeFilter("span", function(spans) {
              each(spans, function(span) {
                identifyParserNode(span).each(function(settings) {
                  if (settings.persistent === false) {
                    span.unwrap();
                  }
                });
              });
            });
          });
        };
        var create$1 = function() {
          var annotations = {};
          var register2 = function(name2, settings) {
            annotations[name2] = {
              name: name2,
              settings
            };
          };
          var lookup = function(name2) {
            return annotations.hasOwnProperty(name2) ? Option.from(annotations[name2]).map(function(a) {
              return a.settings;
            }) : Option.none();
          };
          return {
            register: register2,
            lookup
          };
        };
        var __assign = function() {
          __assign = Object.assign || function __assign2(t) {
            for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s = arguments[i2];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        function __rest(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
              if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
                t[p[i2]] = s[p[i2]];
            }
          return t;
        }
        function __spreadArrays() {
          for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
            s += arguments[i2].length;
          for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
            for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        }
        var unique = 0;
        var generate = function(prefix) {
          var date = new Date();
          var time = date.getTime();
          var random = Math.floor(Math.random() * 1e9);
          unique++;
          return prefix + "_" + random + unique + String(time);
        };
        var add$3 = function(element, classes) {
          each(classes, function(x) {
            add$2(element, x);
          });
        };
        var clone = function(original, isDeep) {
          return Element.fromDom(original.dom().cloneNode(isDeep));
        };
        var shallow = function(original) {
          return clone(original, false);
        };
        var deep = function(original) {
          return clone(original, true);
        };
        var fromHtml$1 = function(html, scope) {
          var doc2 = scope || domGlobals.document;
          var div = doc2.createElement("div");
          div.innerHTML = html;
          return children(Element.fromDom(div));
        };
        var get$3 = function(element) {
          return element.dom().innerHTML;
        };
        var set$1 = function(element, content) {
          var owner$1 = owner(element);
          var docDom = owner$1.dom();
          var fragment = Element.fromDom(docDom.createDocumentFragment());
          var contentElements = fromHtml$1(content, docDom);
          append$1(fragment, contentElements);
          empty(element);
          append(element, fragment);
        };
        var ZWSP = "\uFEFF";
        var isZwsp = function(chr) {
          return chr === ZWSP;
        };
        var trim$3 = function(text) {
          return text.replace(new RegExp(ZWSP, "g"), "");
        };
        var Zwsp = {
          isZwsp,
          ZWSP,
          trim: trim$3
        };
        var isElement$2 = NodeType.isElement;
        var isText$2 = NodeType.isText;
        var isCaretContainerBlock = function(node2) {
          if (isText$2(node2)) {
            node2 = node2.parentNode;
          }
          return isElement$2(node2) && node2.hasAttribute("data-mce-caret");
        };
        var isCaretContainerInline = function(node2) {
          return isText$2(node2) && Zwsp.isZwsp(node2.data);
        };
        var isCaretContainer = function(node2) {
          return isCaretContainerBlock(node2) || isCaretContainerInline(node2);
        };
        var hasContent = function(node2) {
          return node2.firstChild !== node2.lastChild || !NodeType.isBr(node2.firstChild);
        };
        var insertInline = function(node2, before2) {
          var doc2, sibling2, textNode, parentNode;
          doc2 = node2.ownerDocument;
          textNode = doc2.createTextNode(Zwsp.ZWSP);
          parentNode = node2.parentNode;
          if (!before2) {
            sibling2 = node2.nextSibling;
            if (isText$2(sibling2)) {
              if (isCaretContainer(sibling2)) {
                return sibling2;
              }
              if (startsWithCaretContainer(sibling2)) {
                sibling2.splitText(1);
                return sibling2;
              }
            }
            if (node2.nextSibling) {
              parentNode.insertBefore(textNode, node2.nextSibling);
            } else {
              parentNode.appendChild(textNode);
            }
          } else {
            sibling2 = node2.previousSibling;
            if (isText$2(sibling2)) {
              if (isCaretContainer(sibling2)) {
                return sibling2;
              }
              if (endsWithCaretContainer(sibling2)) {
                return sibling2.splitText(sibling2.data.length - 1);
              }
            }
            parentNode.insertBefore(textNode, node2);
          }
          return textNode;
        };
        var isBeforeInline = function(pos) {
          var container = pos.container();
          if (!pos || !NodeType.isText(container)) {
            return false;
          }
          return container.data.charAt(pos.offset()) === Zwsp.ZWSP || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
        };
        var isAfterInline = function(pos) {
          var container = pos.container();
          if (!pos || !NodeType.isText(container)) {
            return false;
          }
          return container.data.charAt(pos.offset() - 1) === Zwsp.ZWSP || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
        };
        var createBogusBr = function() {
          var br = domGlobals.document.createElement("br");
          br.setAttribute("data-mce-bogus", "1");
          return br;
        };
        var insertBlock = function(blockName, node2, before2) {
          var doc2, blockNode, parentNode;
          doc2 = node2.ownerDocument;
          blockNode = doc2.createElement(blockName);
          blockNode.setAttribute("data-mce-caret", before2 ? "before" : "after");
          blockNode.setAttribute("data-mce-bogus", "all");
          blockNode.appendChild(createBogusBr());
          parentNode = node2.parentNode;
          if (!before2) {
            if (node2.nextSibling) {
              parentNode.insertBefore(blockNode, node2.nextSibling);
            } else {
              parentNode.appendChild(blockNode);
            }
          } else {
            parentNode.insertBefore(blockNode, node2);
          }
          return blockNode;
        };
        var startsWithCaretContainer = function(node2) {
          return isText$2(node2) && node2.data[0] === Zwsp.ZWSP;
        };
        var endsWithCaretContainer = function(node2) {
          return isText$2(node2) && node2.data[node2.data.length - 1] === Zwsp.ZWSP;
        };
        var trimBogusBr = function(elm) {
          var brs = elm.getElementsByTagName("br");
          var lastBr = brs[brs.length - 1];
          if (NodeType.isBogus(lastBr)) {
            lastBr.parentNode.removeChild(lastBr);
          }
        };
        var showCaretContainerBlock = function(caretContainer) {
          if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
            trimBogusBr(caretContainer);
            caretContainer.removeAttribute("data-mce-caret");
            caretContainer.removeAttribute("data-mce-bogus");
            caretContainer.removeAttribute("style");
            caretContainer.removeAttribute("_moz_abspos");
            return caretContainer;
          }
          return null;
        };
        var isRangeInCaretContainerBlock = function(range2) {
          return isCaretContainerBlock(range2.startContainer);
        };
        var isContentEditableTrue$1 = NodeType.isContentEditableTrue;
        var isContentEditableFalse$1 = NodeType.isContentEditableFalse;
        var isBr$2 = NodeType.isBr;
        var isText$3 = NodeType.isText;
        var isInvalidTextElement = NodeType.matchNodeNames("script style textarea");
        var isAtomicInline = NodeType.matchNodeNames("img input textarea hr iframe video audio object");
        var isTable$1 = NodeType.matchNodeNames("table");
        var isCaretContainer$1 = isCaretContainer;
        var isCaretCandidate = function(node2) {
          if (isCaretContainer$1(node2)) {
            return false;
          }
          if (isText$3(node2)) {
            if (isInvalidTextElement(node2.parentNode)) {
              return false;
            }
            return true;
          }
          return isAtomicInline(node2) || isBr$2(node2) || isTable$1(node2) || isNonUiContentEditableFalse(node2);
        };
        var isUnselectable = function(node2) {
          return NodeType.isElement(node2) && node2.getAttribute("unselectable") === "true";
        };
        var isNonUiContentEditableFalse = function(node2) {
          return isUnselectable(node2) === false && isContentEditableFalse$1(node2);
        };
        var isInEditable = function(node2, root) {
          for (node2 = node2.parentNode; node2 && node2 !== root; node2 = node2.parentNode) {
            if (isNonUiContentEditableFalse(node2)) {
              return false;
            }
            if (isContentEditableTrue$1(node2)) {
              return true;
            }
          }
          return true;
        };
        var isAtomicContentEditableFalse = function(node2) {
          if (!isNonUiContentEditableFalse(node2)) {
            return false;
          }
          return foldl(from$1(node2.getElementsByTagName("*")), function(result, elm) {
            return result || isContentEditableTrue$1(elm);
          }, false) !== true;
        };
        var isAtomic = function(node2) {
          return isAtomicInline(node2) || isAtomicContentEditableFalse(node2);
        };
        var isEditableCaretCandidate = function(node2, root) {
          return isCaretCandidate(node2) && isInEditable(node2, root);
        };
        var round = Math.round;
        var clone$1 = function(rect) {
          if (!rect) {
            return {
              left: 0,
              top: 0,
              bottom: 0,
              right: 0,
              width: 0,
              height: 0
            };
          }
          return {
            left: round(rect.left),
            top: round(rect.top),
            bottom: round(rect.bottom),
            right: round(rect.right),
            width: round(rect.width),
            height: round(rect.height)
          };
        };
        var collapse = function(rect, toStart) {
          rect = clone$1(rect);
          if (toStart) {
            rect.right = rect.left;
          } else {
            rect.left = rect.left + rect.width;
            rect.right = rect.left;
          }
          rect.width = 0;
          return rect;
        };
        var isEqual = function(rect1, rect2) {
          return rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
        };
        var isValidOverflow = function(overflowY2, rect1, rect2) {
          return overflowY2 >= 0 && overflowY2 <= Math.min(rect1.height, rect2.height) / 2;
        };
        var isAbove = function(rect1, rect2) {
          var halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
          if (rect1.bottom - halfHeight < rect2.top) {
            return true;
          }
          if (rect1.top > rect2.bottom) {
            return false;
          }
          return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
        };
        var isBelow = function(rect1, rect2) {
          if (rect1.top > rect2.bottom) {
            return true;
          }
          if (rect1.bottom < rect2.top) {
            return false;
          }
          return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
        };
        var containsXY = function(rect, clientX, clientY) {
          return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
        };
        var overflowX = function(outer, inner) {
          if (inner.left > outer.left && inner.right < outer.right) {
            return 0;
          } else {
            return inner.left < outer.left ? inner.left - outer.left : inner.right - outer.right;
          }
        };
        var overflowY = function(outer, inner) {
          if (inner.top > outer.top && inner.bottom < outer.bottom) {
            return 0;
          } else {
            return inner.top < outer.top ? inner.top - outer.top : inner.bottom - outer.bottom;
          }
        };
        var getOverflow = function(outer, inner) {
          return {
            x: overflowX(outer, inner),
            y: overflowY(outer, inner)
          };
        };
        var getSelectedNode = function(range2) {
          var startContainer = range2.startContainer, startOffset = range2.startOffset;
          if (startContainer.hasChildNodes() && range2.endOffset === startOffset + 1) {
            return startContainer.childNodes[startOffset];
          }
          return null;
        };
        var getNode = function(container, offset) {
          if (container.nodeType === 1 && container.hasChildNodes()) {
            if (offset >= container.childNodes.length) {
              offset = container.childNodes.length - 1;
            }
            container = container.childNodes[offset];
          }
          return container;
        };
        var extendingChars = new RegExp("[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]");
        var isExtendingChar = function(ch) {
          return typeof ch === "string" && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
        };
        var lift2 = function(oa, ob, f) {
          return oa.isSome() && ob.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie())) : Option.none();
        };
        var lift3 = function(oa, ob, oc, f) {
          return oa.isSome() && ob.isSome() && oc.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Option.none();
        };
        var slice$2 = [].slice;
        var or = function() {
          var x = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            x[_i] = arguments[_i];
          }
          var args = slice$2.call(arguments);
          return function(x2) {
            for (var i2 = 0; i2 < args.length; i2++) {
              if (args[i2](x2)) {
                return true;
              }
            }
            return false;
          };
        };
        var and = function() {
          var x = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            x[_i] = arguments[_i];
          }
          var args = slice$2.call(arguments);
          return function(x2) {
            for (var i2 = 0; i2 < args.length; i2++) {
              if (!args[i2](x2)) {
                return false;
              }
            }
            return true;
          };
        };
        var Predicate = {
          and,
          or
        };
        var isElement$3 = NodeType.isElement;
        var isCaretCandidate$1 = isCaretCandidate;
        var isBlock$1 = NodeType.matchStyleValues("display", "block table");
        var isFloated = NodeType.matchStyleValues("float", "left right");
        var isValidElementCaretCandidate = Predicate.and(isElement$3, isCaretCandidate$1, not(isFloated));
        var isNotPre = not(NodeType.matchStyleValues("white-space", "pre pre-line pre-wrap"));
        var isText$4 = NodeType.isText;
        var isBr$3 = NodeType.isBr;
        var nodeIndex = DOMUtils$1.nodeIndex;
        var resolveIndex = getNode;
        var createRange = function(doc2) {
          return "createRange" in doc2 ? doc2.createRange() : DOMUtils$1.DOM.createRng();
        };
        var isWhiteSpace = function(chr) {
          return chr && /[\r\n\t ]/.test(chr);
        };
        var isRange = function(rng) {
          return !!rng.setStart && !!rng.setEnd;
        };
        var isHiddenWhiteSpaceRange = function(range2) {
          var container = range2.startContainer;
          var offset = range2.startOffset;
          var text;
          if (isWhiteSpace(range2.toString()) && isNotPre(container.parentNode) && NodeType.isText(container)) {
            text = container.data;
            if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
              return true;
            }
          }
          return false;
        };
        var getBrClientRect = function(brNode) {
          var doc2 = brNode.ownerDocument;
          var rng = createRange(doc2);
          var nbsp2 = doc2.createTextNode("\xA0");
          var parentNode = brNode.parentNode;
          var clientRect;
          parentNode.insertBefore(nbsp2, brNode);
          rng.setStart(nbsp2, 0);
          rng.setEnd(nbsp2, 1);
          clientRect = clone$1(rng.getBoundingClientRect());
          parentNode.removeChild(nbsp2);
          return clientRect;
        };
        var getBoundingClientRectWebKitText = function(rng) {
          var sc = rng.startContainer;
          var ec = rng.endContainer;
          var so = rng.startOffset;
          var eo = rng.endOffset;
          if (sc === ec && NodeType.isText(ec) && so === 0 && eo === 1) {
            var newRng = rng.cloneRange();
            newRng.setEndAfter(ec);
            return getBoundingClientRect(newRng);
          } else {
            return null;
          }
        };
        var isZeroRect = function(r) {
          return r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
        };
        var getBoundingClientRect = function(item) {
          var clientRect, clientRects;
          clientRects = item.getClientRects();
          if (clientRects.length > 0) {
            clientRect = clone$1(clientRects[0]);
          } else {
            clientRect = clone$1(item.getBoundingClientRect());
          }
          if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
            return getBrClientRect(item);
          }
          if (isZeroRect(clientRect) && isRange(item)) {
            return getBoundingClientRectWebKitText(item);
          }
          return clientRect;
        };
        var collapseAndInflateWidth = function(clientRect, toStart) {
          var newClientRect = collapse(clientRect, toStart);
          newClientRect.width = 1;
          newClientRect.right = newClientRect.left + 1;
          return newClientRect;
        };
        var getCaretPositionClientRects = function(caretPosition) {
          var clientRects = [];
          var beforeNode, node2;
          var addUniqueAndValidRect = function(clientRect) {
            if (clientRect.height === 0) {
              return;
            }
            if (clientRects.length > 0) {
              if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
                return;
              }
            }
            clientRects.push(clientRect);
          };
          var addCharacterOffset = function(container, offset) {
            var range2 = createRange(container.ownerDocument);
            if (offset < container.data.length) {
              if (isExtendingChar(container.data[offset])) {
                return clientRects;
              }
              if (isExtendingChar(container.data[offset - 1])) {
                range2.setStart(container, offset);
                range2.setEnd(container, offset + 1);
                if (!isHiddenWhiteSpaceRange(range2)) {
                  addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), false));
                  return clientRects;
                }
              }
            }
            if (offset > 0) {
              range2.setStart(container, offset - 1);
              range2.setEnd(container, offset);
              if (!isHiddenWhiteSpaceRange(range2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), false));
              }
            }
            if (offset < container.data.length) {
              range2.setStart(container, offset);
              range2.setEnd(container, offset + 1);
              if (!isHiddenWhiteSpaceRange(range2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), true));
              }
            }
          };
          if (isText$4(caretPosition.container())) {
            addCharacterOffset(caretPosition.container(), caretPosition.offset());
            return clientRects;
          }
          if (isElement$3(caretPosition.container())) {
            if (caretPosition.isAtEnd()) {
              node2 = resolveIndex(caretPosition.container(), caretPosition.offset());
              if (isText$4(node2)) {
                addCharacterOffset(node2, node2.data.length);
              }
              if (isValidElementCaretCandidate(node2) && !isBr$3(node2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node2), false));
              }
            } else {
              node2 = resolveIndex(caretPosition.container(), caretPosition.offset());
              if (isText$4(node2)) {
                addCharacterOffset(node2, 0);
              }
              if (isValidElementCaretCandidate(node2) && caretPosition.isAtEnd()) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node2), false));
                return clientRects;
              }
              beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
              if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
                if (isBlock$1(beforeNode) || isBlock$1(node2) || !isValidElementCaretCandidate(node2)) {
                  addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
                }
              }
              if (isValidElementCaretCandidate(node2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node2), true));
              }
            }
          }
          return clientRects;
        };
        function CaretPosition(container, offset, clientRects) {
          var isAtStart = function() {
            if (isText$4(container)) {
              return offset === 0;
            }
            return offset === 0;
          };
          var isAtEnd = function() {
            if (isText$4(container)) {
              return offset >= container.data.length;
            }
            return offset >= container.childNodes.length;
          };
          var toRange = function() {
            var range2;
            range2 = createRange(container.ownerDocument);
            range2.setStart(container, offset);
            range2.setEnd(container, offset);
            return range2;
          };
          var getClientRects2 = function() {
            if (!clientRects) {
              clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
            }
            return clientRects;
          };
          var isVisible = function() {
            return getClientRects2().length > 0;
          };
          var isEqual2 = function(caretPosition) {
            return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
          };
          var getNode2 = function(before2) {
            return resolveIndex(container, before2 ? offset - 1 : offset);
          };
          return {
            container: constant(container),
            offset: constant(offset),
            toRange,
            getClientRects: getClientRects2,
            isVisible,
            isAtStart,
            isAtEnd,
            isEqual: isEqual2,
            getNode: getNode2
          };
        }
        (function(CaretPosition2) {
          CaretPosition2.fromRangeStart = function(range2) {
            return CaretPosition2(range2.startContainer, range2.startOffset);
          };
          CaretPosition2.fromRangeEnd = function(range2) {
            return CaretPosition2(range2.endContainer, range2.endOffset);
          };
          CaretPosition2.after = function(node2) {
            return CaretPosition2(node2.parentNode, nodeIndex(node2) + 1);
          };
          CaretPosition2.before = function(node2) {
            return CaretPosition2(node2.parentNode, nodeIndex(node2));
          };
          CaretPosition2.isAbove = function(pos1, pos2) {
            return lift2(head(pos2.getClientRects()), last(pos1.getClientRects()), isAbove).getOr(false);
          };
          CaretPosition2.isBelow = function(pos1, pos2) {
            return lift2(last(pos2.getClientRects()), head(pos1.getClientRects()), isBelow).getOr(false);
          };
          CaretPosition2.isAtStart = function(pos) {
            return pos ? pos.isAtStart() : false;
          };
          CaretPosition2.isAtEnd = function(pos) {
            return pos ? pos.isAtEnd() : false;
          };
          CaretPosition2.isTextPosition = function(pos) {
            return pos ? NodeType.isText(pos.container()) : false;
          };
          CaretPosition2.isElementPosition = function(pos) {
            return CaretPosition2.isTextPosition(pos) === false;
          };
        })(CaretPosition || (CaretPosition = {}));
        var CaretPosition$1 = CaretPosition;
        var isText$5 = NodeType.isText;
        var isBogus$1 = NodeType.isBogus;
        var nodeIndex$1 = DOMUtils$1.nodeIndex;
        var normalizedParent = function(node2) {
          var parentNode = node2.parentNode;
          if (isBogus$1(parentNode)) {
            return normalizedParent(parentNode);
          }
          return parentNode;
        };
        var getChildNodes = function(node2) {
          if (!node2) {
            return [];
          }
          return ArrUtils.reduce(node2.childNodes, function(result, node3) {
            if (isBogus$1(node3) && node3.nodeName !== "BR") {
              result = result.concat(getChildNodes(node3));
            } else {
              result.push(node3);
            }
            return result;
          }, []);
        };
        var normalizedTextOffset = function(node2, offset) {
          while (node2 = node2.previousSibling) {
            if (!isText$5(node2)) {
              break;
            }
            offset += node2.data.length;
          }
          return offset;
        };
        var equal = function(a) {
          return function(b) {
            return a === b;
          };
        };
        var normalizedNodeIndex = function(node2) {
          var nodes, index, numTextFragments;
          nodes = getChildNodes(normalizedParent(node2));
          index = ArrUtils.findIndex(nodes, equal(node2), node2);
          nodes = nodes.slice(0, index + 1);
          numTextFragments = ArrUtils.reduce(nodes, function(result, node3, i2) {
            if (isText$5(node3) && isText$5(nodes[i2 - 1])) {
              result++;
            }
            return result;
          }, 0);
          nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames(node2.nodeName));
          index = ArrUtils.findIndex(nodes, equal(node2), node2);
          return index - numTextFragments;
        };
        var createPathItem = function(node2) {
          var name2;
          if (isText$5(node2)) {
            name2 = "text()";
          } else {
            name2 = node2.nodeName.toLowerCase();
          }
          return name2 + "[" + normalizedNodeIndex(node2) + "]";
        };
        var parentsUntil = function(root, node2, predicate) {
          var parents2 = [];
          for (node2 = node2.parentNode; node2 !== root; node2 = node2.parentNode) {
            if (predicate && predicate(node2)) {
              break;
            }
            parents2.push(node2);
          }
          return parents2;
        };
        var create$2 = function(root, caretPosition) {
          var container, offset, path2 = [], outputOffset, childNodes, parents2;
          container = caretPosition.container();
          offset = caretPosition.offset();
          if (isText$5(container)) {
            outputOffset = normalizedTextOffset(container, offset);
          } else {
            childNodes = container.childNodes;
            if (offset >= childNodes.length) {
              outputOffset = "after";
              offset = childNodes.length - 1;
            } else {
              outputOffset = "before";
            }
            container = childNodes[offset];
          }
          path2.push(createPathItem(container));
          parents2 = parentsUntil(root, container);
          parents2 = ArrUtils.filter(parents2, not(NodeType.isBogus));
          path2 = path2.concat(ArrUtils.map(parents2, function(node2) {
            return createPathItem(node2);
          }));
          return path2.reverse().join("/") + "," + outputOffset;
        };
        var resolvePathItem = function(node2, name2, index) {
          var nodes = getChildNodes(node2);
          nodes = ArrUtils.filter(nodes, function(node3, index2) {
            return !isText$5(node3) || !isText$5(nodes[index2 - 1]);
          });
          nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames(name2));
          return nodes[index];
        };
        var findTextPosition = function(container, offset) {
          var node2 = container, targetOffset = 0, dataLen;
          while (isText$5(node2)) {
            dataLen = node2.data.length;
            if (offset >= targetOffset && offset <= targetOffset + dataLen) {
              container = node2;
              offset = offset - targetOffset;
              break;
            }
            if (!isText$5(node2.nextSibling)) {
              container = node2;
              offset = dataLen;
              break;
            }
            targetOffset += dataLen;
            node2 = node2.nextSibling;
          }
          if (isText$5(container) && offset > container.data.length) {
            offset = container.data.length;
          }
          return CaretPosition$1(container, offset);
        };
        var resolve$2 = function(root, path2) {
          var parts, container, offset;
          if (!path2) {
            return null;
          }
          parts = path2.split(",");
          path2 = parts[0].split("/");
          offset = parts.length > 1 ? parts[1] : "before";
          container = ArrUtils.reduce(path2, function(result, value2) {
            value2 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value2);
            if (!value2) {
              return null;
            }
            if (value2[1] === "text()") {
              value2[1] = "#text";
            }
            return resolvePathItem(result, value2[1], parseInt(value2[2], 10));
          }, root);
          if (!container) {
            return null;
          }
          if (!isText$5(container)) {
            if (offset === "after") {
              offset = nodeIndex$1(container) + 1;
            } else {
              offset = nodeIndex$1(container);
            }
            return CaretPosition$1(container.parentNode, offset);
          }
          return findTextPosition(container, parseInt(offset, 10));
        };
        var trimEmptyTextNode = function(dom2, node2) {
          if (NodeType.isText(node2) && node2.data.length === 0) {
            dom2.remove(node2);
          }
        };
        var insertNode = function(dom2, rng, node2) {
          rng.insertNode(node2);
          trimEmptyTextNode(dom2, node2.previousSibling);
          trimEmptyTextNode(dom2, node2.nextSibling);
        };
        var insertFragment = function(dom2, rng, frag) {
          var firstChild2 = Option.from(frag.firstChild);
          var lastChild2 = Option.from(frag.lastChild);
          rng.insertNode(frag);
          firstChild2.each(function(child2) {
            return trimEmptyTextNode(dom2, child2.previousSibling);
          });
          lastChild2.each(function(child2) {
            return trimEmptyTextNode(dom2, child2.nextSibling);
          });
        };
        var rangeInsertNode = function(dom2, rng, node2) {
          if (NodeType.isDocumentFragment(node2)) {
            insertFragment(dom2, rng, node2);
          } else {
            insertNode(dom2, rng, node2);
          }
        };
        var isContentEditableFalse$2 = NodeType.isContentEditableFalse;
        var getNormalizedTextOffset = function(trim2, container, offset) {
          var node2, trimmedOffset;
          trimmedOffset = trim2(container.data.slice(0, offset)).length;
          for (node2 = container.previousSibling; node2 && NodeType.isText(node2); node2 = node2.previousSibling) {
            trimmedOffset += trim2(node2.data).length;
          }
          return trimmedOffset;
        };
        var getPoint = function(dom2, trim2, normalized, rng, start2) {
          var container = rng[start2 ? "startContainer" : "endContainer"];
          var offset = rng[start2 ? "startOffset" : "endOffset"];
          var point = [];
          var childNodes, after2 = 0;
          var root = dom2.getRoot();
          if (NodeType.isText(container)) {
            point.push(normalized ? getNormalizedTextOffset(trim2, container, offset) : offset);
          } else {
            childNodes = container.childNodes;
            if (offset >= childNodes.length && childNodes.length) {
              after2 = 1;
              offset = Math.max(0, childNodes.length - 1);
            }
            point.push(dom2.nodeIndex(childNodes[offset], normalized) + after2);
          }
          for (; container && container !== root; container = container.parentNode) {
            point.push(dom2.nodeIndex(container, normalized));
          }
          return point;
        };
        var getLocation = function(trim2, selection, normalized, rng) {
          var dom2 = selection.dom, bookmark = {};
          bookmark.start = getPoint(dom2, trim2, normalized, rng, true);
          if (!selection.isCollapsed()) {
            bookmark.end = getPoint(dom2, trim2, normalized, rng, false);
          }
          return bookmark;
        };
        var findIndex$2 = function(dom2, name2, element) {
          var count2 = 0;
          Tools.each(dom2.select(name2), function(node2) {
            if (node2.getAttribute("data-mce-bogus") === "all") {
              return;
            }
            if (node2 === element) {
              return false;
            }
            count2++;
          });
          return count2;
        };
        var moveEndPoint = function(rng, start2) {
          var container, offset, childNodes;
          var prefix = start2 ? "start" : "end";
          container = rng[prefix + "Container"];
          offset = rng[prefix + "Offset"];
          if (NodeType.isElement(container) && container.nodeName === "TR") {
            childNodes = container.childNodes;
            container = childNodes[Math.min(start2 ? offset : offset - 1, childNodes.length - 1)];
            if (container) {
              offset = start2 ? 0 : container.childNodes.length;
              rng["set" + (start2 ? "Start" : "End")](container, offset);
            }
          }
        };
        var normalizeTableCellSelection = function(rng) {
          moveEndPoint(rng, true);
          moveEndPoint(rng, false);
          return rng;
        };
        var findSibling = function(node2, offset) {
          var sibling2;
          if (NodeType.isElement(node2)) {
            node2 = getNode(node2, offset);
            if (isContentEditableFalse$2(node2)) {
              return node2;
            }
          }
          if (isCaretContainer(node2)) {
            if (NodeType.isText(node2) && isCaretContainerBlock(node2)) {
              node2 = node2.parentNode;
            }
            sibling2 = node2.previousSibling;
            if (isContentEditableFalse$2(sibling2)) {
              return sibling2;
            }
            sibling2 = node2.nextSibling;
            if (isContentEditableFalse$2(sibling2)) {
              return sibling2;
            }
          }
        };
        var findAdjacentContentEditableFalseElm = function(rng) {
          return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
        };
        var getOffsetBookmark = function(trim2, normalized, selection) {
          var element = selection.getNode();
          var name2 = element ? element.nodeName : null;
          var rng = selection.getRng();
          if (isContentEditableFalse$2(element) || name2 === "IMG") {
            return {
              name: name2,
              index: findIndex$2(selection.dom, name2, element)
            };
          }
          var sibling2 = findAdjacentContentEditableFalseElm(rng);
          if (sibling2) {
            name2 = sibling2.tagName;
            return {
              name: name2,
              index: findIndex$2(selection.dom, name2, sibling2)
            };
          }
          return getLocation(trim2, selection, normalized, rng);
        };
        var getCaretBookmark = function(selection) {
          var rng = selection.getRng();
          return {
            start: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeStart(rng)),
            end: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeEnd(rng))
          };
        };
        var getRangeBookmark = function(selection) {
          return { rng: selection.getRng() };
        };
        var createBookmarkSpan = function(dom2, id, filled) {
          var args = {
            "data-mce-type": "bookmark",
            "id": id,
            "style": "overflow:hidden;line-height:0px"
          };
          return filled ? dom2.create("span", args, "&#xFEFF;") : dom2.create("span", args);
        };
        var getPersistentBookmark = function(selection, filled) {
          var dom2 = selection.dom;
          var rng = selection.getRng();
          var id = dom2.uniqueId();
          var collapsed = selection.isCollapsed();
          var element = selection.getNode();
          var name2 = element.nodeName;
          if (name2 === "IMG") {
            return {
              name: name2,
              index: findIndex$2(dom2, name2, element)
            };
          }
          var rng2 = normalizeTableCellSelection(rng.cloneRange());
          if (!collapsed) {
            rng2.collapse(false);
            var endBookmarkNode = createBookmarkSpan(dom2, id + "_end", filled);
            rangeInsertNode(dom2, rng2, endBookmarkNode);
          }
          rng = normalizeTableCellSelection(rng);
          rng.collapse(true);
          var startBookmarkNode = createBookmarkSpan(dom2, id + "_start", filled);
          rangeInsertNode(dom2, rng, startBookmarkNode);
          selection.moveToBookmark({
            id,
            keep: 1
          });
          return { id };
        };
        var getBookmark = function(selection, type2, normalized) {
          if (type2 === 2) {
            return getOffsetBookmark(Zwsp.trim, normalized, selection);
          } else if (type2 === 3) {
            return getCaretBookmark(selection);
          } else if (type2) {
            return getRangeBookmark(selection);
          } else {
            return getPersistentBookmark(selection, false);
          }
        };
        var GetBookmark = {
          getBookmark,
          getUndoBookmark: curry(getOffsetBookmark, identity, true),
          getPersistentBookmark
        };
        var CARET_ID = "_mce_caret";
        var isCaretNode = function(node2) {
          return NodeType.isElement(node2) && node2.id === CARET_ID;
        };
        var getParentCaretContainer = function(body, node2) {
          while (node2 && node2 !== body) {
            if (node2.id === CARET_ID) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var isElement$4 = NodeType.isElement;
        var isText$6 = NodeType.isText;
        var removeNode = function(node2) {
          var parentNode = node2.parentNode;
          if (parentNode) {
            parentNode.removeChild(node2);
          }
        };
        var getNodeValue = function(node2) {
          try {
            return node2.nodeValue;
          } catch (ex) {
            return "";
          }
        };
        var setNodeValue = function(node2, text) {
          if (text.length === 0) {
            removeNode(node2);
          } else {
            node2.nodeValue = text;
          }
        };
        var trimCount = function(text) {
          var trimmedText = Zwsp.trim(text);
          return {
            count: text.length - trimmedText.length,
            text: trimmedText
          };
        };
        var removeUnchanged = function(caretContainer, pos) {
          remove$5(caretContainer);
          return pos;
        };
        var removeTextAndReposition = function(caretContainer, pos) {
          var before2 = trimCount(caretContainer.data.substr(0, pos.offset()));
          var after2 = trimCount(caretContainer.data.substr(pos.offset()));
          var text = before2.text + after2.text;
          if (text.length > 0) {
            setNodeValue(caretContainer, text);
            return CaretPosition$1(caretContainer, pos.offset() - before2.count);
          } else {
            return pos;
          }
        };
        var removeElementAndReposition = function(caretContainer, pos) {
          var parentNode = pos.container();
          var newPosition = indexOf(from$1(parentNode.childNodes), caretContainer).map(function(index) {
            return index < pos.offset() ? CaretPosition$1(parentNode, pos.offset() - 1) : pos;
          }).getOr(pos);
          remove$5(caretContainer);
          return newPosition;
        };
        var removeTextCaretContainer = function(caretContainer, pos) {
          return isText$6(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
        };
        var removeElementCaretContainer = function(caretContainer, pos) {
          return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
        };
        var removeAndReposition = function(container, pos) {
          return CaretPosition$1.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
        };
        var remove$5 = function(caretContainerNode) {
          if (isElement$4(caretContainerNode) && isCaretContainer(caretContainerNode)) {
            if (hasContent(caretContainerNode)) {
              caretContainerNode.removeAttribute("data-mce-caret");
            } else {
              removeNode(caretContainerNode);
            }
          }
          if (isText$6(caretContainerNode)) {
            var text = Zwsp.trim(getNodeValue(caretContainerNode));
            setNodeValue(caretContainerNode, text);
          }
        };
        var CaretContainerRemove = {
          removeAndReposition,
          remove: remove$5
        };
        var browser$2 = PlatformDetection$1.detect().browser;
        var isContentEditableFalse$3 = NodeType.isContentEditableFalse;
        var isTableCell$1 = function(node2) {
          return NodeType.isElement(node2) && /^(TD|TH)$/i.test(node2.tagName);
        };
        var getAbsoluteClientRect = function(root, element, before2) {
          var clientRect = collapse(element.getBoundingClientRect(), before2);
          var docElm, scrollX, scrollY, margin, rootRect;
          if (root.tagName === "BODY") {
            docElm = root.ownerDocument.documentElement;
            scrollX = root.scrollLeft || docElm.scrollLeft;
            scrollY = root.scrollTop || docElm.scrollTop;
          } else {
            rootRect = root.getBoundingClientRect();
            scrollX = root.scrollLeft - rootRect.left;
            scrollY = root.scrollTop - rootRect.top;
          }
          clientRect.left += scrollX;
          clientRect.right += scrollX;
          clientRect.top += scrollY;
          clientRect.bottom += scrollY;
          clientRect.width = 1;
          margin = element.offsetWidth - element.clientWidth;
          if (margin > 0) {
            if (before2) {
              margin *= -1;
            }
            clientRect.left += margin;
            clientRect.right += margin;
          }
          return clientRect;
        };
        var trimInlineCaretContainers = function(root) {
          var contentEditableFalseNodes, node2, sibling2, i2, data2;
          contentEditableFalseNodes = DomQuery("*[contentEditable=false]", root);
          for (i2 = 0; i2 < contentEditableFalseNodes.length; i2++) {
            node2 = contentEditableFalseNodes[i2];
            sibling2 = node2.previousSibling;
            if (endsWithCaretContainer(sibling2)) {
              data2 = sibling2.data;
              if (data2.length === 1) {
                sibling2.parentNode.removeChild(sibling2);
              } else {
                sibling2.deleteData(data2.length - 1, 1);
              }
            }
            sibling2 = node2.nextSibling;
            if (startsWithCaretContainer(sibling2)) {
              data2 = sibling2.data;
              if (data2.length === 1) {
                sibling2.parentNode.removeChild(sibling2);
              } else {
                sibling2.deleteData(0, 1);
              }
            }
          }
        };
        var FakeCaret = function(root, isBlock2, hasFocus2) {
          var lastVisualCaret = Cell(Option.none());
          var cursorInterval, caretContainerNode;
          var show = function(before2, element) {
            var clientRect, rng;
            hide();
            if (isTableCell$1(element)) {
              return null;
            }
            if (isBlock2(element)) {
              caretContainerNode = insertBlock("p", element, before2);
              clientRect = getAbsoluteClientRect(root, element, before2);
              DomQuery(caretContainerNode).css("top", clientRect.top);
              var caret = DomQuery('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(clientRect).appendTo(root)[0];
              lastVisualCaret.set(Option.some({
                caret,
                element,
                before: before2
              }));
              lastVisualCaret.get().each(function(caretState) {
                if (before2) {
                  DomQuery(caretState.caret).addClass("mce-visual-caret-before");
                }
              });
              startBlink();
              rng = element.ownerDocument.createRange();
              rng.setStart(caretContainerNode, 0);
              rng.setEnd(caretContainerNode, 0);
            } else {
              caretContainerNode = insertInline(element, before2);
              rng = element.ownerDocument.createRange();
              if (isContentEditableFalse$3(caretContainerNode.nextSibling)) {
                rng.setStart(caretContainerNode, 0);
                rng.setEnd(caretContainerNode, 0);
              } else {
                rng.setStart(caretContainerNode, 1);
                rng.setEnd(caretContainerNode, 1);
              }
              return rng;
            }
            return rng;
          };
          var hide = function() {
            trimInlineCaretContainers(root);
            if (caretContainerNode) {
              CaretContainerRemove.remove(caretContainerNode);
              caretContainerNode = null;
            }
            lastVisualCaret.get().each(function(caretState) {
              DomQuery(caretState.caret).remove();
              lastVisualCaret.set(Option.none());
            });
            clearInterval(cursorInterval);
          };
          var startBlink = function() {
            cursorInterval = Delay.setInterval(function() {
              if (hasFocus2()) {
                DomQuery("div.mce-visual-caret", root).toggleClass("mce-visual-caret-hidden");
              } else {
                DomQuery("div.mce-visual-caret", root).addClass("mce-visual-caret-hidden");
              }
            }, 500);
          };
          var reposition2 = function() {
            lastVisualCaret.get().each(function(caretState) {
              var clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
              DomQuery(caretState.caret).css(clientRect);
            });
          };
          var destroy2 = function() {
            return Delay.clearInterval(cursorInterval);
          };
          var getCss = function() {
            return ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
          };
          return {
            show,
            hide,
            getCss,
            reposition: reposition2,
            destroy: destroy2
          };
        };
        var isFakeCaretTableBrowser = function() {
          return browser$2.isIE() || browser$2.isEdge() || browser$2.isFirefox();
        };
        var isFakeCaretTarget = function(node2) {
          return isContentEditableFalse$3(node2) || NodeType.isTable(node2) && isFakeCaretTableBrowser();
        };
        var isContentEditableFalse$4 = NodeType.isContentEditableFalse;
        var isBlockLike = NodeType.matchStyleValues("display", "block table table-cell table-caption list-item");
        var isCaretContainer$2 = isCaretContainer;
        var isCaretContainerBlock$1 = isCaretContainerBlock;
        var isElement$5 = NodeType.isElement;
        var isCaretCandidate$2 = isCaretCandidate;
        var isForwards = function(direction) {
          return direction > 0;
        };
        var isBackwards = function(direction) {
          return direction < 0;
        };
        var skipCaretContainers = function(walk2, shallow2) {
          var node2;
          while (node2 = walk2(shallow2)) {
            if (!isCaretContainerBlock$1(node2)) {
              return node2;
            }
          }
          return null;
        };
        var findNode = function(node2, direction, predicateFn, rootNode, shallow2) {
          var walker = new TreeWalker(node2, rootNode);
          if (isBackwards(direction)) {
            if (isContentEditableFalse$4(node2) || isCaretContainerBlock$1(node2)) {
              node2 = skipCaretContainers(walker.prev, true);
              if (predicateFn(node2)) {
                return node2;
              }
            }
            while (node2 = skipCaretContainers(walker.prev, shallow2)) {
              if (predicateFn(node2)) {
                return node2;
              }
            }
          }
          if (isForwards(direction)) {
            if (isContentEditableFalse$4(node2) || isCaretContainerBlock$1(node2)) {
              node2 = skipCaretContainers(walker.next, true);
              if (predicateFn(node2)) {
                return node2;
              }
            }
            while (node2 = skipCaretContainers(walker.next, shallow2)) {
              if (predicateFn(node2)) {
                return node2;
              }
            }
          }
          return null;
        };
        var getParentBlock = function(node2, rootNode) {
          while (node2 && node2 !== rootNode) {
            if (isBlockLike(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var isInSameBlock = function(caretPosition1, caretPosition2, rootNode) {
          return getParentBlock(caretPosition1.container(), rootNode) === getParentBlock(caretPosition2.container(), rootNode);
        };
        var getChildNodeAtRelativeOffset = function(relativeOffset, caretPosition) {
          var container, offset;
          if (!caretPosition) {
            return null;
          }
          container = caretPosition.container();
          offset = caretPosition.offset();
          if (!isElement$5(container)) {
            return null;
          }
          return container.childNodes[offset + relativeOffset];
        };
        var beforeAfter = function(before2, node2) {
          var range2 = node2.ownerDocument.createRange();
          if (before2) {
            range2.setStartBefore(node2);
            range2.setEndBefore(node2);
          } else {
            range2.setStartAfter(node2);
            range2.setEndAfter(node2);
          }
          return range2;
        };
        var isNodesInSameBlock = function(root, node1, node2) {
          return getParentBlock(node1, root) === getParentBlock(node2, root);
        };
        var lean = function(left, root, node2) {
          var sibling2, siblingName;
          if (left) {
            siblingName = "previousSibling";
          } else {
            siblingName = "nextSibling";
          }
          while (node2 && node2 !== root) {
            sibling2 = node2[siblingName];
            if (isCaretContainer$2(sibling2)) {
              sibling2 = sibling2[siblingName];
            }
            if (isContentEditableFalse$4(sibling2)) {
              if (isNodesInSameBlock(root, sibling2, node2)) {
                return sibling2;
              }
              break;
            }
            if (isCaretCandidate$2(sibling2)) {
              break;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var before$2 = curry(beforeAfter, true);
        var after$1 = curry(beforeAfter, false);
        var normalizeRange = function(direction, root, range2) {
          var node2, container, offset, location;
          var leanLeft = curry(lean, true, root);
          var leanRight2 = curry(lean, false, root);
          container = range2.startContainer;
          offset = range2.startOffset;
          if (isCaretContainerBlock(container)) {
            if (!isElement$5(container)) {
              container = container.parentNode;
            }
            location = container.getAttribute("data-mce-caret");
            if (location === "before") {
              node2 = container.nextSibling;
              if (isFakeCaretTarget(node2)) {
                return before$2(node2);
              }
            }
            if (location === "after") {
              node2 = container.previousSibling;
              if (isFakeCaretTarget(node2)) {
                return after$1(node2);
              }
            }
          }
          if (!range2.collapsed) {
            return range2;
          }
          if (NodeType.isText(container)) {
            if (isCaretContainer$2(container)) {
              if (direction === 1) {
                node2 = leanRight2(container);
                if (node2) {
                  return before$2(node2);
                }
                node2 = leanLeft(container);
                if (node2) {
                  return after$1(node2);
                }
              }
              if (direction === -1) {
                node2 = leanLeft(container);
                if (node2) {
                  return after$1(node2);
                }
                node2 = leanRight2(container);
                if (node2) {
                  return before$2(node2);
                }
              }
              return range2;
            }
            if (endsWithCaretContainer(container) && offset >= container.data.length - 1) {
              if (direction === 1) {
                node2 = leanRight2(container);
                if (node2) {
                  return before$2(node2);
                }
              }
              return range2;
            }
            if (startsWithCaretContainer(container) && offset <= 1) {
              if (direction === -1) {
                node2 = leanLeft(container);
                if (node2) {
                  return after$1(node2);
                }
              }
              return range2;
            }
            if (offset === container.data.length) {
              node2 = leanRight2(container);
              if (node2) {
                return before$2(node2);
              }
              return range2;
            }
            if (offset === 0) {
              node2 = leanLeft(container);
              if (node2) {
                return after$1(node2);
              }
              return range2;
            }
          }
          return range2;
        };
        var getRelativeCefElm = function(forward, caretPosition) {
          return Option.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$4);
        };
        var getNormalizedRangeEndPoint = function(direction, root, range2) {
          var normalizedRange = normalizeRange(direction, root, range2);
          if (direction === -1) {
            return CaretPosition.fromRangeStart(normalizedRange);
          }
          return CaretPosition.fromRangeEnd(normalizedRange);
        };
        var getElementFromPosition = function(pos) {
          return Option.from(pos.getNode()).map(Element.fromDom);
        };
        var getElementFromPrevPosition = function(pos) {
          return Option.from(pos.getNode(true)).map(Element.fromDom);
        };
        var getVisualCaretPosition = function(walkFn, caretPosition) {
          while (caretPosition = walkFn(caretPosition)) {
            if (caretPosition.isVisible()) {
              return caretPosition;
            }
          }
          return caretPosition;
        };
        var isMoveInsideSameBlock = function(from2, to) {
          var inSameBlock = isInSameBlock(from2, to);
          if (!inSameBlock && NodeType.isBr(from2.getNode())) {
            return true;
          }
          return inSameBlock;
        };
        var HDirection;
        (function(HDirection2) {
          HDirection2[HDirection2["Backwards"] = -1] = "Backwards";
          HDirection2[HDirection2["Forwards"] = 1] = "Forwards";
        })(HDirection || (HDirection = {}));
        var isContentEditableFalse$5 = NodeType.isContentEditableFalse;
        var isText$7 = NodeType.isText;
        var isElement$6 = NodeType.isElement;
        var isBr$4 = NodeType.isBr;
        var isCaretCandidate$3 = isCaretCandidate;
        var isAtomic$1 = isAtomic;
        var isEditableCaretCandidate$1 = isEditableCaretCandidate;
        var getParents = function(node2, root) {
          var parents2 = [];
          while (node2 && node2 !== root) {
            parents2.push(node2);
            node2 = node2.parentNode;
          }
          return parents2;
        };
        var nodeAtIndex = function(container, offset) {
          if (container.hasChildNodes() && offset < container.childNodes.length) {
            return container.childNodes[offset];
          }
          return null;
        };
        var getCaretCandidatePosition = function(direction, node2) {
          if (isForwards(direction)) {
            if (isCaretCandidate$3(node2.previousSibling) && !isText$7(node2.previousSibling)) {
              return CaretPosition$1.before(node2);
            }
            if (isText$7(node2)) {
              return CaretPosition$1(node2, 0);
            }
          }
          if (isBackwards(direction)) {
            if (isCaretCandidate$3(node2.nextSibling) && !isText$7(node2.nextSibling)) {
              return CaretPosition$1.after(node2);
            }
            if (isText$7(node2)) {
              return CaretPosition$1(node2, node2.data.length);
            }
          }
          if (isBackwards(direction)) {
            if (isBr$4(node2)) {
              return CaretPosition$1.before(node2);
            }
            return CaretPosition$1.after(node2);
          }
          return CaretPosition$1.before(node2);
        };
        var moveForwardFromBr = function(root, nextNode) {
          var nextSibling2 = nextNode.nextSibling;
          if (nextSibling2 && isCaretCandidate$3(nextSibling2)) {
            if (isText$7(nextSibling2)) {
              return CaretPosition$1(nextSibling2, 0);
            } else {
              return CaretPosition$1.before(nextSibling2);
            }
          } else {
            return findCaretPosition(HDirection.Forwards, CaretPosition$1.after(nextNode), root);
          }
        };
        var findCaretPosition = function(direction, startPos, root) {
          var node2, nextNode, innerNode;
          var rootContentEditableFalseElm, caretPosition;
          if (!isElement$6(root) || !startPos) {
            return null;
          }
          if (startPos.isEqual(CaretPosition$1.after(root)) && root.lastChild) {
            caretPosition = CaretPosition$1.after(root.lastChild);
            if (isBackwards(direction) && isCaretCandidate$3(root.lastChild) && isElement$6(root.lastChild)) {
              return isBr$4(root.lastChild) ? CaretPosition$1.before(root.lastChild) : caretPosition;
            }
          } else {
            caretPosition = startPos;
          }
          var container = caretPosition.container();
          var offset = caretPosition.offset();
          if (isText$7(container)) {
            if (isBackwards(direction) && offset > 0) {
              return CaretPosition$1(container, --offset);
            }
            if (isForwards(direction) && offset < container.length) {
              return CaretPosition$1(container, ++offset);
            }
            node2 = container;
          } else {
            if (isBackwards(direction) && offset > 0) {
              nextNode = nodeAtIndex(container, offset - 1);
              if (isCaretCandidate$3(nextNode)) {
                if (!isAtomic$1(nextNode)) {
                  innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
                  if (innerNode) {
                    if (isText$7(innerNode)) {
                      return CaretPosition$1(innerNode, innerNode.data.length);
                    }
                    return CaretPosition$1.after(innerNode);
                  }
                }
                if (isText$7(nextNode)) {
                  return CaretPosition$1(nextNode, nextNode.data.length);
                }
                return CaretPosition$1.before(nextNode);
              }
            }
            if (isForwards(direction) && offset < container.childNodes.length) {
              nextNode = nodeAtIndex(container, offset);
              if (isCaretCandidate$3(nextNode)) {
                if (isBr$4(nextNode)) {
                  return moveForwardFromBr(root, nextNode);
                }
                if (!isAtomic$1(nextNode)) {
                  innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
                  if (innerNode) {
                    if (isText$7(innerNode)) {
                      return CaretPosition$1(innerNode, 0);
                    }
                    return CaretPosition$1.before(innerNode);
                  }
                }
                if (isText$7(nextNode)) {
                  return CaretPosition$1(nextNode, 0);
                }
                return CaretPosition$1.after(nextNode);
              }
            }
            node2 = nextNode ? nextNode : caretPosition.getNode();
          }
          if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {
            node2 = findNode(node2, direction, constant(true), root, true);
            if (isEditableCaretCandidate$1(node2, root)) {
              return getCaretCandidatePosition(direction, node2);
            }
          }
          nextNode = findNode(node2, direction, isEditableCaretCandidate$1, root);
          rootContentEditableFalseElm = ArrUtils.last(filter(getParents(container, root), isContentEditableFalse$5));
          if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
            if (isForwards(direction)) {
              caretPosition = CaretPosition$1.after(rootContentEditableFalseElm);
            } else {
              caretPosition = CaretPosition$1.before(rootContentEditableFalseElm);
            }
            return caretPosition;
          }
          if (nextNode) {
            return getCaretCandidatePosition(direction, nextNode);
          }
          return null;
        };
        var CaretWalker = function(root) {
          return {
            next: function(caretPosition) {
              return findCaretPosition(HDirection.Forwards, caretPosition, root);
            },
            prev: function(caretPosition) {
              return findCaretPosition(HDirection.Backwards, caretPosition, root);
            }
          };
        };
        var walkToPositionIn = function(forward, root, start2) {
          var position = forward ? CaretPosition$1.before(start2) : CaretPosition$1.after(start2);
          return fromPosition(forward, root, position);
        };
        var afterElement = function(node2) {
          return NodeType.isBr(node2) ? CaretPosition$1.before(node2) : CaretPosition$1.after(node2);
        };
        var isBeforeOrStart = function(position) {
          if (CaretPosition$1.isTextPosition(position)) {
            return position.offset() === 0;
          } else {
            return isCaretCandidate(position.getNode());
          }
        };
        var isAfterOrEnd = function(position) {
          if (CaretPosition$1.isTextPosition(position)) {
            var container = position.container();
            return position.offset() === container.data.length;
          } else {
            return isCaretCandidate(position.getNode(true));
          }
        };
        var isBeforeAfterSameElement = function(from2, to) {
          return !CaretPosition$1.isTextPosition(from2) && !CaretPosition$1.isTextPosition(to) && from2.getNode() === to.getNode(true);
        };
        var isAtBr = function(position) {
          return !CaretPosition$1.isTextPosition(position) && NodeType.isBr(position.getNode());
        };
        var shouldSkipPosition = function(forward, from2, to) {
          if (forward) {
            return !isBeforeAfterSameElement(from2, to) && !isAtBr(from2) && isAfterOrEnd(from2) && isBeforeOrStart(to);
          } else {
            return !isBeforeAfterSameElement(to, from2) && isBeforeOrStart(from2) && isAfterOrEnd(to);
          }
        };
        var fromPosition = function(forward, root, pos) {
          var walker = CaretWalker(root);
          return Option.from(forward ? walker.next(pos) : walker.prev(pos));
        };
        var navigate = function(forward, root, from2) {
          return fromPosition(forward, root, from2).bind(function(to) {
            if (isInSameBlock(from2, to, root) && shouldSkipPosition(forward, from2, to)) {
              return fromPosition(forward, root, to);
            } else {
              return Option.some(to);
            }
          });
        };
        var navigateIgnore = function(forward, root, from2, ignoreFilter) {
          return navigate(forward, root, from2).bind(function(pos) {
            return ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Option.some(pos);
          });
        };
        var positionIn = function(forward, element) {
          var startNode = forward ? element.firstChild : element.lastChild;
          if (NodeType.isText(startNode)) {
            return Option.some(CaretPosition$1(startNode, forward ? 0 : startNode.data.length));
          } else if (startNode) {
            if (isCaretCandidate(startNode)) {
              return Option.some(forward ? CaretPosition$1.before(startNode) : afterElement(startNode));
            } else {
              return walkToPositionIn(forward, element, startNode);
            }
          } else {
            return Option.none();
          }
        };
        var nextPosition = curry(fromPosition, true);
        var prevPosition = curry(fromPosition, false);
        var CaretFinder = {
          fromPosition,
          nextPosition,
          prevPosition,
          navigate,
          navigateIgnore,
          positionIn,
          firstPositionIn: curry(positionIn, true),
          lastPositionIn: curry(positionIn, false)
        };
        var isStringPathBookmark = function(bookmark) {
          return typeof bookmark.start === "string";
        };
        var isRangeBookmark = function(bookmark) {
          return bookmark.hasOwnProperty("rng");
        };
        var isIdBookmark = function(bookmark) {
          return bookmark.hasOwnProperty("id");
        };
        var isIndexBookmark = function(bookmark) {
          return bookmark.hasOwnProperty("name");
        };
        var isPathBookmark = function(bookmark) {
          return Tools.isArray(bookmark.start);
        };
        var addBogus = function(dom2, node2) {
          if (NodeType.isElement(node2) && dom2.isBlock(node2) && !node2.innerHTML && !Env.ie) {
            node2.innerHTML = '<br data-mce-bogus="1" />';
          }
          return node2;
        };
        var resolveCaretPositionBookmark = function(dom2, bookmark) {
          var rng, pos;
          rng = dom2.createRng();
          pos = resolve$2(dom2.getRoot(), bookmark.start);
          rng.setStart(pos.container(), pos.offset());
          pos = resolve$2(dom2.getRoot(), bookmark.end);
          rng.setEnd(pos.container(), pos.offset());
          return rng;
        };
        var insertZwsp = function(node2, rng) {
          var textNode = node2.ownerDocument.createTextNode(Zwsp.ZWSP);
          node2.appendChild(textNode);
          rng.setStart(textNode, 0);
          rng.setEnd(textNode, 0);
        };
        var isEmpty = function(node2) {
          return node2.hasChildNodes() === false;
        };
        var tryFindRangePosition = function(node2, rng) {
          return CaretFinder.lastPositionIn(node2).fold(function() {
            return false;
          }, function(pos) {
            rng.setStart(pos.container(), pos.offset());
            rng.setEnd(pos.container(), pos.offset());
            return true;
          });
        };
        var padEmptyCaretContainer = function(root, node2, rng) {
          if (isEmpty(node2) && getParentCaretContainer(root, node2)) {
            insertZwsp(node2, rng);
            return true;
          } else {
            return false;
          }
        };
        var setEndPoint = function(dom2, start2, bookmark, rng) {
          var point = bookmark[start2 ? "start" : "end"];
          var i2, node2, offset, children2;
          var root = dom2.getRoot();
          if (point) {
            offset = point[0];
            for (node2 = root, i2 = point.length - 1; i2 >= 1; i2--) {
              children2 = node2.childNodes;
              if (padEmptyCaretContainer(root, node2, rng)) {
                return true;
              }
              if (point[i2] > children2.length - 1) {
                if (padEmptyCaretContainer(root, node2, rng)) {
                  return true;
                }
                return tryFindRangePosition(node2, rng);
              }
              node2 = children2[point[i2]];
            }
            if (node2.nodeType === 3) {
              offset = Math.min(point[0], node2.nodeValue.length);
            }
            if (node2.nodeType === 1) {
              offset = Math.min(point[0], node2.childNodes.length);
            }
            if (start2) {
              rng.setStart(node2, offset);
            } else {
              rng.setEnd(node2, offset);
            }
          }
          return true;
        };
        var isValidTextNode = function(node2) {
          return NodeType.isText(node2) && node2.data.length > 0;
        };
        var restoreEndPoint = function(dom2, suffix, bookmark) {
          var marker = dom2.get(bookmark.id + "_" + suffix), node2, idx, next, prev;
          var keep = bookmark.keep;
          var container, offset;
          if (marker) {
            node2 = marker.parentNode;
            if (suffix === "start") {
              if (!keep) {
                idx = dom2.nodeIndex(marker);
              } else {
                if (marker.hasChildNodes()) {
                  node2 = marker.firstChild;
                  idx = 1;
                } else if (isValidTextNode(marker.nextSibling)) {
                  node2 = marker.nextSibling;
                  idx = 0;
                } else if (isValidTextNode(marker.previousSibling)) {
                  node2 = marker.previousSibling;
                  idx = marker.previousSibling.data.length;
                } else {
                  node2 = marker.parentNode;
                  idx = dom2.nodeIndex(marker) + 1;
                }
              }
              container = node2;
              offset = idx;
            } else {
              if (!keep) {
                idx = dom2.nodeIndex(marker);
              } else {
                if (marker.hasChildNodes()) {
                  node2 = marker.firstChild;
                  idx = 1;
                } else if (isValidTextNode(marker.previousSibling)) {
                  node2 = marker.previousSibling;
                  idx = marker.previousSibling.data.length;
                } else {
                  node2 = marker.parentNode;
                  idx = dom2.nodeIndex(marker);
                }
              }
              container = node2;
              offset = idx;
            }
            if (!keep) {
              prev = marker.previousSibling;
              next = marker.nextSibling;
              Tools.each(Tools.grep(marker.childNodes), function(node3) {
                if (NodeType.isText(node3)) {
                  node3.nodeValue = node3.nodeValue.replace(/\uFEFF/g, "");
                }
              });
              while (marker = dom2.get(bookmark.id + "_" + suffix)) {
                dom2.remove(marker, true);
              }
              if (prev && next && prev.nodeType === next.nodeType && NodeType.isText(prev) && !Env.opera) {
                idx = prev.nodeValue.length;
                prev.appendData(next.nodeValue);
                dom2.remove(next);
                if (suffix === "start") {
                  container = prev;
                  offset = idx;
                } else {
                  container = prev;
                  offset = idx;
                }
              }
            }
            return Option.some(CaretPosition$1(container, offset));
          } else {
            return Option.none();
          }
        };
        var alt = function(o1, o2) {
          return o1.isSome() ? o1 : o2;
        };
        var resolvePaths = function(dom2, bookmark) {
          var rng = dom2.createRng();
          if (setEndPoint(dom2, true, bookmark, rng) && setEndPoint(dom2, false, bookmark, rng)) {
            return Option.some(rng);
          } else {
            return Option.none();
          }
        };
        var resolveId = function(dom2, bookmark) {
          var startPos = restoreEndPoint(dom2, "start", bookmark);
          var endPos = restoreEndPoint(dom2, "end", bookmark);
          return lift2(startPos, alt(endPos, startPos), function(spos, epos) {
            var rng = dom2.createRng();
            rng.setStart(addBogus(dom2, spos.container()), spos.offset());
            rng.setEnd(addBogus(dom2, epos.container()), epos.offset());
            return rng;
          });
        };
        var resolveIndex$1 = function(dom2, bookmark) {
          return Option.from(dom2.select(bookmark.name)[bookmark.index]).map(function(elm) {
            var rng = dom2.createRng();
            rng.selectNode(elm);
            return rng;
          });
        };
        var resolve$3 = function(selection, bookmark) {
          var dom2 = selection.dom;
          if (bookmark) {
            if (isPathBookmark(bookmark)) {
              return resolvePaths(dom2, bookmark);
            } else if (isStringPathBookmark(bookmark)) {
              return Option.some(resolveCaretPositionBookmark(dom2, bookmark));
            } else if (isIdBookmark(bookmark)) {
              return resolveId(dom2, bookmark);
            } else if (isIndexBookmark(bookmark)) {
              return resolveIndex$1(dom2, bookmark);
            } else if (isRangeBookmark(bookmark)) {
              return Option.some(bookmark.rng);
            }
          }
          return Option.none();
        };
        var ResolveBookmark = { resolve: resolve$3 };
        var getBookmark$1 = function(selection, type2, normalized) {
          return GetBookmark.getBookmark(selection, type2, normalized);
        };
        var moveToBookmark = function(selection, bookmark) {
          ResolveBookmark.resolve(selection, bookmark).each(function(rng) {
            selection.setRng(rng);
          });
        };
        var isBookmarkNode$1 = function(node2) {
          return NodeType.isElement(node2) && node2.tagName === "SPAN" && node2.getAttribute("data-mce-type") === "bookmark";
        };
        var Bookmarks = {
          getBookmark: getBookmark$1,
          moveToBookmark,
          isBookmarkNode: isBookmarkNode$1
        };
        var isInlineBlock = function(node2) {
          return node2 && /^(IMG)$/.test(node2.nodeName);
        };
        var moveStart = function(dom2, selection, rng) {
          var offset = rng.startOffset;
          var container = rng.startContainer, walker, node2, nodes;
          if (rng.startContainer === rng.endContainer) {
            if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
              return;
            }
          }
          if (container.nodeType === 1) {
            nodes = container.childNodes;
            if (offset < nodes.length) {
              container = nodes[offset];
              walker = new TreeWalker(container, dom2.getParent(container, dom2.isBlock));
            } else {
              container = nodes[nodes.length - 1];
              walker = new TreeWalker(container, dom2.getParent(container, dom2.isBlock));
              walker.next(true);
            }
            for (node2 = walker.current(); node2; node2 = walker.next()) {
              if (node2.nodeType === 3 && !isWhiteSpaceNode(node2)) {
                rng.setStart(node2, 0);
                selection.setRng(rng);
                return;
              }
            }
          }
        };
        var getNonWhiteSpaceSibling = function(node2, next, inc) {
          if (node2) {
            next = next ? "nextSibling" : "previousSibling";
            for (node2 = inc ? node2 : node2[next]; node2; node2 = node2[next]) {
              if (node2.nodeType === 1 || !isWhiteSpaceNode(node2)) {
                return node2;
              }
            }
          }
        };
        var isTextBlock$1 = function(editor, name2) {
          if (name2.nodeType) {
            name2 = name2.nodeName;
          }
          return !!editor.schema.getTextBlockElements()[name2.toLowerCase()];
        };
        var isValid = function(ed, parent2, child2) {
          return ed.schema.isValidChild(parent2, child2);
        };
        var isWhiteSpaceNode = function(node2) {
          return node2 && node2.nodeType === 3 && /^([\t \r\n]+|)$/.test(node2.nodeValue);
        };
        var replaceVars = function(value2, vars) {
          if (typeof value2 !== "string") {
            value2 = value2(vars);
          } else if (vars) {
            value2 = value2.replace(/%(\w+)/g, function(str, name2) {
              return vars[name2] || str;
            });
          }
          return value2;
        };
        var isEq = function(str1, str2) {
          str1 = str1 || "";
          str2 = str2 || "";
          str1 = "" + (str1.nodeName || str1);
          str2 = "" + (str2.nodeName || str2);
          return str1.toLowerCase() === str2.toLowerCase();
        };
        var normalizeStyleValue = function(dom2, value2, name2) {
          if (name2 === "color" || name2 === "backgroundColor") {
            value2 = dom2.toHex(value2);
          }
          if (name2 === "fontWeight" && value2 === 700) {
            value2 = "bold";
          }
          if (name2 === "fontFamily") {
            value2 = value2.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
          }
          return "" + value2;
        };
        var getStyle = function(dom2, node2, name2) {
          return normalizeStyleValue(dom2, dom2.getStyle(node2, name2), name2);
        };
        var getTextDecoration = function(dom2, node2) {
          var decoration;
          dom2.getParent(node2, function(n) {
            decoration = dom2.getStyle(n, "text-decoration");
            return decoration && decoration !== "none";
          });
          return decoration;
        };
        var getParents$1 = function(dom2, node2, selector) {
          return dom2.getParents(node2, selector, dom2.getRoot());
        };
        var FormatUtils = {
          isInlineBlock,
          moveStart,
          getNonWhiteSpaceSibling,
          isTextBlock: isTextBlock$1,
          isValid,
          isWhiteSpaceNode,
          replaceVars,
          isEq,
          normalizeStyleValue,
          getStyle,
          getTextDecoration,
          getParents: getParents$1
        };
        var isBookmarkNode$2 = Bookmarks.isBookmarkNode;
        var getParents$2 = FormatUtils.getParents, isWhiteSpaceNode$1 = FormatUtils.isWhiteSpaceNode, isTextBlock$2 = FormatUtils.isTextBlock;
        var findLeaf = function(node2, offset) {
          if (typeof offset === "undefined") {
            offset = node2.nodeType === 3 ? node2.length : node2.childNodes.length;
          }
          while (node2 && node2.hasChildNodes()) {
            node2 = node2.childNodes[offset];
            if (node2) {
              offset = node2.nodeType === 3 ? node2.length : node2.childNodes.length;
            }
          }
          return {
            node: node2,
            offset
          };
        };
        var excludeTrailingWhitespace = function(endContainer, endOffset) {
          var leaf = findLeaf(endContainer, endOffset);
          if (leaf.node) {
            while (leaf.node && leaf.offset === 0 && leaf.node.previousSibling) {
              leaf = findLeaf(leaf.node.previousSibling);
            }
            if (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 && leaf.node.nodeValue.charAt(leaf.offset - 1) === " ") {
              if (leaf.offset > 1) {
                endContainer = leaf.node;
                endContainer.splitText(leaf.offset - 1);
              }
            }
          }
          return endContainer;
        };
        var isBogusBr = function(node2) {
          return node2.nodeName === "BR" && node2.getAttribute("data-mce-bogus") && !node2.nextSibling;
        };
        var findParentContentEditable = function(dom2, node2) {
          var parent2 = node2;
          while (parent2) {
            if (parent2.nodeType === 1 && dom2.getContentEditable(parent2)) {
              return dom2.getContentEditable(parent2) === "false" ? parent2 : node2;
            }
            parent2 = parent2.parentNode;
          }
          return node2;
        };
        var findSpace = function(start2, remove2, node2, offset) {
          var pos, pos2;
          var str = node2.nodeValue;
          if (typeof offset === "undefined") {
            offset = start2 ? str.length : 0;
          }
          if (start2) {
            pos = str.lastIndexOf(" ", offset);
            pos2 = str.lastIndexOf("\xA0", offset);
            pos = pos > pos2 ? pos : pos2;
            if (pos !== -1 && !remove2 && (pos < offset || !start2) && pos <= str.length) {
              pos++;
            }
          } else {
            pos = str.indexOf(" ", offset);
            pos2 = str.indexOf("\xA0", offset);
            pos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;
          }
          return pos;
        };
        var findWordEndPoint = function(dom2, body, container, offset, start2, remove2) {
          var walker, node2, pos, lastTextNode;
          if (container.nodeType === 3) {
            pos = findSpace(start2, remove2, container, offset);
            if (pos !== -1) {
              return {
                container,
                offset: pos
              };
            }
            lastTextNode = container;
          }
          walker = new TreeWalker(container, dom2.getParent(container, dom2.isBlock) || body);
          while (node2 = walker[start2 ? "prev" : "next"]()) {
            if (node2.nodeType === 3 && !isBookmarkNode$2(node2.parentNode)) {
              lastTextNode = node2;
              pos = findSpace(start2, remove2, node2);
              if (pos !== -1) {
                return {
                  container: node2,
                  offset: pos
                };
              }
            } else if (dom2.isBlock(node2) || FormatUtils.isEq(node2, "BR")) {
              break;
            }
          }
          if (lastTextNode) {
            if (start2) {
              offset = 0;
            } else {
              offset = lastTextNode.length;
            }
            return {
              container: lastTextNode,
              offset
            };
          }
        };
        var findSelectorEndPoint = function(dom2, format, rng, container, siblingName) {
          var parents2, i2, y, curFormat;
          if (container.nodeType === 3 && container.nodeValue.length === 0 && container[siblingName]) {
            container = container[siblingName];
          }
          parents2 = getParents$2(dom2, container);
          for (i2 = 0; i2 < parents2.length; i2++) {
            for (y = 0; y < format.length; y++) {
              curFormat = format[y];
              if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {
                continue;
              }
              if (dom2.is(parents2[i2], curFormat.selector)) {
                return parents2[i2];
              }
            }
          }
          return container;
        };
        var findBlockEndPoint = function(editor, format, container, siblingName) {
          var node2;
          var dom2 = editor.dom;
          var root = dom2.getRoot();
          if (!format[0].wrapper) {
            node2 = dom2.getParent(container, format[0].block, root);
          }
          if (!node2) {
            var scopeRoot = dom2.getParent(container, "LI,TD,TH");
            node2 = dom2.getParent(container.nodeType === 3 ? container.parentNode : container, function(node3) {
              return node3 !== root && isTextBlock$2(editor, node3);
            }, scopeRoot);
          }
          if (node2 && format[0].wrapper) {
            node2 = getParents$2(dom2, node2, "ul,ol").reverse()[0] || node2;
          }
          if (!node2) {
            node2 = container;
            while (node2[siblingName] && !dom2.isBlock(node2[siblingName])) {
              node2 = node2[siblingName];
              if (FormatUtils.isEq(node2, "br")) {
                break;
              }
            }
          }
          return node2 || container;
        };
        var findParentContainer = function(dom2, format, startContainer, startOffset, endContainer, endOffset, start2) {
          var container, parent2, sibling2, siblingName, root;
          container = parent2 = start2 ? startContainer : endContainer;
          siblingName = start2 ? "previousSibling" : "nextSibling";
          root = dom2.getRoot();
          if (container.nodeType === 3 && !isWhiteSpaceNode$1(container)) {
            if (start2 ? startOffset > 0 : endOffset < container.nodeValue.length) {
              return container;
            }
          }
          while (true) {
            if (!format[0].block_expand && dom2.isBlock(parent2)) {
              return parent2;
            }
            for (sibling2 = parent2[siblingName]; sibling2; sibling2 = sibling2[siblingName]) {
              if (!isBookmarkNode$2(sibling2) && !isWhiteSpaceNode$1(sibling2) && !isBogusBr(sibling2)) {
                return parent2;
              }
            }
            if (parent2 === root || parent2.parentNode === root) {
              container = parent2;
              break;
            }
            parent2 = parent2.parentNode;
          }
          return container;
        };
        var expandRng = function(editor, rng, format, remove2) {
          var endPoint, startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
          var dom2 = editor.dom;
          if (startContainer.nodeType === 1 && startContainer.hasChildNodes()) {
            startContainer = getNode(startContainer, startOffset);
            if (startContainer.nodeType === 3) {
              startOffset = 0;
            }
          }
          if (endContainer.nodeType === 1 && endContainer.hasChildNodes()) {
            endContainer = getNode(endContainer, rng.collapsed ? endOffset : endOffset - 1);
            if (endContainer.nodeType === 3) {
              endOffset = endContainer.nodeValue.length;
            }
          }
          startContainer = findParentContentEditable(dom2, startContainer);
          endContainer = findParentContentEditable(dom2, endContainer);
          if (isBookmarkNode$2(startContainer.parentNode) || isBookmarkNode$2(startContainer)) {
            startContainer = isBookmarkNode$2(startContainer) ? startContainer : startContainer.parentNode;
            if (rng.collapsed) {
              startContainer = startContainer.previousSibling || startContainer;
            } else {
              startContainer = startContainer.nextSibling || startContainer;
            }
            if (startContainer.nodeType === 3) {
              startOffset = rng.collapsed ? startContainer.length : 0;
            }
          }
          if (isBookmarkNode$2(endContainer.parentNode) || isBookmarkNode$2(endContainer)) {
            endContainer = isBookmarkNode$2(endContainer) ? endContainer : endContainer.parentNode;
            if (rng.collapsed) {
              endContainer = endContainer.nextSibling || endContainer;
            } else {
              endContainer = endContainer.previousSibling || endContainer;
            }
            if (endContainer.nodeType === 3) {
              endOffset = rng.collapsed ? 0 : endContainer.length;
            }
          }
          if (rng.collapsed) {
            endPoint = findWordEndPoint(dom2, editor.getBody(), startContainer, startOffset, true, remove2);
            if (endPoint) {
              startContainer = endPoint.container;
              startOffset = endPoint.offset;
            }
            endPoint = findWordEndPoint(dom2, editor.getBody(), endContainer, endOffset, false, remove2);
            if (endPoint) {
              endContainer = endPoint.container;
              endOffset = endPoint.offset;
            }
          }
          if (format[0].inline) {
            endContainer = remove2 ? endContainer : excludeTrailingWhitespace(endContainer, endOffset);
          }
          if (format[0].inline || format[0].block_expand) {
            if (!format[0].inline || (startContainer.nodeType !== 3 || startOffset === 0)) {
              startContainer = findParentContainer(dom2, format, startContainer, startOffset, endContainer, endOffset, true);
            }
            if (!format[0].inline || (endContainer.nodeType !== 3 || endOffset === endContainer.nodeValue.length)) {
              endContainer = findParentContainer(dom2, format, startContainer, startOffset, endContainer, endOffset, false);
            }
          }
          if (format[0].selector && format[0].expand !== false && !format[0].inline) {
            startContainer = findSelectorEndPoint(dom2, format, rng, startContainer, "previousSibling");
            endContainer = findSelectorEndPoint(dom2, format, rng, endContainer, "nextSibling");
          }
          if (format[0].block || format[0].selector) {
            startContainer = findBlockEndPoint(editor, format, startContainer, "previousSibling");
            endContainer = findBlockEndPoint(editor, format, endContainer, "nextSibling");
            if (format[0].block) {
              if (!dom2.isBlock(startContainer)) {
                startContainer = findParentContainer(dom2, format, startContainer, startOffset, endContainer, endOffset, true);
              }
              if (!dom2.isBlock(endContainer)) {
                endContainer = findParentContainer(dom2, format, startContainer, startOffset, endContainer, endOffset, false);
              }
            }
          }
          if (startContainer.nodeType === 1) {
            startOffset = dom2.nodeIndex(startContainer);
            startContainer = startContainer.parentNode;
          }
          if (endContainer.nodeType === 1) {
            endOffset = dom2.nodeIndex(endContainer) + 1;
            endContainer = endContainer.parentNode;
          }
          return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
          };
        };
        var ExpandRange = { expandRng };
        var each$8 = Tools.each;
        var getEndChild = function(container, index) {
          var childNodes = container.childNodes;
          index--;
          if (index > childNodes.length - 1) {
            index = childNodes.length - 1;
          } else if (index < 0) {
            index = 0;
          }
          return childNodes[index] || container;
        };
        var walk$1 = function(dom2, rng, callback) {
          var startContainer = rng.startContainer;
          var startOffset = rng.startOffset;
          var endContainer = rng.endContainer;
          var endOffset = rng.endOffset;
          var ancestor2;
          var startPoint;
          var endPoint;
          var node2;
          var parent2;
          var siblings;
          var nodes;
          nodes = dom2.select("td[data-mce-selected],th[data-mce-selected]");
          if (nodes.length > 0) {
            each$8(nodes, function(node3) {
              callback([node3]);
            });
            return;
          }
          var exclude = function(nodes2) {
            var node3;
            node3 = nodes2[0];
            if (node3.nodeType === 3 && node3 === startContainer && startOffset >= node3.nodeValue.length) {
              nodes2.splice(0, 1);
            }
            node3 = nodes2[nodes2.length - 1];
            if (endOffset === 0 && nodes2.length > 0 && node3 === endContainer && node3.nodeType === 3) {
              nodes2.splice(nodes2.length - 1, 1);
            }
            return nodes2;
          };
          var collectSiblings = function(node3, name2, endNode) {
            var siblings2 = [];
            for (; node3 && node3 !== endNode; node3 = node3[name2]) {
              siblings2.push(node3);
            }
            return siblings2;
          };
          var findEndPoint = function(node3, root) {
            do {
              if (node3.parentNode === root) {
                return node3;
              }
              node3 = node3.parentNode;
            } while (node3);
          };
          var walkBoundary = function(startNode, endNode, next) {
            var siblingName = next ? "nextSibling" : "previousSibling";
            for (node2 = startNode, parent2 = node2.parentNode; node2 && node2 !== endNode; node2 = parent2) {
              parent2 = node2.parentNode;
              siblings = collectSiblings(node2 === startNode ? node2 : node2[siblingName], siblingName);
              if (siblings.length) {
                if (!next) {
                  siblings.reverse();
                }
                callback(exclude(siblings));
              }
            }
          };
          if (startContainer.nodeType === 1 && startContainer.hasChildNodes()) {
            startContainer = startContainer.childNodes[startOffset];
          }
          if (endContainer.nodeType === 1 && endContainer.hasChildNodes()) {
            endContainer = getEndChild(endContainer, endOffset);
          }
          if (startContainer === endContainer) {
            return callback(exclude([startContainer]));
          }
          ancestor2 = dom2.findCommonAncestor(startContainer, endContainer);
          for (node2 = startContainer; node2; node2 = node2.parentNode) {
            if (node2 === endContainer) {
              return walkBoundary(startContainer, ancestor2, true);
            }
            if (node2 === ancestor2) {
              break;
            }
          }
          for (node2 = endContainer; node2; node2 = node2.parentNode) {
            if (node2 === startContainer) {
              return walkBoundary(endContainer, ancestor2);
            }
            if (node2 === ancestor2) {
              break;
            }
          }
          startPoint = findEndPoint(startContainer, ancestor2) || startContainer;
          endPoint = findEndPoint(endContainer, ancestor2) || endContainer;
          walkBoundary(startContainer, startPoint, true);
          siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint === endContainer ? endPoint.nextSibling : endPoint);
          if (siblings.length) {
            callback(exclude(siblings));
          }
          walkBoundary(endContainer, endPoint);
        };
        var RangeWalk = { walk: walk$1 };
        var zeroWidth = function() {
          return "\uFEFF";
        };
        function NodeValue(is2, name2) {
          var get2 = function(element) {
            if (!is2(element)) {
              throw new Error("Can only get " + name2 + " value of a " + name2 + " node");
            }
            return getOption(element).getOr("");
          };
          var getOption = function(element) {
            return is2(element) ? Option.from(element.dom().nodeValue) : Option.none();
          };
          var set2 = function(element, value2) {
            if (!is2(element)) {
              throw new Error("Can only set raw " + name2 + " value of a " + name2 + " node");
            }
            element.dom().nodeValue = value2;
          };
          return {
            get: get2,
            getOption,
            set: set2
          };
        }
        var api = NodeValue(isText, "text");
        var get$4 = function(element) {
          return api.get(element);
        };
        var isZeroWidth = function(elem) {
          return isText(elem) && get$4(elem) === zeroWidth();
        };
        var context = function(editor, elem, wrapName, nodeName) {
          return parent(elem).fold(function() {
            return "skipping";
          }, function(parent2) {
            if (nodeName === "br" || isZeroWidth(elem)) {
              return "valid";
            } else if (isAnnotation(elem)) {
              return "existing";
            } else if (isCaretNode(elem)) {
              return "caret";
            } else if (!FormatUtils.isValid(editor, wrapName, nodeName) || !FormatUtils.isValid(editor, name(parent2), wrapName)) {
              return "invalid-child";
            } else {
              return "valid";
            }
          });
        };
        var shouldApplyToTrailingSpaces = function(rng) {
          return rng.startContainer.nodeType === 3 && rng.startContainer.nodeValue.length >= rng.startOffset && rng.startContainer.nodeValue[rng.startOffset] === "\xA0";
        };
        var applyWordGrab = function(editor, rng) {
          var r = ExpandRange.expandRng(editor, rng, [{ inline: true }], shouldApplyToTrailingSpaces(rng));
          rng.setStart(r.startContainer, r.startOffset);
          rng.setEnd(r.endContainer, r.endOffset);
          editor.selection.setRng(rng);
        };
        var makeAnnotation = function(eDoc, _a, annotationName, decorate) {
          var _b = _a.uid, uid = _b === void 0 ? generate("mce-annotation") : _b, data2 = __rest(_a, ["uid"]);
          var master = Element.fromTag("span", eDoc);
          add$2(master, annotation());
          set(master, "" + dataAnnotationId(), uid);
          set(master, "" + dataAnnotation(), annotationName);
          var _c = decorate(uid, data2), _d = _c.attributes, attributes2 = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;
          setAll(master, attributes2);
          add$3(master, classes);
          return master;
        };
        var annotate = function(editor, rng, annotationName, decorate, data2) {
          var newWrappers = [];
          var master = makeAnnotation(editor.getDoc(), data2, annotationName, decorate);
          var wrapper = Cell(Option.none());
          var finishWrapper = function() {
            wrapper.set(Option.none());
          };
          var getOrOpenWrapper = function() {
            return wrapper.get().getOrThunk(function() {
              var nu2 = shallow(master);
              newWrappers.push(nu2);
              wrapper.set(Option.some(nu2));
              return nu2;
            });
          };
          var processElements = function(elems) {
            each(elems, processElement);
          };
          var processElement = function(elem) {
            var ctx = context(editor, elem, "span", name(elem));
            switch (ctx) {
              case "invalid-child": {
                finishWrapper();
                var children$1 = children(elem);
                processElements(children$1);
                finishWrapper();
                break;
              }
              case "valid": {
                var w = getOrOpenWrapper();
                wrap$1(elem, w);
                break;
              }
              case "skipping":
              case "existing":
              case "caret":
            }
          };
          var processNodes = function(nodes) {
            var elems = map(nodes, Element.fromDom);
            processElements(elems);
          };
          RangeWalk.walk(editor.dom, rng, function(nodes) {
            finishWrapper();
            processNodes(nodes);
          });
          return newWrappers;
        };
        var annotateWithBookmark = function(editor, name2, settings, data2) {
          editor.undoManager.transact(function() {
            var initialRng = editor.selection.getRng();
            if (initialRng.collapsed) {
              applyWordGrab(editor, initialRng);
            }
            if (editor.selection.getRng().collapsed) {
              var wrapper = makeAnnotation(editor.getDoc(), data2, name2, settings.decorate);
              set$1(wrapper, "\xA0");
              editor.selection.getRng().insertNode(wrapper.dom());
              editor.selection.select(wrapper.dom());
            } else {
              var bookmark = GetBookmark.getPersistentBookmark(editor.selection, false);
              var rng = editor.selection.getRng();
              annotate(editor, rng, name2, settings.decorate, data2);
              editor.selection.moveToBookmark(bookmark);
            }
          });
        };
        function Annotator(editor) {
          var registry = create$1();
          setup$1(editor, registry);
          var changes = setup(editor);
          return {
            register: function(name2, settings) {
              registry.register(name2, settings);
            },
            annotate: function(name2, data2) {
              registry.lookup(name2).each(function(settings) {
                annotateWithBookmark(editor, name2, settings, data2);
              });
            },
            annotationChanged: function(name2, callback) {
              changes.addListener(name2, callback);
            },
            remove: function(name2) {
              identify(editor, Option.some(name2)).each(function(_a) {
                var elements = _a.elements;
                each(elements, unwrap);
              });
            },
            getAll: function(name2) {
              var directory = findAll(editor, name2);
              return map$2(directory, function(elems) {
                return map(elems, function(elem) {
                  return elem.dom();
                });
              });
            }
          };
        }
        var hasOnlyOneChild = function(node2) {
          return node2.firstChild && node2.firstChild === node2.lastChild;
        };
        var isPaddingNode = function(node2) {
          return node2.name === "br" || node2.value === "\xA0";
        };
        var isPaddedEmptyBlock = function(schema, node2) {
          var blockElements = schema.getBlockElements();
          return blockElements[node2.name] && hasOnlyOneChild(node2) && isPaddingNode(node2.firstChild);
        };
        var isEmptyFragmentElement = function(schema, node2) {
          var nonEmptyElements = schema.getNonEmptyElements();
          return node2 && (node2.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node2));
        };
        var isListFragment = function(schema, fragment) {
          var firstChild2 = fragment.firstChild;
          var lastChild2 = fragment.lastChild;
          if (firstChild2 && firstChild2.name === "meta") {
            firstChild2 = firstChild2.next;
          }
          if (lastChild2 && lastChild2.attr("id") === "mce_marker") {
            lastChild2 = lastChild2.prev;
          }
          if (isEmptyFragmentElement(schema, lastChild2)) {
            lastChild2 = lastChild2.prev;
          }
          if (!firstChild2 || firstChild2 !== lastChild2) {
            return false;
          }
          return firstChild2.name === "ul" || firstChild2.name === "ol";
        };
        var cleanupDomFragment = function(domFragment) {
          var firstChild2 = domFragment.firstChild;
          var lastChild2 = domFragment.lastChild;
          if (firstChild2 && firstChild2.nodeName === "META") {
            firstChild2.parentNode.removeChild(firstChild2);
          }
          if (lastChild2 && lastChild2.id === "mce_marker") {
            lastChild2.parentNode.removeChild(lastChild2);
          }
          return domFragment;
        };
        var toDomFragment = function(dom2, serializer, fragment) {
          var html = serializer.serialize(fragment);
          var domFragment = dom2.createFragment(html);
          return cleanupDomFragment(domFragment);
        };
        var listItems$1 = function(elm) {
          return Tools.grep(elm.childNodes, function(child2) {
            return child2.nodeName === "LI";
          });
        };
        var isPadding = function(node2) {
          return node2.data === "\xA0" || NodeType.isBr(node2);
        };
        var isListItemPadded = function(node2) {
          return node2 && node2.firstChild && node2.firstChild === node2.lastChild && isPadding(node2.firstChild);
        };
        var isEmptyOrPadded = function(elm) {
          return !elm.firstChild || isListItemPadded(elm);
        };
        var trimListItems = function(elms) {
          return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
        };
        var getParentLi = function(dom2, node2) {
          var parentBlock = dom2.getParent(node2, dom2.isBlock);
          return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
        };
        var isParentBlockLi = function(dom2, node2) {
          return !!getParentLi(dom2, node2);
        };
        var getSplit = function(parentNode, rng) {
          var beforeRng = rng.cloneRange();
          var afterRng = rng.cloneRange();
          beforeRng.setStartBefore(parentNode);
          afterRng.setEndAfter(parentNode);
          return [
            beforeRng.cloneContents(),
            afterRng.cloneContents()
          ];
        };
        var findFirstIn = function(node2, rootNode) {
          var caretPos = CaretPosition$1.before(node2);
          var caretWalker = CaretWalker(rootNode);
          var newCaretPos = caretWalker.next(caretPos);
          return newCaretPos ? newCaretPos.toRange() : null;
        };
        var findLastOf = function(node2, rootNode) {
          var caretPos = CaretPosition$1.after(node2);
          var caretWalker = CaretWalker(rootNode);
          var newCaretPos = caretWalker.prev(caretPos);
          return newCaretPos ? newCaretPos.toRange() : null;
        };
        var insertMiddle = function(target, elms, rootNode, rng) {
          var parts = getSplit(target, rng);
          var parentElm = target.parentNode;
          parentElm.insertBefore(parts[0], target);
          Tools.each(elms, function(li) {
            parentElm.insertBefore(li, target);
          });
          parentElm.insertBefore(parts[1], target);
          parentElm.removeChild(target);
          return findLastOf(elms[elms.length - 1], rootNode);
        };
        var insertBefore = function(target, elms, rootNode) {
          var parentElm = target.parentNode;
          Tools.each(elms, function(elm) {
            parentElm.insertBefore(elm, target);
          });
          return findFirstIn(target, rootNode);
        };
        var insertAfter = function(target, elms, rootNode, dom2) {
          dom2.insertAfter(elms.reverse(), target);
          return findLastOf(elms[0], rootNode);
        };
        var insertAtCaret = function(serializer, dom2, rng, fragment) {
          var domFragment = toDomFragment(dom2, serializer, fragment);
          var liTarget = getParentLi(dom2, rng.startContainer);
          var liElms = trimListItems(listItems$1(domFragment.firstChild));
          var BEGINNING = 1, END = 2;
          var rootNode = dom2.getRoot();
          var isAt = function(location) {
            var caretPos = CaretPosition$1.fromRangeStart(rng);
            var caretWalker = CaretWalker(dom2.getRoot());
            var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
            return newPos ? getParentLi(dom2, newPos.getNode()) !== liTarget : true;
          };
          if (isAt(BEGINNING)) {
            return insertBefore(liTarget, liElms, rootNode);
          } else if (isAt(END)) {
            return insertAfter(liTarget, liElms, rootNode, dom2);
          }
          return insertMiddle(liTarget, liElms, rootNode, rng);
        };
        var InsertList = {
          isListFragment,
          insertAtCaret,
          isParentBlockLi,
          trimListItems,
          listItems: listItems$1
        };
        var each$9 = Tools.each;
        var ElementUtils = function(dom2) {
          this.compare = function(node1, node2) {
            if (node1.nodeName !== node2.nodeName) {
              return false;
            }
            var getAttribs = function(node3) {
              var attribs = {};
              each$9(dom2.getAttribs(node3), function(attr) {
                var name2 = attr.nodeName.toLowerCase();
                if (name2.indexOf("_") !== 0 && name2 !== "style" && name2.indexOf("data-") !== 0) {
                  attribs[name2] = dom2.getAttrib(node3, name2);
                }
              });
              return attribs;
            };
            var compareObjects = function(obj1, obj2) {
              var value2, name2;
              for (name2 in obj1) {
                if (obj1.hasOwnProperty(name2)) {
                  value2 = obj2[name2];
                  if (typeof value2 === "undefined") {
                    return false;
                  }
                  if (obj1[name2] !== value2) {
                    return false;
                  }
                  delete obj2[name2];
                }
              }
              for (name2 in obj2) {
                if (obj2.hasOwnProperty(name2)) {
                  return false;
                }
              }
              return true;
            };
            if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
              return false;
            }
            if (!compareObjects(dom2.parseStyle(dom2.getAttrib(node1, "style")), dom2.parseStyle(dom2.getAttrib(node2, "style")))) {
              return false;
            }
            return !Bookmarks.isBookmarkNode(node1) && !Bookmarks.isBookmarkNode(node2);
          };
        };
        var getLastChildren = function(elm) {
          var children2 = [];
          var rawNode = elm.dom();
          while (rawNode) {
            children2.push(Element.fromDom(rawNode));
            rawNode = rawNode.lastChild;
          }
          return children2;
        };
        var removeTrailingBr = function(elm) {
          var allBrs = descendants$1(elm, "br");
          var brs = filter(getLastChildren(elm).slice(-1), isBr);
          if (allBrs.length === brs.length) {
            each(brs, remove$1);
          }
        };
        var fillWithPaddingBr = function(elm) {
          empty(elm);
          append(elm, Element.fromHtml('<br data-mce-bogus="1">'));
        };
        var isPaddingContents = function(elm) {
          return isText(elm) ? get$4(elm) === "\xA0" : isBr(elm);
        };
        var isPaddedElement = function(elm) {
          return filter(children(elm), isPaddingContents).length === 1;
        };
        var trimBlockTrailingBr = function(elm) {
          lastChild(elm).each(function(lastChild2) {
            prevSibling(lastChild2).each(function(lastChildPrevSibling) {
              if (isBlock(elm) && isBr(lastChild2) && isBlock(lastChildPrevSibling)) {
                remove$1(lastChild2);
              }
            });
          });
        };
        var PaddingBr = {
          removeTrailingBr,
          fillWithPaddingBr,
          isPaddedElement,
          trimBlockTrailingBr
        };
        var makeMap$3 = Tools.makeMap;
        function Writer(settings) {
          var html = [];
          var indent, indentBefore, indentAfter, encode, htmlOutput;
          settings = settings || {};
          indent = settings.indent;
          indentBefore = makeMap$3(settings.indent_before || "");
          indentAfter = makeMap$3(settings.indent_after || "");
          encode = Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
          htmlOutput = settings.element_format === "html";
          return {
            start: function(name2, attrs, empty2) {
              var i2, l, attr, value2;
              if (indent && indentBefore[name2] && html.length > 0) {
                value2 = html[html.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html.push("\n");
                }
              }
              html.push("<", name2);
              if (attrs) {
                for (i2 = 0, l = attrs.length; i2 < l; i2++) {
                  attr = attrs[i2];
                  html.push(" ", attr.name, '="', encode(attr.value, true), '"');
                }
              }
              if (!empty2 || htmlOutput) {
                html[html.length] = ">";
              } else {
                html[html.length] = " />";
              }
              if (empty2 && indent && indentAfter[name2] && html.length > 0) {
                value2 = html[html.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html.push("\n");
                }
              }
            },
            end: function(name2) {
              var value2;
              html.push("</", name2, ">");
              if (indent && indentAfter[name2] && html.length > 0) {
                value2 = html[html.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html.push("\n");
                }
              }
            },
            text: function(text, raw) {
              if (text.length > 0) {
                html[html.length] = raw ? text : encode(text);
              }
            },
            cdata: function(text) {
              html.push("<![CDATA[", text, "]]>");
            },
            comment: function(text) {
              html.push("<!--", text, "-->");
            },
            pi: function(name2, text) {
              if (text) {
                html.push("<?", name2, " ", encode(text), "?>");
              } else {
                html.push("<?", name2, "?>");
              }
              if (indent) {
                html.push("\n");
              }
            },
            doctype: function(text) {
              html.push("<!DOCTYPE", text, ">", indent ? "\n" : "");
            },
            reset: function() {
              html.length = 0;
            },
            getContent: function() {
              return html.join("").replace(/\n$/, "");
            }
          };
        }
        function HtmlSerializer(settings, schema) {
          if (schema === void 0) {
            schema = Schema();
          }
          var writer = Writer(settings);
          settings = settings || {};
          settings.validate = "validate" in settings ? settings.validate : true;
          var serialize2 = function(node2) {
            var handlers, validate2;
            validate2 = settings.validate;
            handlers = {
              3: function(node3) {
                writer.text(node3.value, node3.raw);
              },
              8: function(node3) {
                writer.comment(node3.value);
              },
              7: function(node3) {
                writer.pi(node3.name, node3.value);
              },
              10: function(node3) {
                writer.doctype(node3.value);
              },
              4: function(node3) {
                writer.cdata(node3.value);
              },
              11: function(node3) {
                if (node3 = node3.firstChild) {
                  do {
                    walk2(node3);
                  } while (node3 = node3.next);
                }
              }
            };
            writer.reset();
            var walk2 = function(node3) {
              var handler = handlers[node3.type];
              var name2, isEmpty2, attrs, attrName, attrValue, sortedAttrs, i2, l, elementRule;
              if (!handler) {
                name2 = node3.name;
                isEmpty2 = node3.shortEnded;
                attrs = node3.attributes;
                if (validate2 && attrs && attrs.length > 1) {
                  sortedAttrs = [];
                  sortedAttrs.map = {};
                  elementRule = schema.getElementRule(node3.name);
                  if (elementRule) {
                    for (i2 = 0, l = elementRule.attributesOrder.length; i2 < l; i2++) {
                      attrName = elementRule.attributesOrder[i2];
                      if (attrName in attrs.map) {
                        attrValue = attrs.map[attrName];
                        sortedAttrs.map[attrName] = attrValue;
                        sortedAttrs.push({
                          name: attrName,
                          value: attrValue
                        });
                      }
                    }
                    for (i2 = 0, l = attrs.length; i2 < l; i2++) {
                      attrName = attrs[i2].name;
                      if (!(attrName in sortedAttrs.map)) {
                        attrValue = attrs.map[attrName];
                        sortedAttrs.map[attrName] = attrValue;
                        sortedAttrs.push({
                          name: attrName,
                          value: attrValue
                        });
                      }
                    }
                    attrs = sortedAttrs;
                  }
                }
                writer.start(node3.name, attrs, isEmpty2);
                if (!isEmpty2) {
                  if (node3 = node3.firstChild) {
                    do {
                      walk2(node3);
                    } while (node3 = node3.next);
                  }
                  writer.end(name2);
                }
              } else {
                handler(node3);
              }
            };
            if (node2.type === 1 && !settings.inner) {
              walk2(node2);
            } else {
              handlers[11](node2);
            }
            return writer.getContent();
          };
          return { serialize: serialize2 };
        }
        var createRange$1 = function(sc, so, ec, eo) {
          var rng = domGlobals.document.createRange();
          rng.setStart(sc, so);
          rng.setEnd(ec, eo);
          return rng;
        };
        var normalizeBlockSelectionRange = function(rng) {
          var startPos = CaretPosition$1.fromRangeStart(rng);
          var endPos = CaretPosition$1.fromRangeEnd(rng);
          var rootNode = rng.commonAncestorContainer;
          return CaretFinder.fromPosition(false, rootNode, endPos).map(function(newEndPos) {
            if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
              return createRange$1(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
            } else {
              return rng;
            }
          }).getOr(rng);
        };
        var normalize = function(rng) {
          return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
        };
        var RangeNormalizer = { normalize };
        var isAfterNbsp = function(container, offset) {
          return NodeType.isText(container) && container.nodeValue[offset - 1] === "\xA0";
        };
        var trimOrPadLeftRight = function(rng, html) {
          var container, offset;
          container = rng.startContainer;
          offset = rng.startOffset;
          var hasSiblingText = function(siblingName) {
            return container[siblingName] && container[siblingName].nodeType === 3;
          };
          if (container.nodeType === 3) {
            if (offset > 0) {
              html = html.replace(/^&nbsp;/, " ");
            } else if (!hasSiblingText("previousSibling")) {
              html = html.replace(/^ /, "&nbsp;");
            }
            if (offset < container.length) {
              html = html.replace(/&nbsp;(<br>|)$/, " ");
            } else if (!hasSiblingText("nextSibling")) {
              html = html.replace(/(&nbsp;| )(<br>|)$/, "&nbsp;");
            }
          }
          return html;
        };
        var trimNbspAfterDeleteAndPadValue = function(rng, value2) {
          var container, offset;
          container = rng.startContainer;
          offset = rng.startOffset;
          if (container.nodeType === 3 && rng.collapsed) {
            if (container.data[offset] === "\xA0") {
              container.deleteData(offset, 1);
              if (!/[\u00a0| ]$/.test(value2)) {
                value2 += " ";
              }
            } else if (container.data[offset - 1] === "\xA0") {
              container.deleteData(offset - 1, 1);
              if (!/[\u00a0| ]$/.test(value2)) {
                value2 = " " + value2;
              }
            }
          }
          return value2;
        };
        var isTableCell$2 = NodeType.matchNodeNames("td th");
        var selectionSetContent = function(editor, content) {
          var rng = editor.selection.getRng();
          var container = rng.startContainer;
          var offset = rng.startOffset;
          if (rng.collapsed && isAfterNbsp(container, offset) && NodeType.isText(container)) {
            container.insertData(offset - 1, " ");
            container.deleteData(offset, 1);
            rng.setStart(container, offset);
            rng.setEnd(container, offset);
            editor.selection.setRng(rng);
          }
          editor.selection.setContent(content);
        };
        var validInsertion = function(editor, value2, parentNode) {
          if (parentNode.getAttribute("data-mce-bogus") === "all") {
            parentNode.parentNode.insertBefore(editor.dom.createFragment(value2), parentNode);
          } else {
            var node2 = parentNode.firstChild;
            var node22 = parentNode.lastChild;
            if (!node2 || node2 === node22 && node2.nodeName === "BR") {
              editor.dom.setHTML(parentNode, value2);
            } else {
              selectionSetContent(editor, value2);
            }
          }
        };
        var trimBrsFromTableCell = function(dom2, elm) {
          Option.from(dom2.getParent(elm, "td,th")).map(Element.fromDom).each(PaddingBr.trimBlockTrailingBr);
        };
        var reduceInlineTextElements = function(editor, merge2) {
          var textInlineElements = editor.schema.getTextInlineElements();
          var dom2 = editor.dom;
          if (merge2) {
            var root_1 = editor.getBody(), elementUtils_1 = new ElementUtils(dom2);
            Tools.each(dom2.select("*[data-mce-fragment]"), function(node2) {
              for (var testNode = node2.parentNode; testNode && testNode !== root_1; testNode = testNode.parentNode) {
                if (textInlineElements[node2.nodeName.toLowerCase()] && elementUtils_1.compare(testNode, node2)) {
                  dom2.remove(node2, true);
                }
              }
            });
          }
        };
        var markFragmentElements = function(fragment) {
          var node2 = fragment;
          while (node2 = node2.walk()) {
            if (node2.type === 1) {
              node2.attr("data-mce-fragment", "1");
            }
          }
        };
        var umarkFragmentElements = function(elm) {
          Tools.each(elm.getElementsByTagName("*"), function(elm2) {
            elm2.removeAttribute("data-mce-fragment");
          });
        };
        var isPartOfFragment = function(node2) {
          return !!node2.getAttribute("data-mce-fragment");
        };
        var canHaveChildren = function(editor, node2) {
          return node2 && !editor.schema.getShortEndedElements()[node2.nodeName];
        };
        var moveSelectionToMarker = function(editor, marker) {
          var parentEditableFalseElm, parentBlock, nextRng;
          var dom2 = editor.dom, selection = editor.selection;
          var node2, node22;
          var getContentEditableFalseParent = function(node3) {
            var root = editor.getBody();
            for (; node3 && node3 !== root; node3 = node3.parentNode) {
              if (editor.dom.getContentEditable(node3) === "false") {
                return node3;
              }
            }
            return null;
          };
          if (!marker) {
            return;
          }
          editor.selection.scrollIntoView(marker);
          parentEditableFalseElm = getContentEditableFalseParent(marker);
          if (parentEditableFalseElm) {
            dom2.remove(marker);
            selection.select(parentEditableFalseElm);
            return;
          }
          var rng = dom2.createRng();
          node2 = marker.previousSibling;
          if (node2 && node2.nodeType === 3) {
            rng.setStart(node2, node2.nodeValue.length);
            if (!Env.ie) {
              node22 = marker.nextSibling;
              if (node22 && node22.nodeType === 3) {
                node2.appendData(node22.data);
                node22.parentNode.removeChild(node22);
              }
            }
          } else {
            rng.setStartBefore(marker);
            rng.setEndBefore(marker);
          }
          var findNextCaretRng = function(rng2) {
            var caretPos = CaretPosition$1.fromRangeStart(rng2);
            var caretWalker = CaretWalker(editor.getBody());
            caretPos = caretWalker.next(caretPos);
            if (caretPos) {
              return caretPos.toRange();
            }
          };
          parentBlock = dom2.getParent(marker, dom2.isBlock);
          dom2.remove(marker);
          if (parentBlock && dom2.isEmpty(parentBlock)) {
            editor.$(parentBlock).empty();
            rng.setStart(parentBlock, 0);
            rng.setEnd(parentBlock, 0);
            if (!isTableCell$2(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
              rng = nextRng;
              dom2.remove(parentBlock);
            } else {
              dom2.add(parentBlock, dom2.create("br", { "data-mce-bogus": "1" }));
            }
          }
          selection.setRng(rng);
        };
        var insertHtmlAtCaret = function(editor, value2, details) {
          var parser, serializer, parentNode, rootNode, fragment, args;
          var marker, rng, node2, bookmarkHtml, merge2;
          var selection = editor.selection, dom2 = editor.dom;
          if (/^ | $/.test(value2)) {
            value2 = trimOrPadLeftRight(selection.getRng(), value2);
          }
          parser = editor.parser;
          merge2 = details.merge;
          serializer = HtmlSerializer({ validate: editor.settings.validate }, editor.schema);
          bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>';
          args = {
            content: value2,
            format: "html",
            selection: true,
            paste: details.paste
          };
          args = editor.fire("BeforeSetContent", args);
          if (args.isDefaultPrevented()) {
            editor.fire("SetContent", {
              content: args.content,
              format: "html",
              selection: true,
              paste: details.paste
            });
            return;
          }
          value2 = args.content;
          if (value2.indexOf("{$caret}") === -1) {
            value2 += "{$caret}";
          }
          value2 = value2.replace(/\{\$caret\}/, bookmarkHtml);
          rng = selection.getRng();
          var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
          var body = editor.getBody();
          if (caretElement === body && selection.isCollapsed()) {
            if (dom2.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom2.isEmpty(body.firstChild)) {
              rng = dom2.createRng();
              rng.setStart(body.firstChild, 0);
              rng.setEnd(body.firstChild, 0);
              selection.setRng(rng);
            }
          }
          if (!selection.isCollapsed()) {
            editor.selection.setRng(RangeNormalizer.normalize(editor.selection.getRng()));
            editor.getDoc().execCommand("Delete", false, null);
            value2 = trimNbspAfterDeleteAndPadValue(editor.selection.getRng(), value2);
          }
          parentNode = selection.getNode();
          var parserArgs = {
            context: parentNode.nodeName.toLowerCase(),
            data: details.data,
            insert: true
          };
          fragment = parser.parse(value2, parserArgs);
          if (details.paste === true && InsertList.isListFragment(editor.schema, fragment) && InsertList.isParentBlockLi(dom2, parentNode)) {
            rng = InsertList.insertAtCaret(serializer, dom2, editor.selection.getRng(), fragment);
            editor.selection.setRng(rng);
            editor.fire("SetContent", args);
            return;
          }
          markFragmentElements(fragment);
          node2 = fragment.lastChild;
          if (node2.attr("id") === "mce_marker") {
            marker = node2;
            for (node2 = node2.prev; node2; node2 = node2.walk(true)) {
              if (node2.type === 3 || !dom2.isBlock(node2.name)) {
                if (editor.schema.isValidChild(node2.parent.name, "span")) {
                  node2.parent.insert(marker, node2, node2.name === "br");
                }
                break;
              }
            }
          }
          editor._selectionOverrides.showBlockCaretContainer(parentNode);
          if (!parserArgs.invalid) {
            value2 = serializer.serialize(fragment);
            validInsertion(editor, value2, parentNode);
          } else {
            selectionSetContent(editor, bookmarkHtml);
            parentNode = selection.getNode();
            rootNode = editor.getBody();
            if (parentNode.nodeType === 9) {
              parentNode = node2 = rootNode;
            } else {
              node2 = parentNode;
            }
            while (node2 !== rootNode) {
              parentNode = node2;
              node2 = node2.parentNode;
            }
            value2 = parentNode === rootNode ? rootNode.innerHTML : dom2.getOuterHTML(parentNode);
            value2 = serializer.serialize(parser.parse(value2.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
              return serializer.serialize(fragment);
            })));
            if (parentNode === rootNode) {
              dom2.setHTML(rootNode, value2);
            } else {
              dom2.setOuterHTML(parentNode, value2);
            }
          }
          reduceInlineTextElements(editor, merge2);
          moveSelectionToMarker(editor, dom2.get("mce_marker"));
          umarkFragmentElements(editor.getBody());
          trimBrsFromTableCell(editor.dom, editor.selection.getStart());
          editor.fire("SetContent", args);
          editor.addVisual();
        };
        var processValue = function(value2) {
          var details;
          if (typeof value2 !== "string") {
            details = Tools.extend({
              paste: value2.paste,
              data: { paste: value2.paste }
            }, value2);
            return {
              content: value2.content,
              details
            };
          }
          return {
            content: value2,
            details: {}
          };
        };
        var insertAtCaret$1 = function(editor, value2) {
          var result = processValue(value2);
          insertHtmlAtCaret(editor, result.content, result.details);
        };
        var InsertContent = { insertAtCaret: insertAtCaret$1 };
        var strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
        var hasStrongRtl = function(text) {
          return strongRtl.test(text);
        };
        var getBodySetting = function(editor, name2, defaultValue) {
          var value2 = editor.getParam(name2, defaultValue);
          if (value2.indexOf("=") !== -1) {
            var bodyObj = editor.getParam(name2, "", "hash");
            return bodyObj.hasOwnProperty(editor.id) ? bodyObj[editor.id] : defaultValue;
          } else {
            return value2;
          }
        };
        var getIframeAttrs = function(editor) {
          return editor.getParam("iframe_attrs", {});
        };
        var getDocType = function(editor) {
          return editor.getParam("doctype", "<!DOCTYPE html>");
        };
        var getDocumentBaseUrl = function(editor) {
          return editor.getParam("document_base_url", "");
        };
        var getBodyId = function(editor) {
          return getBodySetting(editor, "body_id", "tinymce");
        };
        var getBodyClass = function(editor) {
          return getBodySetting(editor, "body_class", "");
        };
        var getContentSecurityPolicy = function(editor) {
          return editor.getParam("content_security_policy", "");
        };
        var shouldPutBrInPre = function(editor) {
          return editor.getParam("br_in_pre", true);
        };
        var getForcedRootBlock = function(editor) {
          if (editor.getParam("force_p_newlines", false)) {
            return "p";
          }
          var block = editor.getParam("forced_root_block", "p");
          return block === false ? "" : block;
        };
        var getForcedRootBlockAttrs = function(editor) {
          return editor.getParam("forced_root_block_attrs", {});
        };
        var getBrNewLineSelector = function(editor) {
          return editor.getParam("br_newline_selector", ".mce-toc h2,figcaption,caption");
        };
        var getNoNewLineSelector = function(editor) {
          return editor.getParam("no_newline_selector", "");
        };
        var shouldKeepStyles = function(editor) {
          return editor.getParam("keep_styles", true);
        };
        var shouldEndContainerOnEmptyBlock = function(editor) {
          return editor.getParam("end_container_on_empty_block", false);
        };
        var getFontStyleValues = function(editor) {
          return Tools.explode(editor.getParam("font_size_style_values", ""));
        };
        var getFontSizeClasses = function(editor) {
          return Tools.explode(editor.getParam("font_size_classes", ""));
        };
        var getImagesDataImgFilter = function(editor) {
          return editor.getParam("images_dataimg_filter", constant(true), "function");
        };
        var isAutomaticUploadsEnabled = function(editor) {
          return editor.getParam("automatic_uploads", true, "boolean");
        };
        var shouldReuseFileName = function(editor) {
          return editor.getParam("images_reuse_filename", false, "boolean");
        };
        var shouldReplaceBlobUris = function(editor) {
          return editor.getParam("images_replace_blob_uris", true, "boolean");
        };
        var getImageUploadUrl = function(editor) {
          return editor.getParam("images_upload_url", "", "string");
        };
        var getImageUploadBasePath = function(editor) {
          return editor.getParam("images_upload_base_path", "", "string");
        };
        var getImagesUploadCredentials = function(editor) {
          return editor.getParam("images_upload_credentials", false, "boolean");
        };
        var getImagesUploadHandler = function(editor) {
          return editor.getParam("images_upload_handler", null, "function");
        };
        var shouldUseContentCssCors = function(editor) {
          return editor.getParam("content_css_cors", false, "boolean");
        };
        var getInlineBoundarySelector = function(editor) {
          return editor.getParam("inline_boundaries_selector", "a[href],code,.mce-annotation", "string");
        };
        var Settings = {
          getIframeAttrs,
          getDocType,
          getDocumentBaseUrl,
          getBodyId,
          getBodyClass,
          getContentSecurityPolicy,
          shouldPutBrInPre,
          getForcedRootBlock,
          getForcedRootBlockAttrs,
          getBrNewLineSelector,
          getNoNewLineSelector,
          shouldKeepStyles,
          shouldEndContainerOnEmptyBlock,
          getFontStyleValues,
          getFontSizeClasses,
          getImagesDataImgFilter,
          isAutomaticUploadsEnabled,
          shouldReuseFileName,
          shouldReplaceBlobUris,
          getImageUploadUrl,
          getImageUploadBasePath,
          getImagesUploadCredentials,
          getImagesUploadHandler,
          shouldUseContentCssCors,
          getInlineBoundarySelector
        };
        var isInlineTarget = function(editor, elm) {
          return is$1(Element.fromDom(elm), Settings.getInlineBoundarySelector(editor));
        };
        var isRtl = function(element) {
          return DOMUtils$1.DOM.getStyle(element, "direction", true) === "rtl" || hasStrongRtl(element.textContent);
        };
        var findInlineParents = function(isInlineTarget2, rootNode, pos) {
          return filter(DOMUtils$1.DOM.getParents(pos.container(), "*", rootNode), isInlineTarget2);
        };
        var findRootInline = function(isInlineTarget2, rootNode, pos) {
          var parents2 = findInlineParents(isInlineTarget2, rootNode, pos);
          return Option.from(parents2[parents2.length - 1]);
        };
        var hasSameParentBlock = function(rootNode, node1, node2) {
          var block1 = getParentBlock(node1, rootNode);
          var block2 = getParentBlock(node2, rootNode);
          return block1 && block1 === block2;
        };
        var isAtZwsp = function(pos) {
          return isBeforeInline(pos) || isAfterInline(pos);
        };
        var normalizePosition = function(forward, pos) {
          if (!pos) {
            return pos;
          }
          var container = pos.container(), offset = pos.offset();
          if (forward) {
            if (isCaretContainerInline(container)) {
              if (NodeType.isText(container.nextSibling)) {
                return CaretPosition$1(container.nextSibling, 0);
              } else {
                return CaretPosition$1.after(container);
              }
            } else {
              return isBeforeInline(pos) ? CaretPosition$1(container, offset + 1) : pos;
            }
          } else {
            if (isCaretContainerInline(container)) {
              if (NodeType.isText(container.previousSibling)) {
                return CaretPosition$1(container.previousSibling, container.previousSibling.data.length);
              } else {
                return CaretPosition$1.before(container);
              }
            } else {
              return isAfterInline(pos) ? CaretPosition$1(container, offset - 1) : pos;
            }
          }
        };
        var normalizeForwards = curry(normalizePosition, true);
        var normalizeBackwards = curry(normalizePosition, false);
        var InlineUtils = {
          isInlineTarget,
          findRootInline,
          isRtl,
          isAtZwsp,
          normalizePosition,
          normalizeForwards,
          normalizeBackwards,
          hasSameParentBlock
        };
        var isBeforeRoot = function(rootNode) {
          return function(elm) {
            return eq(rootNode, Element.fromDom(elm.dom().parentNode));
          };
        };
        var getParentBlock$1 = function(rootNode, elm) {
          return contains$3(rootNode, elm) ? closest(elm, function(element) {
            return isTextBlock(element) || isListItem(element);
          }, isBeforeRoot(rootNode)) : Option.none();
        };
        var placeCaretInEmptyBody = function(editor) {
          var body = editor.getBody();
          var node2 = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;
          editor.selection.setCursorLocation(node2, 0);
        };
        var paddEmptyBody = function(editor) {
          if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent("");
            placeCaretInEmptyBody(editor);
          }
        };
        var willDeleteLastPositionInElement = function(forward, fromPos, elm) {
          return lift2(CaretFinder.firstPositionIn(elm), CaretFinder.lastPositionIn(elm), function(firstPos, lastPos) {
            var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
            var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
            var normalizedFromPos = InlineUtils.normalizePosition(false, fromPos);
            if (forward) {
              return CaretFinder.nextPosition(elm, normalizedFromPos).map(function(nextPos) {
                return nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos);
              }).getOr(false);
            } else {
              return CaretFinder.prevPosition(elm, normalizedFromPos).map(function(prevPos) {
                return prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos);
              }).getOr(false);
            }
          }).getOr(true);
        };
        var DeleteUtils = {
          getParentBlock: getParentBlock$1,
          paddEmptyBody,
          willDeleteLastPositionInElement
        };
        var ancestor$2 = function(scope, selector, isRoot) {
          return ancestor$1(scope, selector, isRoot).isSome();
        };
        var hasWhitespacePreserveParent = function(rootNode, node2) {
          var rootElement = Element.fromDom(rootNode);
          var startNode = Element.fromDom(node2);
          return ancestor$2(startNode, "pre,code", curry(eq, rootElement));
        };
        var isWhitespace = function(rootNode, node2) {
          return NodeType.isText(node2) && /^[ \t\r\n]*$/.test(node2.data) && hasWhitespacePreserveParent(rootNode, node2) === false;
        };
        var isNamedAnchor = function(node2) {
          return NodeType.isElement(node2) && node2.nodeName === "A" && node2.hasAttribute("name");
        };
        var isContent = function(rootNode, node2) {
          return isCaretCandidate(node2) && isWhitespace(rootNode, node2) === false || isNamedAnchor(node2) || isBookmark(node2);
        };
        var isBookmark = NodeType.hasAttribute("data-mce-bookmark");
        var isBogus$2 = NodeType.hasAttribute("data-mce-bogus");
        var isBogusAll$1 = NodeType.hasAttributeValue("data-mce-bogus", "all");
        var isEmptyNode = function(targetNode) {
          var walker, node2, brCount = 0;
          if (isContent(targetNode, targetNode)) {
            return false;
          } else {
            node2 = targetNode.firstChild;
            if (!node2) {
              return true;
            }
            walker = new TreeWalker(node2, targetNode);
            do {
              if (isBogusAll$1(node2)) {
                node2 = walker.next(true);
                continue;
              }
              if (isBogus$2(node2)) {
                node2 = walker.next();
                continue;
              }
              if (NodeType.isBr(node2)) {
                brCount++;
                node2 = walker.next();
                continue;
              }
              if (isContent(targetNode, node2)) {
                return false;
              }
              node2 = walker.next();
            } while (node2);
            return brCount <= 1;
          }
        };
        var isEmpty$1 = function(elm) {
          return isEmptyNode(elm.dom());
        };
        var Empty = { isEmpty: isEmpty$1 };
        var BlockPosition = Immutable("block", "position");
        var BlockBoundary = Immutable("from", "to");
        var getBlockPosition = function(rootNode, pos) {
          var rootElm = Element.fromDom(rootNode);
          var containerElm = Element.fromDom(pos.container());
          return DeleteUtils.getParentBlock(rootElm, containerElm).map(function(block) {
            return BlockPosition(block, pos);
          });
        };
        var isDifferentBlocks = function(blockBoundary) {
          return eq(blockBoundary.from().block(), blockBoundary.to().block()) === false;
        };
        var hasSameParent = function(blockBoundary) {
          return parent(blockBoundary.from().block()).bind(function(parent1) {
            return parent(blockBoundary.to().block()).filter(function(parent2) {
              return eq(parent1, parent2);
            });
          }).isSome();
        };
        var isEditable = function(blockBoundary) {
          return NodeType.isContentEditableFalse(blockBoundary.from().block().dom()) === false && NodeType.isContentEditableFalse(blockBoundary.to().block().dom()) === false;
        };
        var skipLastBr = function(rootNode, forward, blockPosition) {
          if (NodeType.isBr(blockPosition.position().getNode()) && Empty.isEmpty(blockPosition.block()) === false) {
            return CaretFinder.positionIn(false, blockPosition.block().dom()).bind(function(lastPositionInBlock) {
              if (lastPositionInBlock.isEqual(blockPosition.position())) {
                return CaretFinder.fromPosition(forward, rootNode, lastPositionInBlock).bind(function(to) {
                  return getBlockPosition(rootNode, to);
                });
              } else {
                return Option.some(blockPosition);
              }
            }).getOr(blockPosition);
          } else {
            return blockPosition;
          }
        };
        var readFromRange = function(rootNode, forward, rng) {
          var fromBlockPos = getBlockPosition(rootNode, CaretPosition$1.fromRangeStart(rng));
          var toBlockPos = fromBlockPos.bind(function(blockPos) {
            return CaretFinder.fromPosition(forward, rootNode, blockPos.position()).bind(function(to) {
              return getBlockPosition(rootNode, to).map(function(blockPos2) {
                return skipLastBr(rootNode, forward, blockPos2);
              });
            });
          });
          return lift2(fromBlockPos, toBlockPos, BlockBoundary).filter(function(blockBoundary) {
            return isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable(blockBoundary);
          });
        };
        var read$1 = function(rootNode, forward, rng) {
          return rng.collapsed ? readFromRange(rootNode, forward, rng) : Option.none();
        };
        var BlockMergeBoundary = { read: read$1 };
        var dropLast = function(xs) {
          return xs.slice(0, -1);
        };
        var parentsUntil$1 = function(start2, root, predicate) {
          if (contains$3(root, start2)) {
            return dropLast(parents(start2, function(elm) {
              return predicate(elm) || eq(elm, root);
            }));
          } else {
            return [];
          }
        };
        var parents$1 = function(start2, root) {
          return parentsUntil$1(start2, root, constant(false));
        };
        var parentsAndSelf = function(start2, root) {
          return [start2].concat(parents$1(start2, root));
        };
        var Parents = {
          parentsUntil: parentsUntil$1,
          parents: parents$1,
          parentsAndSelf
        };
        var getChildrenUntilBlockBoundary = function(block) {
          var children$1 = children(block);
          return findIndex(children$1, isBlock).fold(function() {
            return children$1;
          }, function(index) {
            return children$1.slice(0, index);
          });
        };
        var extractChildren = function(block) {
          var children2 = getChildrenUntilBlockBoundary(block);
          each(children2, remove$1);
          return children2;
        };
        var removeEmptyRoot = function(rootNode, block) {
          var parents2 = Parents.parentsAndSelf(block, rootNode);
          return find(parents2.reverse(), Empty.isEmpty).each(remove$1);
        };
        var isEmptyBefore = function(el) {
          return filter(prevSiblings(el), function(el2) {
            return !Empty.isEmpty(el2);
          }).length === 0;
        };
        var nestedBlockMerge = function(rootNode, fromBlock, toBlock, insertionPoint) {
          if (Empty.isEmpty(toBlock)) {
            PaddingBr.fillWithPaddingBr(toBlock);
            return CaretFinder.firstPositionIn(toBlock.dom());
          }
          if (isEmptyBefore(insertionPoint) && Empty.isEmpty(fromBlock)) {
            before(insertionPoint, Element.fromTag("br"));
          }
          var position = CaretFinder.prevPosition(toBlock.dom(), CaretPosition$1.before(insertionPoint.dom()));
          each(extractChildren(fromBlock), function(child2) {
            before(insertionPoint, child2);
          });
          removeEmptyRoot(rootNode, fromBlock);
          return position;
        };
        var sidelongBlockMerge = function(rootNode, fromBlock, toBlock) {
          if (Empty.isEmpty(toBlock)) {
            remove$1(toBlock);
            if (Empty.isEmpty(fromBlock)) {
              PaddingBr.fillWithPaddingBr(fromBlock);
            }
            return CaretFinder.firstPositionIn(fromBlock.dom());
          }
          var position = CaretFinder.lastPositionIn(toBlock.dom());
          each(extractChildren(fromBlock), function(child2) {
            append(toBlock, child2);
          });
          removeEmptyRoot(rootNode, fromBlock);
          return position;
        };
        var findInsertionPoint = function(toBlock, block) {
          var parentsAndSelf2 = Parents.parentsAndSelf(block, toBlock);
          return Option.from(parentsAndSelf2[parentsAndSelf2.length - 1]);
        };
        var getInsertionPoint = function(fromBlock, toBlock) {
          return contains$3(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Option.none();
        };
        var trimBr = function(first2, block) {
          CaretFinder.positionIn(first2, block.dom()).map(function(position) {
            return position.getNode();
          }).map(Element.fromDom).filter(isBr).each(remove$1);
        };
        var mergeBlockInto = function(rootNode, fromBlock, toBlock) {
          trimBr(true, fromBlock);
          trimBr(false, toBlock);
          return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
        };
        var mergeBlocks = function(rootNode, forward, block1, block2) {
          return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
        };
        var MergeBlocks = { mergeBlocks };
        var backspaceDelete = function(editor, forward) {
          var position;
          var rootNode = Element.fromDom(editor.getBody());
          position = BlockMergeBoundary.read(rootNode.dom(), forward, editor.selection.getRng()).bind(function(blockBoundary) {
            return MergeBlocks.mergeBlocks(rootNode, forward, blockBoundary.from().block(), blockBoundary.to().block());
          });
          position.each(function(pos) {
            editor.selection.setRng(pos.toRange());
          });
          return position.isSome();
        };
        var BlockBoundaryDelete = { backspaceDelete };
        var deleteRangeMergeBlocks = function(rootNode, selection) {
          var rng = selection.getRng();
          return lift2(DeleteUtils.getParentBlock(rootNode, Element.fromDom(rng.startContainer)), DeleteUtils.getParentBlock(rootNode, Element.fromDom(rng.endContainer)), function(block1, block2) {
            if (eq(block1, block2) === false) {
              rng.deleteContents();
              MergeBlocks.mergeBlocks(rootNode, true, block1, block2).each(function(pos) {
                selection.setRng(pos.toRange());
              });
              return true;
            } else {
              return false;
            }
          }).getOr(false);
        };
        var isRawNodeInTable = function(root, rawNode) {
          var node2 = Element.fromDom(rawNode);
          var isRoot = curry(eq, root);
          return ancestor(node2, isTableCell, isRoot).isSome();
        };
        var isSelectionInTable = function(root, rng) {
          return isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
        };
        var isEverythingSelected = function(root, rng) {
          var noPrevious = CaretFinder.prevPosition(root.dom(), CaretPosition$1.fromRangeStart(rng)).isNone();
          var noNext = CaretFinder.nextPosition(root.dom(), CaretPosition$1.fromRangeEnd(rng)).isNone();
          return !isSelectionInTable(root, rng) && noPrevious && noNext;
        };
        var emptyEditor = function(editor) {
          editor.setContent("");
          editor.selection.setCursorLocation();
          return true;
        };
        var deleteRange = function(editor) {
          var rootNode = Element.fromDom(editor.getBody());
          var rng = editor.selection.getRng();
          return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
        };
        var backspaceDelete$1 = function(editor, forward) {
          return editor.selection.isCollapsed() ? false : deleteRange(editor);
        };
        var BlockRangeDelete = { backspaceDelete: backspaceDelete$1 };
        var generate$1 = function(cases) {
          if (!isArray(cases)) {
            throw new Error("cases must be an array");
          }
          if (cases.length === 0) {
            throw new Error("there must be at least one case");
          }
          var constructors = [];
          var adt2 = {};
          each(cases, function(acase, count2) {
            var keys$1 = keys(acase);
            if (keys$1.length !== 1) {
              throw new Error("one and only one name per case");
            }
            var key = keys$1[0];
            var value2 = acase[key];
            if (adt2[key] !== void 0) {
              throw new Error("duplicate key detected:" + key);
            } else if (key === "cata") {
              throw new Error("cannot have a case named cata (sorry)");
            } else if (!isArray(value2)) {
              throw new Error("case arguments must be an array");
            }
            constructors.push(key);
            adt2[key] = function() {
              var argLength = arguments.length;
              if (argLength !== value2.length) {
                throw new Error("Wrong number of arguments to case " + key + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
              }
              var args = new Array(argLength);
              for (var i2 = 0; i2 < args.length; i2++) {
                args[i2] = arguments[i2];
              }
              var match2 = function(branches) {
                var branchKeys = keys(branches);
                if (constructors.length !== branchKeys.length) {
                  throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
                }
                var allReqd = forall(constructors, function(reqKey) {
                  return contains(branchKeys, reqKey);
                });
                if (!allReqd) {
                  throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
                }
                return branches[key].apply(null, args);
              };
              return {
                fold: function() {
                  if (arguments.length !== cases.length) {
                    throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + arguments.length);
                  }
                  var target = arguments[count2];
                  return target.apply(null, args);
                },
                match: match2,
                log: function(label) {
                  domGlobals.console.log(label, {
                    constructors,
                    constructor: key,
                    params: args
                  });
                }
              };
            };
          });
          return adt2;
        };
        var Adt = { generate: generate$1 };
        var isBr$5 = function(pos) {
          return getElementFromPosition(pos).exists(isBr);
        };
        var findBr = function(forward, root, pos) {
          var parentBlocks = filter(Parents.parentsAndSelf(Element.fromDom(pos.container()), root), isBlock);
          var scope = head(parentBlocks).getOr(root);
          return CaretFinder.fromPosition(forward, scope.dom(), pos).filter(isBr$5);
        };
        var isBeforeBr = function(root, pos) {
          return getElementFromPosition(pos).exists(isBr) || findBr(true, root, pos).isSome();
        };
        var isAfterBr = function(root, pos) {
          return getElementFromPrevPosition(pos).exists(isBr) || findBr(false, root, pos).isSome();
        };
        var findPreviousBr = curry(findBr, false);
        var findNextBr = curry(findBr, true);
        var is$2 = function(expected) {
          return function(actual) {
            return expected === actual;
          };
        };
        var isNbsp = is$2("\xA0");
        var isWhiteSpace$1 = function(chr) {
          return /^[\r\n\t ]$/.test(chr);
        };
        var isContent$1 = function(chr) {
          return !isWhiteSpace$1(chr) && !isNbsp(chr);
        };
        var isChar = function(forward, predicate, pos) {
          return Option.from(pos.container()).filter(NodeType.isText).exists(function(text) {
            var delta = forward ? 0 : -1;
            return predicate(text.data.charAt(pos.offset() + delta));
          });
        };
        var isBeforeSpace = curry(isChar, true, isWhiteSpace$1);
        var isAfterSpace = curry(isChar, false, isWhiteSpace$1);
        var isEmptyText = function(pos) {
          var container = pos.container();
          return NodeType.isText(container) && container.data.length === 0;
        };
        var isNextToContentEditableFalse = function(relativeOffset, caretPosition) {
          var node2 = getChildNodeAtRelativeOffset(relativeOffset, caretPosition);
          return NodeType.isContentEditableFalse(node2) && !NodeType.isBogusAll(node2);
        };
        var isBeforeContentEditableFalse = curry(isNextToContentEditableFalse, 0);
        var isAfterContentEditableFalse = curry(isNextToContentEditableFalse, -1);
        var isNextToTable = function(relativeOffset, caretPosition) {
          return NodeType.isTable(getChildNodeAtRelativeOffset(relativeOffset, caretPosition));
        };
        var isBeforeTable = curry(isNextToTable, 0);
        var isAfterTable = curry(isNextToTable, -1);
        var isCompoundElement = function(node2) {
          return isTableCell(Element.fromDom(node2)) || isListItem(Element.fromDom(node2));
        };
        var DeleteAction = Adt.generate([
          { remove: ["element"] },
          { moveToElement: ["element"] },
          { moveToPosition: ["position"] }
        ]);
        var isAtContentEditableBlockCaret = function(forward, from2) {
          var elm = from2.getNode(forward === false);
          var caretLocation = forward ? "after" : "before";
          return NodeType.isElement(elm) && elm.getAttribute("data-mce-caret") === caretLocation;
        };
        var isDeleteFromCefDifferentBlocks = function(root, forward, from2, to) {
          var inSameBlock = function(elm) {
            return isInline(Element.fromDom(elm)) && !isInSameBlock(from2, to, root);
          };
          return getRelativeCefElm(!forward, from2).fold(function() {
            return getRelativeCefElm(forward, to).fold(constant(false), inSameBlock);
          }, inSameBlock);
        };
        var deleteEmptyBlockOrMoveToCef = function(root, forward, from2, to) {
          var toCefElm = to.getNode(forward === false);
          return DeleteUtils.getParentBlock(Element.fromDom(root), Element.fromDom(from2.getNode())).map(function(blockElm) {
            return Empty.isEmpty(blockElm) ? DeleteAction.remove(blockElm.dom()) : DeleteAction.moveToElement(toCefElm);
          }).orThunk(function() {
            return Option.some(DeleteAction.moveToElement(toCefElm));
          });
        };
        var findCefPosition = function(root, forward, from2) {
          return CaretFinder.fromPosition(forward, root, from2).bind(function(to) {
            if (isCompoundElement(to.getNode())) {
              return Option.none();
            } else if (isDeleteFromCefDifferentBlocks(root, forward, from2, to)) {
              return Option.none();
            } else if (forward && NodeType.isContentEditableFalse(to.getNode())) {
              return deleteEmptyBlockOrMoveToCef(root, forward, from2, to);
            } else if (forward === false && NodeType.isContentEditableFalse(to.getNode(true))) {
              return deleteEmptyBlockOrMoveToCef(root, forward, from2, to);
            } else if (forward && isAfterContentEditableFalse(from2)) {
              return Option.some(DeleteAction.moveToPosition(to));
            } else if (forward === false && isBeforeContentEditableFalse(from2)) {
              return Option.some(DeleteAction.moveToPosition(to));
            } else {
              return Option.none();
            }
          });
        };
        var getContentEditableBlockAction = function(forward, elm) {
          if (forward && NodeType.isContentEditableFalse(elm.nextSibling)) {
            return Option.some(DeleteAction.moveToElement(elm.nextSibling));
          } else if (forward === false && NodeType.isContentEditableFalse(elm.previousSibling)) {
            return Option.some(DeleteAction.moveToElement(elm.previousSibling));
          } else {
            return Option.none();
          }
        };
        var skipMoveToActionFromInlineCefToContent = function(root, from2, deleteAction2) {
          return deleteAction2.fold(function(elm) {
            return Option.some(DeleteAction.remove(elm));
          }, function(elm) {
            return Option.some(DeleteAction.moveToElement(elm));
          }, function(to) {
            if (isInSameBlock(from2, to, root)) {
              return Option.none();
            } else {
              return Option.some(DeleteAction.moveToPosition(to));
            }
          });
        };
        var getContentEditableAction = function(root, forward, from2) {
          if (isAtContentEditableBlockCaret(forward, from2)) {
            return getContentEditableBlockAction(forward, from2.getNode(forward === false)).fold(function() {
              return findCefPosition(root, forward, from2);
            }, Option.some);
          } else {
            return findCefPosition(root, forward, from2).bind(function(deleteAction2) {
              return skipMoveToActionFromInlineCefToContent(root, from2, deleteAction2);
            });
          }
        };
        var read$2 = function(root, forward, rng) {
          var normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
          var from2 = CaretPosition$1.fromRangeStart(normalizedRange);
          var rootElement = Element.fromDom(root);
          if (forward === false && isAfterContentEditableFalse(from2)) {
            return Option.some(DeleteAction.remove(from2.getNode(true)));
          } else if (forward && isBeforeContentEditableFalse(from2)) {
            return Option.some(DeleteAction.remove(from2.getNode()));
          } else if (forward === false && isBeforeContentEditableFalse(from2) && isAfterBr(rootElement, from2)) {
            return findPreviousBr(rootElement, from2).map(function(br) {
              return DeleteAction.remove(br.getNode());
            });
          } else if (forward && isAfterContentEditableFalse(from2) && isBeforeBr(rootElement, from2)) {
            return findNextBr(rootElement, from2).map(function(br) {
              return DeleteAction.remove(br.getNode());
            });
          } else {
            return getContentEditableAction(root, forward, from2);
          }
        };
        var isCollapsibleWhitespace = function(c) {
          return " \f\n\r	\v".indexOf(c) !== -1;
        };
        var normalizeContent = function(content, isStartOfContent, isEndOfContent) {
          var result = foldl(content.split(""), function(acc, c) {
            if (isCollapsibleWhitespace(c) || c === "\xA0") {
              if (acc.previousCharIsSpace || acc.str === "" && isStartOfContent || acc.str.length === content.length - 1 && isEndOfContent) {
                return {
                  previousCharIsSpace: false,
                  str: acc.str + "\xA0"
                };
              } else {
                return {
                  previousCharIsSpace: true,
                  str: acc.str + " "
                };
              }
            } else {
              return {
                previousCharIsSpace: false,
                str: acc.str + c
              };
            }
          }, {
            previousCharIsSpace: false,
            str: ""
          });
          return result.str;
        };
        var normalize$1 = function(node2, offset, count2) {
          if (count2 === 0) {
            return;
          }
          var whitespace2 = node2.data.slice(offset, offset + count2);
          var isEndOfContent = offset + count2 >= node2.data.length;
          var isStartOfContent = offset === 0;
          node2.replaceData(offset, count2, normalizeContent(whitespace2, isStartOfContent, isEndOfContent));
        };
        var normalizeWhitespaceAfter = function(node2, offset) {
          var content = node2.data.slice(offset);
          var whitespaceCount = content.length - lTrim(content).length;
          return normalize$1(node2, offset, whitespaceCount);
        };
        var normalizeWhitespaceBefore = function(node2, offset) {
          var content = node2.data.slice(0, offset);
          var whitespaceCount = content.length - rTrim(content).length;
          return normalize$1(node2, offset - whitespaceCount, whitespaceCount);
        };
        var mergeTextNodes = function(prevNode, nextNode, normalizeWhitespace) {
          var whitespaceOffset = rTrim(prevNode.data).length;
          prevNode.appendData(nextNode.data);
          remove$1(Element.fromDom(nextNode));
          if (normalizeWhitespace) {
            normalizeWhitespaceAfter(prevNode, whitespaceOffset);
          }
          return prevNode;
        };
        var needsReposition = function(pos, elm) {
          var container = pos.container();
          var offset = pos.offset();
          return CaretPosition$1.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition$1.before(elm).offset();
        };
        var reposition = function(elm, pos) {
          return needsReposition(pos, elm) ? CaretPosition$1(pos.container(), pos.offset() - 1) : pos;
        };
        var beforeOrStartOf = function(node2) {
          return NodeType.isText(node2) ? CaretPosition$1(node2, 0) : CaretPosition$1.before(node2);
        };
        var afterOrEndOf = function(node2) {
          return NodeType.isText(node2) ? CaretPosition$1(node2, node2.data.length) : CaretPosition$1.after(node2);
        };
        var getPreviousSiblingCaretPosition = function(elm) {
          if (isCaretCandidate(elm.previousSibling)) {
            return Option.some(afterOrEndOf(elm.previousSibling));
          } else {
            return elm.previousSibling ? CaretFinder.lastPositionIn(elm.previousSibling) : Option.none();
          }
        };
        var getNextSiblingCaretPosition = function(elm) {
          if (isCaretCandidate(elm.nextSibling)) {
            return Option.some(beforeOrStartOf(elm.nextSibling));
          } else {
            return elm.nextSibling ? CaretFinder.firstPositionIn(elm.nextSibling) : Option.none();
          }
        };
        var findCaretPositionBackwardsFromElm = function(rootElement, elm) {
          var startPosition = CaretPosition$1.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
          return CaretFinder.prevPosition(rootElement, startPosition).fold(function() {
            return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm));
          }, Option.some);
        };
        var findCaretPositionForwardsFromElm = function(rootElement, elm) {
          return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm)).fold(function() {
            return CaretFinder.prevPosition(rootElement, CaretPosition$1.before(elm));
          }, Option.some);
        };
        var findCaretPositionBackwards = function(rootElement, elm) {
          return getPreviousSiblingCaretPosition(elm).orThunk(function() {
            return getNextSiblingCaretPosition(elm);
          }).orThunk(function() {
            return findCaretPositionBackwardsFromElm(rootElement, elm);
          });
        };
        var findCaretPositionForward = function(rootElement, elm) {
          return getNextSiblingCaretPosition(elm).orThunk(function() {
            return getPreviousSiblingCaretPosition(elm);
          }).orThunk(function() {
            return findCaretPositionForwardsFromElm(rootElement, elm);
          });
        };
        var findCaretPosition$1 = function(forward, rootElement, elm) {
          return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
        };
        var findCaretPosOutsideElmAfterDelete = function(forward, rootElement, elm) {
          return findCaretPosition$1(forward, rootElement, elm).map(curry(reposition, elm));
        };
        var setSelection = function(editor, forward, pos) {
          pos.fold(function() {
            editor.focus();
          }, function(pos2) {
            editor.selection.setRng(pos2.toRange(), forward);
          });
        };
        var eqRawNode = function(rawNode) {
          return function(elm) {
            return elm.dom() === rawNode;
          };
        };
        var isBlock$2 = function(editor, elm) {
          return elm && editor.schema.getBlockElements().hasOwnProperty(name(elm));
        };
        var paddEmptyBlock = function(elm) {
          if (Empty.isEmpty(elm)) {
            var br = Element.fromHtml('<br data-mce-bogus="1">');
            empty(elm);
            append(elm, br);
            return Option.some(CaretPosition$1.before(br.dom()));
          } else {
            return Option.none();
          }
        };
        var deleteNormalized = function(elm, afterDeletePosOpt, normalizeWhitespace) {
          var prevTextOpt = prevSibling(elm).filter(isText);
          var nextTextOpt = nextSibling(elm).filter(isText);
          remove$1(elm);
          return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, function(prev, next, pos) {
            var prevNode = prev.dom(), nextNode = next.dom();
            var offset = prevNode.data.length;
            mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
            return pos.container() === nextNode ? CaretPosition$1(prevNode, offset) : pos;
          }).orThunk(function() {
            if (normalizeWhitespace) {
              prevTextOpt.each(function(elm2) {
                return normalizeWhitespaceBefore(elm2.dom(), elm2.dom().length);
              });
              nextTextOpt.each(function(elm2) {
                return normalizeWhitespaceAfter(elm2.dom(), 0);
              });
            }
            return afterDeletePosOpt;
          });
        };
        var isInlineElement = function(editor, element) {
          return has(editor.schema.getTextInlineElements(), name(element));
        };
        var deleteElement = function(editor, forward, elm, moveCaret2) {
          if (moveCaret2 === void 0) {
            moveCaret2 = true;
          }
          var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom());
          var parentBlock = ancestor(elm, curry(isBlock$2, editor), eqRawNode(editor.getBody()));
          var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
          if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent("");
            editor.selection.setCursorLocation();
          } else {
            parentBlock.bind(paddEmptyBlock).fold(function() {
              if (moveCaret2) {
                setSelection(editor, forward, normalizedAfterDeletePos);
              }
            }, function(paddPos) {
              if (moveCaret2) {
                setSelection(editor, forward, Option.some(paddPos));
              }
            });
          }
        };
        var DeleteElement = { deleteElement };
        var deleteElement$1 = function(editor, forward) {
          return function(element) {
            editor._selectionOverrides.hideFakeCaret();
            DeleteElement.deleteElement(editor, forward, Element.fromDom(element));
            return true;
          };
        };
        var moveToElement = function(editor, forward) {
          return function(element) {
            var pos = forward ? CaretPosition$1.before(element) : CaretPosition$1.after(element);
            editor.selection.setRng(pos.toRange());
            return true;
          };
        };
        var moveToPosition = function(editor) {
          return function(pos) {
            editor.selection.setRng(pos.toRange());
            return true;
          };
        };
        var backspaceDeleteCaret = function(editor, forward) {
          var result = read$2(editor.getBody(), forward, editor.selection.getRng()).map(function(deleteAction2) {
            return deleteAction2.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));
          });
          return result.getOr(false);
        };
        var deleteOffscreenSelection = function(rootElement) {
          each(descendants$1(rootElement, ".mce-offscreen-selection"), remove$1);
        };
        var backspaceDeleteRange = function(editor, forward) {
          var selectedElement = editor.selection.getNode();
          if (NodeType.isContentEditableFalse(selectedElement)) {
            deleteOffscreenSelection(Element.fromDom(editor.getBody()));
            DeleteElement.deleteElement(editor, forward, Element.fromDom(editor.selection.getNode()));
            DeleteUtils.paddEmptyBody(editor);
            return true;
          } else {
            return false;
          }
        };
        var getContentEditableRoot = function(root, node2) {
          while (node2 && node2 !== root) {
            if (NodeType.isContentEditableTrue(node2) || NodeType.isContentEditableFalse(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var paddEmptyElement = function(editor) {
          var br;
          var ceRoot = getContentEditableRoot(editor.getBody(), editor.selection.getNode());
          if (NodeType.isContentEditableTrue(ceRoot) && editor.dom.isBlock(ceRoot) && editor.dom.isEmpty(ceRoot)) {
            br = editor.dom.create("br", { "data-mce-bogus": "1" });
            editor.dom.setHTML(ceRoot, "");
            ceRoot.appendChild(br);
            editor.selection.setRng(CaretPosition$1.before(br).toRange());
          }
          return true;
        };
        var backspaceDelete$2 = function(editor, forward) {
          if (editor.selection.isCollapsed()) {
            return backspaceDeleteCaret(editor, forward);
          } else {
            return backspaceDeleteRange(editor, forward);
          }
        };
        var CefDelete = {
          backspaceDelete: backspaceDelete$2,
          paddEmptyElement
        };
        var isText$8 = NodeType.isText;
        var startsWithCaretContainer$1 = function(node2) {
          return isText$8(node2) && node2.data[0] === Zwsp.ZWSP;
        };
        var endsWithCaretContainer$1 = function(node2) {
          return isText$8(node2) && node2.data[node2.data.length - 1] === Zwsp.ZWSP;
        };
        var createZwsp = function(node2) {
          return node2.ownerDocument.createTextNode(Zwsp.ZWSP);
        };
        var insertBefore$1 = function(node2) {
          if (isText$8(node2.previousSibling)) {
            if (endsWithCaretContainer$1(node2.previousSibling)) {
              return node2.previousSibling;
            } else {
              node2.previousSibling.appendData(Zwsp.ZWSP);
              return node2.previousSibling;
            }
          } else if (isText$8(node2)) {
            if (startsWithCaretContainer$1(node2)) {
              return node2;
            } else {
              node2.insertData(0, Zwsp.ZWSP);
              return node2;
            }
          } else {
            var newNode = createZwsp(node2);
            node2.parentNode.insertBefore(newNode, node2);
            return newNode;
          }
        };
        var insertAfter$1 = function(node2) {
          if (isText$8(node2.nextSibling)) {
            if (startsWithCaretContainer$1(node2.nextSibling)) {
              return node2.nextSibling;
            } else {
              node2.nextSibling.insertData(0, Zwsp.ZWSP);
              return node2.nextSibling;
            }
          } else if (isText$8(node2)) {
            if (endsWithCaretContainer$1(node2)) {
              return node2;
            } else {
              node2.appendData(Zwsp.ZWSP);
              return node2;
            }
          } else {
            var newNode = createZwsp(node2);
            if (node2.nextSibling) {
              node2.parentNode.insertBefore(newNode, node2.nextSibling);
            } else {
              node2.parentNode.appendChild(newNode);
            }
            return newNode;
          }
        };
        var insertInline$1 = function(before2, node2) {
          return before2 ? insertBefore$1(node2) : insertAfter$1(node2);
        };
        var insertInlineBefore = curry(insertInline$1, true);
        var insertInlineAfter = curry(insertInline$1, false);
        var insertInlinePos = function(pos, before2) {
          if (NodeType.isText(pos.container())) {
            return insertInline$1(before2, pos.container());
          } else {
            return insertInline$1(before2, pos.getNode());
          }
        };
        var isPosCaretContainer = function(pos, caret) {
          var caretNode = caret.get();
          return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
        };
        var renderCaret = function(caret, location) {
          return location.fold(function(element) {
            CaretContainerRemove.remove(caret.get());
            var text = insertInlineBefore(element);
            caret.set(text);
            return Option.some(CaretPosition$1(text, text.length - 1));
          }, function(element) {
            return CaretFinder.firstPositionIn(element).map(function(pos) {
              if (!isPosCaretContainer(pos, caret)) {
                CaretContainerRemove.remove(caret.get());
                var text = insertInlinePos(pos, true);
                caret.set(text);
                return CaretPosition$1(text, 1);
              } else {
                return CaretPosition$1(caret.get(), 1);
              }
            });
          }, function(element) {
            return CaretFinder.lastPositionIn(element).map(function(pos) {
              if (!isPosCaretContainer(pos, caret)) {
                CaretContainerRemove.remove(caret.get());
                var text = insertInlinePos(pos, false);
                caret.set(text);
                return CaretPosition$1(text, text.length - 1);
              } else {
                return CaretPosition$1(caret.get(), caret.get().length - 1);
              }
            });
          }, function(element) {
            CaretContainerRemove.remove(caret.get());
            var text = insertInlineAfter(element);
            caret.set(text);
            return Option.some(CaretPosition$1(text, 1));
          });
        };
        var BoundaryCaret = { renderCaret };
        var evaluateUntil = function(fns, args) {
          for (var i2 = 0; i2 < fns.length; i2++) {
            var result = fns[i2].apply(null, args);
            if (result.isSome()) {
              return result;
            }
          }
          return Option.none();
        };
        var LazyEvaluator = { evaluateUntil };
        var Location = Adt.generate([
          { before: ["element"] },
          { start: ["element"] },
          { end: ["element"] },
          { after: ["element"] }
        ]);
        var rescope = function(rootNode, node2) {
          var parentBlock = getParentBlock(node2, rootNode);
          return parentBlock ? parentBlock : rootNode;
        };
        var before$3 = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeForwards(pos);
          var scope = rescope(rootNode, nPos.container());
          return InlineUtils.findRootInline(isInlineTarget2, scope, nPos).fold(function() {
            return CaretFinder.nextPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget2, scope)).map(function(inline) {
              return Location.before(inline);
            });
          }, Option.none);
        };
        var isNotInsideFormatCaretContainer = function(rootNode, elm) {
          return getParentCaretContainer(rootNode, elm) === null;
        };
        var findInsideRootInline = function(isInlineTarget2, rootNode, pos) {
          return InlineUtils.findRootInline(isInlineTarget2, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
        };
        var start = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeBackwards(pos);
          return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline) {
            var prevPos = CaretFinder.prevPosition(inline, nPos);
            return prevPos.isNone() ? Option.some(Location.start(inline)) : Option.none();
          });
        };
        var end = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeForwards(pos);
          return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline) {
            var nextPos = CaretFinder.nextPosition(inline, nPos);
            return nextPos.isNone() ? Option.some(Location.end(inline)) : Option.none();
          });
        };
        var after$2 = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeBackwards(pos);
          var scope = rescope(rootNode, nPos.container());
          return InlineUtils.findRootInline(isInlineTarget2, scope, nPos).fold(function() {
            return CaretFinder.prevPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget2, scope)).map(function(inline) {
              return Location.after(inline);
            });
          }, Option.none);
        };
        var isValidLocation = function(location) {
          return InlineUtils.isRtl(getElement(location)) === false;
        };
        var readLocation = function(isInlineTarget2, rootNode, pos) {
          var location = LazyEvaluator.evaluateUntil([
            before$3,
            start,
            end,
            after$2
          ], [
            isInlineTarget2,
            rootNode,
            pos
          ]);
          return location.filter(isValidLocation);
        };
        var getElement = function(location) {
          return location.fold(identity, identity, identity, identity);
        };
        var getName = function(location) {
          return location.fold(constant("before"), constant("start"), constant("end"), constant("after"));
        };
        var outside = function(location) {
          return location.fold(Location.before, Location.before, Location.after, Location.after);
        };
        var inside = function(location) {
          return location.fold(Location.start, Location.start, Location.end, Location.end);
        };
        var isEq$1 = function(location1, location2) {
          return getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
        };
        var betweenInlines = function(forward, isInlineTarget2, rootNode, from2, to, location) {
          return lift2(InlineUtils.findRootInline(isInlineTarget2, rootNode, from2), InlineUtils.findRootInline(isInlineTarget2, rootNode, to), function(fromInline, toInline) {
            if (fromInline !== toInline && InlineUtils.hasSameParentBlock(rootNode, fromInline, toInline)) {
              return Location.after(forward ? fromInline : toInline);
            } else {
              return location;
            }
          }).getOr(location);
        };
        var skipNoMovement = function(fromLocation, toLocation) {
          return fromLocation.fold(constant(true), function(fromLocation2) {
            return !isEq$1(fromLocation2, toLocation);
          });
        };
        var findLocationTraverse = function(forward, isInlineTarget2, rootNode, fromLocation, pos) {
          var from2 = InlineUtils.normalizePosition(forward, pos);
          var to = CaretFinder.fromPosition(forward, rootNode, from2).map(curry(InlineUtils.normalizePosition, forward));
          var location = to.fold(function() {
            return fromLocation.map(outside);
          }, function(to2) {
            return readLocation(isInlineTarget2, rootNode, to2).map(curry(betweenInlines, forward, isInlineTarget2, rootNode, from2, to2)).filter(curry(skipNoMovement, fromLocation));
          });
          return location.filter(isValidLocation);
        };
        var findLocationSimple = function(forward, location) {
          if (forward) {
            return location.fold(compose(Option.some, Location.start), Option.none, compose(Option.some, Location.after), Option.none);
          } else {
            return location.fold(Option.none, compose(Option.some, Location.before), Option.none, compose(Option.some, Location.end));
          }
        };
        var findLocation = function(forward, isInlineTarget2, rootNode, pos) {
          var from2 = InlineUtils.normalizePosition(forward, pos);
          var fromLocation = readLocation(isInlineTarget2, rootNode, from2);
          return readLocation(isInlineTarget2, rootNode, from2).bind(curry(findLocationSimple, forward)).orThunk(function() {
            return findLocationTraverse(forward, isInlineTarget2, rootNode, fromLocation, pos);
          });
        };
        var BoundaryLocation = {
          readLocation,
          findLocation,
          prevLocation: curry(findLocation, false),
          nextLocation: curry(findLocation, true),
          getElement,
          outside,
          inside
        };
        var hasSelectionModifyApi = function(editor) {
          return isFunction(editor.selection.getSel().modify);
        };
        var moveRel = function(forward, selection, pos) {
          var delta = forward ? 1 : -1;
          selection.setRng(CaretPosition$1(pos.container(), pos.offset() + delta).toRange());
          selection.getSel().modify("move", forward ? "forward" : "backward", "word");
          return true;
        };
        var moveByWord = function(forward, editor) {
          var rng = editor.selection.getRng();
          var pos = forward ? CaretPosition$1.fromRangeEnd(rng) : CaretPosition$1.fromRangeStart(rng);
          if (!hasSelectionModifyApi(editor)) {
            return false;
          } else if (forward && isBeforeInline(pos)) {
            return moveRel(true, editor.selection, pos);
          } else if (!forward && isAfterInline(pos)) {
            return moveRel(false, editor.selection, pos);
          } else {
            return false;
          }
        };
        var WordSelection = {
          hasSelectionModifyApi,
          moveByWord
        };
        var setCaretPosition = function(editor, pos) {
          var rng = editor.dom.createRng();
          rng.setStart(pos.container(), pos.offset());
          rng.setEnd(pos.container(), pos.offset());
          editor.selection.setRng(rng);
        };
        var isFeatureEnabled = function(editor) {
          return editor.settings.inline_boundaries !== false;
        };
        var setSelected = function(state, elm) {
          if (state) {
            elm.setAttribute("data-mce-selected", "inline-boundary");
          } else {
            elm.removeAttribute("data-mce-selected");
          }
        };
        var renderCaretLocation = function(editor, caret, location) {
          return BoundaryCaret.renderCaret(caret, location).map(function(pos) {
            setCaretPosition(editor, pos);
            return location;
          });
        };
        var findLocation$1 = function(editor, caret, forward) {
          var rootNode = editor.getBody();
          var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          var location = BoundaryLocation.findLocation(forward, isInlineTarget2, rootNode, from2);
          return location.bind(function(location2) {
            return renderCaretLocation(editor, caret, location2);
          });
        };
        var toggleInlines = function(isInlineTarget2, dom2, elms) {
          var selectedInlines = filter(dom2.select('*[data-mce-selected="inline-boundary"]'), isInlineTarget2);
          var targetInlines = filter(elms, isInlineTarget2);
          each(difference(selectedInlines, targetInlines), curry(setSelected, false));
          each(difference(targetInlines, selectedInlines), curry(setSelected, true));
        };
        var safeRemoveCaretContainer = function(editor, caret) {
          if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {
            var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            if (CaretPosition$1.isTextPosition(pos) && InlineUtils.isAtZwsp(pos) === false) {
              setCaretPosition(editor, CaretContainerRemove.removeAndReposition(caret.get(), pos));
              caret.set(null);
            }
          }
        };
        var renderInsideInlineCaret = function(isInlineTarget2, editor, caret, elms) {
          if (editor.selection.isCollapsed()) {
            var inlines = filter(elms, isInlineTarget2);
            each(inlines, function(inline) {
              var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
              BoundaryLocation.readLocation(isInlineTarget2, editor.getBody(), pos).bind(function(location) {
                return renderCaretLocation(editor, caret, location);
              });
            });
          }
        };
        var move = function(editor, caret, forward) {
          return function() {
            return isFeatureEnabled(editor) ? findLocation$1(editor, caret, forward).isSome() : false;
          };
        };
        var moveWord = function(forward, editor, caret) {
          return function() {
            return isFeatureEnabled(editor) ? WordSelection.moveByWord(forward, editor) : false;
          };
        };
        var setupSelectedState = function(editor) {
          var caret = Cell(null);
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          editor.on("NodeChange", function(e) {
            if (isFeatureEnabled(editor)) {
              toggleInlines(isInlineTarget2, editor.dom, e.parents);
              safeRemoveCaretContainer(editor, caret);
              renderInsideInlineCaret(isInlineTarget2, editor, caret, e.parents);
            }
          });
          return caret;
        };
        var moveNextWord = curry(moveWord, true);
        var movePrevWord = curry(moveWord, false);
        var BoundarySelection = {
          move,
          moveNextWord,
          movePrevWord,
          setupSelectedState,
          setCaretPosition
        };
        var isFeatureEnabled$1 = function(editor) {
          return editor.settings.inline_boundaries !== false;
        };
        var rangeFromPositions = function(from2, to) {
          var range2 = domGlobals.document.createRange();
          range2.setStart(from2.container(), from2.offset());
          range2.setEnd(to.container(), to.offset());
          return range2;
        };
        var hasOnlyTwoOrLessPositionsLeft = function(elm) {
          return lift2(CaretFinder.firstPositionIn(elm), CaretFinder.lastPositionIn(elm), function(firstPos, lastPos) {
            var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
            var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
            return CaretFinder.nextPosition(elm, normalizedFirstPos).map(function(pos) {
              return pos.isEqual(normalizedLastPos);
            }).getOr(true);
          }).getOr(true);
        };
        var setCaretLocation = function(editor, caret) {
          return function(location) {
            return BoundaryCaret.renderCaret(caret, location).map(function(pos) {
              BoundarySelection.setCaretPosition(editor, pos);
              return true;
            }).getOr(false);
          };
        };
        var deleteFromTo = function(editor, caret, from2, to) {
          var rootNode = editor.getBody();
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          editor.undoManager.ignore(function() {
            editor.selection.setRng(rangeFromPositions(from2, to));
            editor.execCommand("Delete");
            BoundaryLocation.readLocation(isInlineTarget2, rootNode, CaretPosition$1.fromRangeStart(editor.selection.getRng())).map(BoundaryLocation.inside).map(setCaretLocation(editor, caret));
          });
          editor.nodeChanged();
        };
        var rescope$1 = function(rootNode, node2) {
          var parentBlock = getParentBlock(node2, rootNode);
          return parentBlock ? parentBlock : rootNode;
        };
        var backspaceDeleteCollapsed = function(editor, caret, forward, from2) {
          var rootNode = rescope$1(editor.getBody(), from2.container());
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          var fromLocation = BoundaryLocation.readLocation(isInlineTarget2, rootNode, from2);
          return fromLocation.bind(function(location) {
            if (forward) {
              return location.fold(constant(Option.some(BoundaryLocation.inside(location))), Option.none, constant(Option.some(BoundaryLocation.outside(location))), Option.none);
            } else {
              return location.fold(Option.none, constant(Option.some(BoundaryLocation.outside(location))), Option.none, constant(Option.some(BoundaryLocation.inside(location))));
            }
          }).map(setCaretLocation(editor, caret)).getOrThunk(function() {
            var toPosition = CaretFinder.navigate(forward, rootNode, from2);
            var toLocation = toPosition.bind(function(pos) {
              return BoundaryLocation.readLocation(isInlineTarget2, rootNode, pos);
            });
            if (fromLocation.isSome() && toLocation.isSome()) {
              return InlineUtils.findRootInline(isInlineTarget2, rootNode, from2).map(function(elm) {
                if (hasOnlyTwoOrLessPositionsLeft(elm)) {
                  DeleteElement.deleteElement(editor, forward, Element.fromDom(elm));
                  return true;
                } else {
                  return false;
                }
              }).getOr(false);
            } else {
              return toLocation.bind(function(_) {
                return toPosition.map(function(to) {
                  if (forward) {
                    deleteFromTo(editor, caret, from2, to);
                  } else {
                    deleteFromTo(editor, caret, to, from2);
                  }
                  return true;
                });
              }).getOr(false);
            }
          });
        };
        var backspaceDelete$3 = function(editor, caret, forward) {
          if (editor.selection.isCollapsed() && isFeatureEnabled$1(editor)) {
            var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            return backspaceDeleteCollapsed(editor, caret, forward, from2);
          }
          return false;
        };
        var InlineBoundaryDelete = { backspaceDelete: backspaceDelete$3 };
        var tableCellRng = Immutable("start", "end");
        var tableSelection = Immutable("rng", "table", "cells");
        var deleteAction = Adt.generate([
          { removeTable: ["element"] },
          { emptyCells: ["cells"] }
        ]);
        var isRootFromElement = function(root) {
          return curry(eq, root);
        };
        var getClosestCell = function(container, isRoot) {
          return closest$1(Element.fromDom(container), "td,th", isRoot);
        };
        var getClosestTable = function(cell, isRoot) {
          return ancestor$1(cell, "table", isRoot);
        };
        var isExpandedCellRng = function(cellRng) {
          return eq(cellRng.start(), cellRng.end()) === false;
        };
        var getTableFromCellRng = function(cellRng, isRoot) {
          return getClosestTable(cellRng.start(), isRoot).bind(function(startParentTable) {
            return getClosestTable(cellRng.end(), isRoot).bind(function(endParentTable) {
              return eq(startParentTable, endParentTable) ? Option.some(startParentTable) : Option.none();
            });
          });
        };
        var getTableCells = function(table) {
          return descendants$1(table, "td,th");
        };
        var getCellRangeFromStartTable = function(cellRng, isRoot) {
          return getClosestTable(cellRng.start(), isRoot).bind(function(table) {
            return last(getTableCells(table)).map(function(endCell) {
              return tableCellRng(cellRng.start(), endCell);
            });
          });
        };
        var partialSelection = function(isRoot, rng) {
          var startCell = getClosestCell(rng.startContainer, isRoot);
          var endCell = getClosestCell(rng.endContainer, isRoot);
          return rng.collapsed ? Option.none() : lift2(startCell, endCell, tableCellRng).fold(function() {
            return startCell.fold(function() {
              return endCell.bind(function(endCell2) {
                return getClosestTable(endCell2, isRoot).bind(function(table) {
                  return head(getTableCells(table)).map(function(startCell2) {
                    return tableCellRng(startCell2, endCell2);
                  });
                });
              });
            }, function(startCell2) {
              return getClosestTable(startCell2, isRoot).bind(function(table) {
                return last(getTableCells(table)).map(function(endCell2) {
                  return tableCellRng(startCell2, endCell2);
                });
              });
            });
          }, function(cellRng) {
            return isWithinSameTable(isRoot, cellRng) ? Option.none() : getCellRangeFromStartTable(cellRng, isRoot);
          });
        };
        var isWithinSameTable = function(isRoot, cellRng) {
          return getTableFromCellRng(cellRng, isRoot).isSome();
        };
        var getCellRng = function(rng, isRoot) {
          var startCell = getClosestCell(rng.startContainer, isRoot);
          var endCell = getClosestCell(rng.endContainer, isRoot);
          return lift2(startCell, endCell, tableCellRng).filter(isExpandedCellRng).filter(function(cellRng) {
            return isWithinSameTable(isRoot, cellRng);
          }).orThunk(function() {
            return partialSelection(isRoot, rng);
          });
        };
        var getTableSelectionFromCellRng = function(cellRng, isRoot) {
          return getTableFromCellRng(cellRng, isRoot).map(function(table) {
            return tableSelection(cellRng, table, getTableCells(table));
          });
        };
        var getTableSelectionFromRng = function(root, rng) {
          var isRoot = isRootFromElement(root);
          return getCellRng(rng, isRoot).bind(function(cellRng) {
            return getTableSelectionFromCellRng(cellRng, isRoot);
          });
        };
        var getCellIndex = function(cells, cell) {
          return findIndex(cells, function(x) {
            return eq(x, cell);
          });
        };
        var getSelectedCells = function(tableSelection2) {
          return lift2(getCellIndex(tableSelection2.cells(), tableSelection2.rng().start()), getCellIndex(tableSelection2.cells(), tableSelection2.rng().end()), function(startIndex, endIndex) {
            return tableSelection2.cells().slice(startIndex, endIndex + 1);
          });
        };
        var getAction = function(tableSelection2) {
          return getSelectedCells(tableSelection2).map(function(selected) {
            var cells = tableSelection2.cells();
            return selected.length === cells.length ? deleteAction.removeTable(tableSelection2.table()) : deleteAction.emptyCells(selected);
          });
        };
        var getActionFromCells = function(cells) {
          return deleteAction.emptyCells(cells);
        };
        var getActionFromRange = function(root, rng) {
          return getTableSelectionFromRng(root, rng).bind(getAction);
        };
        var TableDeleteAction = {
          getActionFromRange,
          getActionFromCells
        };
        var getRanges = function(selection) {
          var ranges = [];
          if (selection) {
            for (var i2 = 0; i2 < selection.rangeCount; i2++) {
              ranges.push(selection.getRangeAt(i2));
            }
          }
          return ranges;
        };
        var getSelectedNodes = function(ranges) {
          return bind(ranges, function(range2) {
            var node2 = getSelectedNode(range2);
            return node2 ? [Element.fromDom(node2)] : [];
          });
        };
        var hasMultipleRanges = function(selection) {
          return getRanges(selection).length > 1;
        };
        var MultiRange = {
          getRanges,
          getSelectedNodes,
          hasMultipleRanges
        };
        var getCellsFromRanges = function(ranges) {
          return filter(MultiRange.getSelectedNodes(ranges), isTableCell);
        };
        var getCellsFromElement = function(elm) {
          var selectedCells = descendants$1(elm, "td[data-mce-selected],th[data-mce-selected]");
          return selectedCells;
        };
        var getCellsFromElementOrRanges = function(ranges, element) {
          var selectedCells = getCellsFromElement(element);
          var rangeCells = getCellsFromRanges(ranges);
          return selectedCells.length > 0 ? selectedCells : rangeCells;
        };
        var getCellsFromEditor = function(editor) {
          return getCellsFromElementOrRanges(MultiRange.getRanges(editor.selection.getSel()), Element.fromDom(editor.getBody()));
        };
        var TableCellSelection = {
          getCellsFromRanges,
          getCellsFromElement,
          getCellsFromElementOrRanges,
          getCellsFromEditor
        };
        var emptyCells = function(editor, cells) {
          each(cells, PaddingBr.fillWithPaddingBr);
          editor.selection.setCursorLocation(cells[0].dom(), 0);
          return true;
        };
        var deleteTableElement = function(editor, table) {
          DeleteElement.deleteElement(editor, false, table);
          return true;
        };
        var deleteCellRange = function(editor, rootElm, rng) {
          return TableDeleteAction.getActionFromRange(rootElm, rng).map(function(action2) {
            return action2.fold(curry(deleteTableElement, editor), curry(emptyCells, editor));
          });
        };
        var deleteCaptionRange = function(editor, caption) {
          return emptyElement(editor, caption);
        };
        var deleteTableRange = function(editor, rootElm, rng, startElm) {
          return getParentCaption(rootElm, startElm).fold(function() {
            return deleteCellRange(editor, rootElm, rng);
          }, function(caption) {
            return deleteCaptionRange(editor, caption);
          }).getOr(false);
        };
        var deleteRange$1 = function(editor, startElm) {
          var rootNode = Element.fromDom(editor.getBody());
          var rng = editor.selection.getRng();
          var selectedCells = TableCellSelection.getCellsFromEditor(editor);
          return selectedCells.length !== 0 ? emptyCells(editor, selectedCells) : deleteTableRange(editor, rootNode, rng, startElm);
        };
        var getParentCell = function(rootElm, elm) {
          return find(Parents.parentsAndSelf(elm, rootElm), isTableCell);
        };
        var getParentCaption = function(rootElm, elm) {
          return find(Parents.parentsAndSelf(elm, rootElm), function(elm2) {
            return name(elm2) === "caption";
          });
        };
        var deleteBetweenCells = function(editor, rootElm, forward, fromCell, from2) {
          return CaretFinder.navigate(forward, editor.getBody(), from2).bind(function(to) {
            return getParentCell(rootElm, Element.fromDom(to.getNode())).map(function(toCell) {
              return eq(toCell, fromCell) === false;
            });
          });
        };
        var emptyElement = function(editor, elm) {
          PaddingBr.fillWithPaddingBr(elm);
          editor.selection.setCursorLocation(elm.dom(), 0);
          return Option.some(true);
        };
        var isDeleteOfLastCharPos = function(fromCaption, forward, from2, to) {
          return CaretFinder.firstPositionIn(fromCaption.dom()).bind(function(first2) {
            return CaretFinder.lastPositionIn(fromCaption.dom()).map(function(last2) {
              return forward ? from2.isEqual(first2) && to.isEqual(last2) : from2.isEqual(last2) && to.isEqual(first2);
            });
          }).getOr(true);
        };
        var emptyCaretCaption = function(editor, elm) {
          return emptyElement(editor, elm);
        };
        var validateCaretCaption = function(rootElm, fromCaption, to) {
          return getParentCaption(rootElm, Element.fromDom(to.getNode())).map(function(toCaption) {
            return eq(toCaption, fromCaption) === false;
          });
        };
        var deleteCaretInsideCaption = function(editor, rootElm, forward, fromCaption, from2) {
          return CaretFinder.navigate(forward, editor.getBody(), from2).bind(function(to) {
            return isDeleteOfLastCharPos(fromCaption, forward, from2, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to);
          }).or(Option.some(true));
        };
        var deleteCaretCells = function(editor, forward, rootElm, startElm) {
          var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          return getParentCell(rootElm, startElm).bind(function(fromCell) {
            return Empty.isEmpty(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from2);
          });
        };
        var deleteCaretCaption = function(editor, forward, rootElm, fromCaption) {
          var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          return Empty.isEmpty(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from2);
        };
        var deleteCaret = function(editor, forward, startElm) {
          var rootElm = Element.fromDom(editor.getBody());
          return getParentCaption(rootElm, startElm).fold(function() {
            return deleteCaretCells(editor, forward, rootElm, startElm);
          }, function(fromCaption) {
            return deleteCaretCaption(editor, forward, rootElm, fromCaption);
          }).getOr(false);
        };
        var backspaceDelete$4 = function(editor, forward) {
          var startElm = Element.fromDom(editor.selection.getStart(true));
          var cells = TableCellSelection.getCellsFromEditor(editor);
          return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret(editor, forward, startElm) : deleteRange$1(editor, startElm);
        };
        var TableDelete = { backspaceDelete: backspaceDelete$4 };
        var isEq$2 = FormatUtils.isEq;
        var matchesUnInheritedFormatSelector = function(ed, node2, name2) {
          var formatList = ed.formatter.get(name2);
          if (formatList) {
            for (var i2 = 0; i2 < formatList.length; i2++) {
              if (formatList[i2].inherit === false && ed.dom.is(node2, formatList[i2].selector)) {
                return true;
              }
            }
          }
          return false;
        };
        var matchParents = function(editor, node2, name2, vars) {
          var root = editor.dom.getRoot();
          if (node2 === root) {
            return false;
          }
          node2 = editor.dom.getParent(node2, function(node3) {
            if (matchesUnInheritedFormatSelector(editor, node3, name2)) {
              return true;
            }
            return node3.parentNode === root || !!matchNode(editor, node3, name2, vars, true);
          });
          return matchNode(editor, node2, name2, vars);
        };
        var matchName = function(dom2, node2, format) {
          if (isEq$2(node2, format.inline)) {
            return true;
          }
          if (isEq$2(node2, format.block)) {
            return true;
          }
          if (format.selector) {
            return node2.nodeType === 1 && dom2.is(node2, format.selector);
          }
        };
        var matchItems = function(dom2, node2, format, itemName, similar, vars) {
          var key, value2;
          var items = format[itemName];
          var i2;
          if (format.onmatch) {
            return format.onmatch(node2, format, itemName);
          }
          if (items) {
            if (typeof items.length === "undefined") {
              for (key in items) {
                if (items.hasOwnProperty(key)) {
                  if (itemName === "attributes") {
                    value2 = dom2.getAttrib(node2, key);
                  } else {
                    value2 = FormatUtils.getStyle(dom2, node2, key);
                  }
                  if (similar && !value2 && !format.exact) {
                    return;
                  }
                  if ((!similar || format.exact) && !isEq$2(value2, FormatUtils.normalizeStyleValue(dom2, FormatUtils.replaceVars(items[key], vars), key))) {
                    return;
                  }
                }
              }
            } else {
              for (i2 = 0; i2 < items.length; i2++) {
                if (itemName === "attributes" ? dom2.getAttrib(node2, items[i2]) : FormatUtils.getStyle(dom2, node2, items[i2])) {
                  return format;
                }
              }
            }
          }
          return format;
        };
        var matchNode = function(ed, node2, name2, vars, similar) {
          var formatList = ed.formatter.get(name2);
          var format, i2, x, classes;
          var dom2 = ed.dom;
          if (formatList && node2) {
            for (i2 = 0; i2 < formatList.length; i2++) {
              format = formatList[i2];
              if (matchName(ed.dom, node2, format) && matchItems(dom2, node2, format, "attributes", similar, vars) && matchItems(dom2, node2, format, "styles", similar, vars)) {
                if (classes = format.classes) {
                  for (x = 0; x < classes.length; x++) {
                    if (!ed.dom.hasClass(node2, classes[x])) {
                      return;
                    }
                  }
                }
                return format;
              }
            }
          }
        };
        var match = function(editor, name2, vars, node2) {
          var startNode;
          if (node2) {
            return matchParents(editor, node2, name2, vars);
          }
          node2 = editor.selection.getNode();
          if (matchParents(editor, node2, name2, vars)) {
            return true;
          }
          startNode = editor.selection.getStart();
          if (startNode !== node2) {
            if (matchParents(editor, startNode, name2, vars)) {
              return true;
            }
          }
          return false;
        };
        var matchAll = function(editor, names, vars) {
          var startElement;
          var matchedFormatNames = [];
          var checkedMap = {};
          startElement = editor.selection.getStart();
          editor.dom.getParent(startElement, function(node2) {
            var i2, name2;
            for (i2 = 0; i2 < names.length; i2++) {
              name2 = names[i2];
              if (!checkedMap[name2] && matchNode(editor, node2, name2, vars)) {
                checkedMap[name2] = true;
                matchedFormatNames.push(name2);
              }
            }
          }, editor.dom.getRoot());
          return matchedFormatNames;
        };
        var canApply = function(editor, name2) {
          var formatList = editor.formatter.get(name2);
          var startNode, parents2, i2, x, selector;
          var dom2 = editor.dom;
          if (formatList) {
            startNode = editor.selection.getStart();
            parents2 = FormatUtils.getParents(dom2, startNode);
            for (x = formatList.length - 1; x >= 0; x--) {
              selector = formatList[x].selector;
              if (!selector || formatList[x].defaultBlock) {
                return true;
              }
              for (i2 = parents2.length - 1; i2 >= 0; i2--) {
                if (dom2.is(parents2[i2], selector)) {
                  return true;
                }
              }
            }
          }
          return false;
        };
        var MatchFormat = {
          matchNode,
          matchName,
          match,
          matchAll,
          canApply,
          matchesUnInheritedFormatSelector
        };
        var splitText = function(node2, offset) {
          return node2.splitText(offset);
        };
        var split$1 = function(rng) {
          var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
          if (startContainer === endContainer && NodeType.isText(startContainer)) {
            if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
              endContainer = splitText(startContainer, startOffset);
              startContainer = endContainer.previousSibling;
              if (endOffset > startOffset) {
                endOffset = endOffset - startOffset;
                startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
                endOffset = endContainer.nodeValue.length;
                startOffset = 0;
              } else {
                endOffset = 0;
              }
            }
          } else {
            if (NodeType.isText(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
              startContainer = splitText(startContainer, startOffset);
              startOffset = 0;
            }
            if (NodeType.isText(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
              endContainer = splitText(endContainer, endOffset).previousSibling;
              endOffset = endContainer.nodeValue.length;
            }
          }
          return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
          };
        };
        var SplitRange = { split: split$1 };
        var ZWSP$1 = Zwsp.ZWSP, CARET_ID$1 = "_mce_caret";
        var importNode = function(ownerDocument, node2) {
          return ownerDocument.importNode(node2, true);
        };
        var getEmptyCaretContainers = function(node2) {
          var nodes = [];
          while (node2) {
            if (node2.nodeType === 3 && node2.nodeValue !== ZWSP$1 || node2.childNodes.length > 1) {
              return [];
            }
            if (node2.nodeType === 1) {
              nodes.push(node2);
            }
            node2 = node2.firstChild;
          }
          return nodes;
        };
        var isCaretContainerEmpty = function(node2) {
          return getEmptyCaretContainers(node2).length > 0;
        };
        var findFirstTextNode = function(node2) {
          var walker;
          if (node2) {
            walker = new TreeWalker(node2, node2);
            for (node2 = walker.current(); node2; node2 = walker.next()) {
              if (node2.nodeType === 3) {
                return node2;
              }
            }
          }
          return null;
        };
        var createCaretContainer = function(fill) {
          var caretContainer = Element.fromTag("span");
          setAll(caretContainer, {
            "id": CARET_ID$1,
            "data-mce-bogus": "1",
            "data-mce-type": "format-caret"
          });
          if (fill) {
            append(caretContainer, Element.fromText(ZWSP$1));
          }
          return caretContainer;
        };
        var trimZwspFromCaretContainer = function(caretContainerNode) {
          var textNode = findFirstTextNode(caretContainerNode);
          if (textNode && textNode.nodeValue.charAt(0) === ZWSP$1) {
            textNode.deleteData(0, 1);
          }
          return textNode;
        };
        var removeCaretContainerNode = function(editor, node2, moveCaret2) {
          if (moveCaret2 === void 0) {
            moveCaret2 = true;
          }
          var dom2 = editor.dom, selection = editor.selection;
          if (isCaretContainerEmpty(node2)) {
            DeleteElement.deleteElement(editor, false, Element.fromDom(node2), moveCaret2);
          } else {
            var rng = selection.getRng();
            var block = dom2.getParent(node2, dom2.isBlock);
            var textNode = trimZwspFromCaretContainer(node2);
            if (rng.startContainer === textNode && rng.startOffset > 0) {
              rng.setStart(textNode, rng.startOffset - 1);
            }
            if (rng.endContainer === textNode && rng.endOffset > 0) {
              rng.setEnd(textNode, rng.endOffset - 1);
            }
            dom2.remove(node2, true);
            if (block && dom2.isEmpty(block)) {
              PaddingBr.fillWithPaddingBr(Element.fromDom(block));
            }
            selection.setRng(rng);
          }
        };
        var removeCaretContainer = function(editor, node2, moveCaret2) {
          if (moveCaret2 === void 0) {
            moveCaret2 = true;
          }
          var dom2 = editor.dom, selection = editor.selection;
          if (!node2) {
            node2 = getParentCaretContainer(editor.getBody(), selection.getStart());
            if (!node2) {
              while (node2 = dom2.get(CARET_ID$1)) {
                removeCaretContainerNode(editor, node2, false);
              }
            }
          } else {
            removeCaretContainerNode(editor, node2, moveCaret2);
          }
        };
        var insertCaretContainerNode = function(editor, caretContainer, formatNode) {
          var dom2 = editor.dom, block = dom2.getParent(formatNode, curry(FormatUtils.isTextBlock, editor));
          if (block && dom2.isEmpty(block)) {
            formatNode.parentNode.replaceChild(caretContainer, formatNode);
          } else {
            PaddingBr.removeTrailingBr(Element.fromDom(formatNode));
            if (dom2.isEmpty(formatNode)) {
              formatNode.parentNode.replaceChild(caretContainer, formatNode);
            } else {
              dom2.insertAfter(caretContainer, formatNode);
            }
          }
        };
        var appendNode = function(parentNode, node2) {
          parentNode.appendChild(node2);
          return node2;
        };
        var insertFormatNodesIntoCaretContainer = function(formatNodes, caretContainer) {
          var innerMostFormatNode = foldr(formatNodes, function(parentNode, formatNode) {
            return appendNode(parentNode, formatNode.cloneNode(false));
          }, caretContainer);
          return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP$1));
        };
        var applyCaretFormat = function(editor, name2, vars) {
          var rng, caretContainer, textNode, offset, bookmark, container, text;
          var selection = editor.selection;
          rng = selection.getRng(true);
          offset = rng.startOffset;
          container = rng.startContainer;
          text = container.nodeValue;
          caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
          if (caretContainer) {
            textNode = findFirstTextNode(caretContainer);
          }
          var wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
          if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
            bookmark = selection.getBookmark();
            rng.collapse(true);
            rng = ExpandRange.expandRng(editor, rng, editor.formatter.get(name2));
            rng = SplitRange.split(rng);
            editor.formatter.apply(name2, vars, rng);
            selection.moveToBookmark(bookmark);
          } else {
            if (!caretContainer || textNode.nodeValue !== ZWSP$1) {
              caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom());
              textNode = caretContainer.firstChild;
              rng.insertNode(caretContainer);
              offset = 1;
              editor.formatter.apply(name2, vars, caretContainer);
            } else {
              editor.formatter.apply(name2, vars, caretContainer);
            }
            selection.setCursorLocation(textNode, offset);
          }
        };
        var removeCaretFormat = function(editor, name2, vars, similar) {
          var dom2 = editor.dom, selection = editor.selection;
          var container, offset, bookmark;
          var hasContentAfter, node2, formatNode;
          var parents2 = [], rng = selection.getRng();
          var caretContainer;
          container = rng.startContainer;
          offset = rng.startOffset;
          node2 = container;
          if (container.nodeType === 3) {
            if (offset !== container.nodeValue.length) {
              hasContentAfter = true;
            }
            node2 = node2.parentNode;
          }
          while (node2) {
            if (MatchFormat.matchNode(editor, node2, name2, vars, similar)) {
              formatNode = node2;
              break;
            }
            if (node2.nextSibling) {
              hasContentAfter = true;
            }
            parents2.push(node2);
            node2 = node2.parentNode;
          }
          if (!formatNode) {
            return;
          }
          if (hasContentAfter) {
            bookmark = selection.getBookmark();
            rng.collapse(true);
            var expandedRng = ExpandRange.expandRng(editor, rng, editor.formatter.get(name2), true);
            expandedRng = SplitRange.split(expandedRng);
            editor.formatter.remove(name2, vars, expandedRng);
            selection.moveToBookmark(bookmark);
          } else {
            caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
            var newCaretContainer = createCaretContainer(false).dom();
            var caretNode = insertFormatNodesIntoCaretContainer(parents2, newCaretContainer);
            if (caretContainer) {
              insertCaretContainerNode(editor, newCaretContainer, caretContainer);
            } else {
              insertCaretContainerNode(editor, newCaretContainer, formatNode);
            }
            removeCaretContainerNode(editor, caretContainer, false);
            selection.setCursorLocation(caretNode, 1);
            if (dom2.isEmpty(formatNode)) {
              dom2.remove(formatNode);
            }
          }
        };
        var disableCaretContainer = function(editor, keyCode) {
          var selection = editor.selection, body = editor.getBody();
          removeCaretContainer(editor, null, false);
          if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP$1) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
          }
          if (keyCode === 37 || keyCode === 39) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
          }
        };
        var setup$2 = function(editor) {
          editor.on("mouseup keydown", function(e) {
            disableCaretContainer(editor, e.keyCode);
          });
        };
        var replaceWithCaretFormat = function(targetNode, formatNodes) {
          var caretContainer = createCaretContainer(false);
          var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom());
          before(Element.fromDom(targetNode), caretContainer);
          remove$1(Element.fromDom(targetNode));
          return CaretPosition$1(innerMost, 0);
        };
        var isFormatElement = function(editor, element) {
          var inlineElements = editor.schema.getTextInlineElements();
          return inlineElements.hasOwnProperty(name(element)) && !isCaretNode(element.dom()) && !NodeType.isBogus(element.dom());
        };
        var isEmptyCaretFormatElement = function(element) {
          return isCaretNode(element.dom()) && isCaretContainerEmpty(element.dom());
        };
        var getParentInlines = function(rootElm, startElm) {
          var parents2 = Parents.parentsAndSelf(startElm, rootElm);
          return findIndex(parents2, isBlock).fold(constant(parents2), function(index) {
            return parents2.slice(0, index);
          });
        };
        var hasOnlyOneChild$1 = function(elm) {
          return children(elm).length === 1;
        };
        var deleteLastPosition = function(forward, editor, target, parentInlines) {
          var isFormatElement$1 = curry(isFormatElement, editor);
          var formatNodes = map(filter(parentInlines, isFormatElement$1), function(elm) {
            return elm.dom();
          });
          if (formatNodes.length === 0) {
            DeleteElement.deleteElement(editor, forward, target);
          } else {
            var pos = replaceWithCaretFormat(target.dom(), formatNodes);
            editor.selection.setRng(pos.toRange());
          }
        };
        var deleteCaret$1 = function(editor, forward) {
          var rootElm = Element.fromDom(editor.getBody());
          var startElm = Element.fromDom(editor.selection.getStart());
          var parentInlines = filter(getParentInlines(rootElm, startElm), hasOnlyOneChild$1);
          return last(parentInlines).map(function(target) {
            var fromPos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            if (DeleteUtils.willDeleteLastPositionInElement(forward, fromPos, target.dom()) && !isEmptyCaretFormatElement(target)) {
              deleteLastPosition(forward, editor, target, parentInlines);
              return true;
            } else {
              return false;
            }
          }).getOr(false);
        };
        var backspaceDelete$5 = function(editor, forward) {
          return editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : false;
        };
        var InlineFormatDelete = { backspaceDelete: backspaceDelete$5 };
        var getPos$1 = function(elm) {
          var x = 0, y = 0;
          var offsetParent = elm;
          while (offsetParent && offsetParent.nodeType) {
            x += offsetParent.offsetLeft || 0;
            y += offsetParent.offsetTop || 0;
            offsetParent = offsetParent.offsetParent;
          }
          return {
            x,
            y
          };
        };
        var fireScrollIntoViewEvent = function(editor, elm, alignToTop) {
          var scrollEvent = {
            elm,
            alignToTop
          };
          editor.fire("scrollIntoView", scrollEvent);
          return scrollEvent.isDefaultPrevented();
        };
        var scrollElementIntoView = function(editor, elm, alignToTop) {
          var y, viewPort;
          var dom2 = editor.dom;
          var root = dom2.getRoot();
          var viewPortY, viewPortH, offsetY = 0;
          if (fireScrollIntoViewEvent(editor, elm, alignToTop)) {
            return;
          }
          if (!NodeType.isElement(elm)) {
            return;
          }
          if (alignToTop === false) {
            offsetY = elm.offsetHeight;
          }
          if (root.nodeName !== "BODY") {
            var scrollContainer = editor.selection.getScrollContainer();
            if (scrollContainer) {
              y = getPos$1(elm).y - getPos$1(scrollContainer).y + offsetY;
              viewPortH = scrollContainer.clientHeight;
              viewPortY = scrollContainer.scrollTop;
              if (y < viewPortY || y + 25 > viewPortY + viewPortH) {
                scrollContainer.scrollTop = y < viewPortY ? y : y - viewPortH + 25;
              }
              return;
            }
          }
          viewPort = dom2.getViewPort(editor.getWin());
          y = dom2.getPos(elm).y + offsetY;
          viewPortY = viewPort.y;
          viewPortH = viewPort.h;
          if (y < viewPort.y || y + 25 > viewPortY + viewPortH) {
            editor.getWin().scrollTo(0, y < viewPortY ? y : y - viewPortH + 25);
          }
        };
        var getViewPortRect = function(editor) {
          if (editor.inline) {
            return editor.getBody().getBoundingClientRect();
          } else {
            var win = editor.getWin();
            return {
              left: 0,
              right: win.innerWidth,
              top: 0,
              bottom: win.innerHeight,
              width: win.innerWidth,
              height: win.innerHeight
            };
          }
        };
        var scrollBy = function(editor, dx, dy) {
          if (editor.inline) {
            editor.getBody().scrollLeft += dx;
            editor.getBody().scrollTop += dy;
          } else {
            editor.getWin().scrollBy(dx, dy);
          }
        };
        var scrollRangeIntoView = function(editor, rng) {
          head(CaretPosition.fromRangeStart(rng).getClientRects()).each(function(rngRect) {
            var bodyRect = getViewPortRect(editor);
            var overflow = getOverflow(bodyRect, rngRect);
            var margin = 4;
            var dx = overflow.x > 0 ? overflow.x + margin : overflow.x - margin;
            var dy = overflow.y > 0 ? overflow.y + margin : overflow.y - margin;
            scrollBy(editor, overflow.x !== 0 ? dx : 0, overflow.y !== 0 ? dy : 0);
          });
        };
        var ScrollIntoView = {
          scrollElementIntoView,
          scrollRangeIntoView
        };
        var isContentEditableTrue$2 = NodeType.isContentEditableTrue;
        var isContentEditableFalse$6 = NodeType.isContentEditableFalse;
        var showCaret = function(direction, editor, node2, before2, scrollIntoView) {
          return editor._selectionOverrides.showCaret(direction, node2, before2, scrollIntoView);
        };
        var getNodeRange = function(node2) {
          var rng = node2.ownerDocument.createRange();
          rng.selectNode(node2);
          return rng;
        };
        var selectNode = function(editor, node2) {
          var e = editor.fire("BeforeObjectSelected", { target: node2 });
          if (e.isDefaultPrevented()) {
            return null;
          }
          return getNodeRange(node2);
        };
        var renderCaretAtRange = function(editor, range2, scrollIntoView) {
          var normalizedRange = normalizeRange(1, editor.getBody(), range2);
          var caretPosition = CaretPosition$1.fromRangeStart(normalizedRange);
          var caretPositionNode = caretPosition.getNode();
          if (isContentEditableFalse$6(caretPositionNode)) {
            return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
          }
          var caretPositionBeforeNode = caretPosition.getNode(true);
          if (isContentEditableFalse$6(caretPositionBeforeNode)) {
            return showCaret(1, editor, caretPositionBeforeNode, false, false);
          }
          var ceRoot = editor.dom.getParent(caretPosition.getNode(), function(node2) {
            return isContentEditableFalse$6(node2) || isContentEditableTrue$2(node2);
          });
          if (isContentEditableFalse$6(ceRoot)) {
            return showCaret(1, editor, ceRoot, false, scrollIntoView);
          }
          return null;
        };
        var renderRangeCaret = function(editor, range2, scrollIntoView) {
          if (!range2 || !range2.collapsed) {
            return range2;
          }
          var caretRange = renderCaretAtRange(editor, range2, scrollIntoView);
          if (caretRange) {
            return caretRange;
          }
          return range2;
        };
        var moveToRange = function(editor, rng) {
          editor.selection.setRng(rng);
          ScrollIntoView.scrollRangeIntoView(editor, editor.selection.getRng());
        };
        var trimEmptyTextNode$1 = function(dom2, node2) {
          if (NodeType.isText(node2) && node2.data.length === 0) {
            dom2.remove(node2);
          }
        };
        var deleteContentAndShowCaret = function(editor, range2, node2, direction, forward, peekCaretPosition) {
          var caretRange = showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true);
          if (range2.collapsed) {
            var deleteRange2 = range2.cloneRange();
            if (forward) {
              deleteRange2.setEnd(caretRange.startContainer, caretRange.startOffset);
            } else {
              deleteRange2.setStart(caretRange.endContainer, caretRange.endOffset);
            }
            deleteRange2.deleteContents();
          } else {
            range2.deleteContents();
          }
          editor.selection.setRng(caretRange);
          trimEmptyTextNode$1(editor.dom, node2);
          return true;
        };
        var deleteCefBoundaryText = function(editor, forward) {
          var range2 = editor.selection.getRng();
          if (!NodeType.isText(range2.commonAncestorContainer)) {
            return false;
          }
          var direction = forward ? HDirection.Forwards : HDirection.Backwards;
          var caretWalker = CaretWalker(editor.getBody());
          var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
          var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
          var getNextPosFn = forward ? getNextVisualCaretPosition : getPrevVisualCaretPosition;
          var isBeforeContentEditableFalseFn = forward ? isBeforeContentEditableFalse : isAfterContentEditableFalse;
          var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
          var nextCaretPosition = InlineUtils.normalizePosition(forward, getNextPosFn(caretPosition));
          if (!nextCaretPosition) {
            return false;
          } else if (isBeforeContentEditableFalseFn(nextCaretPosition)) {
            return deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, nextCaretPosition);
          }
          var peekCaretPosition = getNextPosFn(nextCaretPosition);
          if (peekCaretPosition && isBeforeContentEditableFalseFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
              return deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, peekCaretPosition);
            }
          }
          return false;
        };
        var backspaceDelete$6 = function(editor, forward) {
          return deleteCefBoundaryText(editor, forward);
        };
        var CefBoundaryDelete = { backspaceDelete: backspaceDelete$6 };
        var nativeCommand = function(editor, command) {
          editor.getDoc().execCommand(command, false, null);
        };
        var deleteCommand = function(editor) {
          if (CefDelete.backspaceDelete(editor, false)) {
            return;
          } else if (CefBoundaryDelete.backspaceDelete(editor, false)) {
            return;
          } else if (InlineBoundaryDelete.backspaceDelete(editor, false)) {
            return;
          } else if (BlockBoundaryDelete.backspaceDelete(editor, false)) {
            return;
          } else if (TableDelete.backspaceDelete(editor)) {
            return;
          } else if (BlockRangeDelete.backspaceDelete(editor, false)) {
            return;
          } else if (InlineFormatDelete.backspaceDelete(editor, false)) {
            return;
          } else {
            nativeCommand(editor, "Delete");
            DeleteUtils.paddEmptyBody(editor);
          }
        };
        var forwardDeleteCommand = function(editor) {
          if (CefDelete.backspaceDelete(editor, true)) {
            return;
          } else if (CefBoundaryDelete.backspaceDelete(editor, true)) {
            return;
          } else if (InlineBoundaryDelete.backspaceDelete(editor, true)) {
            return;
          } else if (BlockBoundaryDelete.backspaceDelete(editor, true)) {
            return;
          } else if (TableDelete.backspaceDelete(editor)) {
            return;
          } else if (BlockRangeDelete.backspaceDelete(editor, true)) {
            return;
          } else if (InlineFormatDelete.backspaceDelete(editor, true)) {
            return;
          } else {
            nativeCommand(editor, "ForwardDelete");
          }
        };
        var DeleteCommands = {
          deleteCommand,
          forwardDeleteCommand
        };
        var getSpecifiedFontProp = function(propName, rootElm, elm) {
          var getProperty = function(elm2) {
            return getRaw(elm2, propName);
          };
          var isRoot = function(elm2) {
            return eq(Element.fromDom(rootElm), elm2);
          };
          return closest(Element.fromDom(elm), function(elm2) {
            return getProperty(elm2).isSome();
          }, isRoot).bind(getProperty);
        };
        var round$1 = function(number, precision) {
          var factor = Math.pow(10, precision);
          return Math.round(number * factor) / factor;
        };
        var toPt = function(fontSize, precision) {
          if (/[0-9.]+px$/.test(fontSize)) {
            return round$1(parseInt(fontSize, 10) * 72 / 96, precision || 0) + "pt";
          }
          return fontSize;
        };
        var normalizeFontFamily = function(fontFamily) {
          return fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
        };
        var getComputedFontProp = function(propName, elm) {
          return Option.from(DOMUtils$1.DOM.getStyle(elm, propName, true));
        };
        var getFontProp = function(propName) {
          return function(rootElm, elm) {
            return Option.from(elm).map(Element.fromDom).filter(isElement).bind(function(element) {
              return getSpecifiedFontProp(propName, rootElm, element.dom()).or(getComputedFontProp(propName, element.dom()));
            }).getOr("");
          };
        };
        var FontInfo = {
          getFontSize: getFontProp("font-size"),
          getFontFamily: compose(normalizeFontFamily, getFontProp("font-family")),
          toPt
        };
        var findFirstCaretElement = function(editor) {
          return CaretFinder.firstPositionIn(editor.getBody()).map(function(caret) {
            var container = caret.container();
            return NodeType.isText(container) ? container.parentNode : container;
          });
        };
        var isRangeAtStartOfNode = function(rng, root) {
          return rng.startContainer === root && rng.startOffset === 0;
        };
        var getCaretElement = function(editor) {
          return Option.from(editor.selection.getRng()).bind(function(rng) {
            var root = editor.getBody();
            return isRangeAtStartOfNode(rng, root) ? Option.none() : Option.from(editor.selection.getStart(true));
          });
        };
        var fromFontSizeNumber = function(editor, value2) {
          if (/^[0-9\.]+$/.test(value2)) {
            var fontSizeNumber = parseInt(value2, 10);
            if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
              var fontSizes = Settings.getFontStyleValues(editor);
              var fontClasses = Settings.getFontSizeClasses(editor);
              if (fontClasses) {
                return fontClasses[fontSizeNumber - 1] || value2;
              } else {
                return fontSizes[fontSizeNumber - 1] || value2;
              }
            } else {
              return value2;
            }
          } else {
            return value2;
          }
        };
        var fontNameAction = function(editor, value2) {
          editor.formatter.toggle("fontname", { value: fromFontSizeNumber(editor, value2) });
          editor.nodeChanged();
        };
        var fontNameQuery = function(editor) {
          return getCaretElement(editor).fold(function() {
            return findFirstCaretElement(editor).map(function(caretElement) {
              return FontInfo.getFontFamily(editor.getBody(), caretElement);
            }).getOr("");
          }, function(caretElement) {
            return FontInfo.getFontFamily(editor.getBody(), caretElement);
          });
        };
        var fontSizeAction = function(editor, value2) {
          editor.formatter.toggle("fontsize", { value: fromFontSizeNumber(editor, value2) });
          editor.nodeChanged();
        };
        var fontSizeQuery = function(editor) {
          return getCaretElement(editor).fold(function() {
            return findFirstCaretElement(editor).map(function(caretElement) {
              return FontInfo.getFontSize(editor.getBody(), caretElement);
            }).getOr("");
          }, function(caretElement) {
            return FontInfo.getFontSize(editor.getBody(), caretElement);
          });
        };
        var isEq$3 = function(rng1, rng2) {
          return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
        };
        var RangeCompare = { isEq: isEq$3 };
        var findParent = function(node2, rootNode, predicate) {
          while (node2 && node2 !== rootNode) {
            if (predicate(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var hasParent = function(node2, rootNode, predicate) {
          return findParent(node2, rootNode, predicate) !== null;
        };
        var hasParentWithName = function(node2, rootNode, name2) {
          return hasParent(node2, rootNode, function(node3) {
            return node3.nodeName === name2;
          });
        };
        var isTable$2 = function(node2) {
          return node2 && node2.nodeName === "TABLE";
        };
        var isTableCell$3 = function(node2) {
          return node2 && /^(TD|TH|CAPTION)$/.test(node2.nodeName);
        };
        var isCeFalseCaretContainer = function(node2, rootNode) {
          return isCaretContainer(node2) && hasParent(node2, rootNode, isCaretNode) === false;
        };
        var hasBrBeforeAfter = function(dom2, node2, left) {
          var walker = new TreeWalker(node2, dom2.getParent(node2.parentNode, dom2.isBlock) || dom2.getRoot());
          while (node2 = walker[left ? "prev" : "next"]()) {
            if (NodeType.isBr(node2)) {
              return true;
            }
          }
        };
        var isPrevNode = function(node2, name2) {
          return node2.previousSibling && node2.previousSibling.nodeName === name2;
        };
        var hasContentEditableFalseParent = function(body, node2) {
          while (node2 && node2 !== body) {
            if (NodeType.isContentEditableFalse(node2)) {
              return true;
            }
            node2 = node2.parentNode;
          }
          return false;
        };
        var findTextNodeRelative = function(dom2, isAfterNode, collapsed, left, startNode) {
          var walker, lastInlineElement, parentBlockContainer;
          var body = dom2.getRoot();
          var node2;
          var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          parentBlockContainer = dom2.getParent(startNode.parentNode, dom2.isBlock) || body;
          if (left && NodeType.isBr(startNode) && isAfterNode && dom2.isEmpty(parentBlockContainer)) {
            return Option.some(CaretPosition(startNode.parentNode, dom2.nodeIndex(startNode)));
          }
          walker = new TreeWalker(startNode, parentBlockContainer);
          while (node2 = walker[left ? "prev" : "next"]()) {
            if (dom2.getContentEditableParent(node2) === "false" || isCeFalseCaretContainer(node2, body)) {
              return Option.none();
            }
            if (NodeType.isText(node2) && node2.nodeValue.length > 0) {
              if (hasParentWithName(node2, body, "A") === false) {
                return Option.some(CaretPosition(node2, left ? node2.nodeValue.length : 0));
              }
              return Option.none();
            }
            if (dom2.isBlock(node2) || nonEmptyElementsMap[node2.nodeName.toLowerCase()]) {
              return Option.none();
            }
            lastInlineElement = node2;
          }
          if (collapsed && lastInlineElement) {
            return Option.some(CaretPosition(lastInlineElement, 0));
          }
          return Option.none();
        };
        var normalizeEndPoint = function(dom2, collapsed, start2, rng) {
          var container, offset, walker;
          var body = dom2.getRoot();
          var node2, nonEmptyElementsMap;
          var directionLeft, isAfterNode, normalized = false;
          container = rng[(start2 ? "start" : "end") + "Container"];
          offset = rng[(start2 ? "start" : "end") + "Offset"];
          isAfterNode = NodeType.isElement(container) && offset === container.childNodes.length;
          nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          directionLeft = start2;
          if (isCaretContainer(container)) {
            return Option.none();
          }
          if (NodeType.isElement(container) && offset > container.childNodes.length - 1) {
            directionLeft = false;
          }
          if (NodeType.isDocument(container)) {
            container = body;
            offset = 0;
          }
          if (container === body) {
            if (directionLeft) {
              node2 = container.childNodes[offset > 0 ? offset - 1 : 0];
              if (node2) {
                if (isCaretContainer(node2)) {
                  return Option.none();
                }
                if (nonEmptyElementsMap[node2.nodeName] || isTable$2(node2)) {
                  return Option.none();
                }
              }
            }
            if (container.hasChildNodes()) {
              offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
              container = container.childNodes[offset];
              offset = NodeType.isText(container) && isAfterNode ? container.data.length : 0;
              if (!collapsed && container === body.lastChild && isTable$2(container)) {
                return Option.none();
              }
              if (hasContentEditableFalseParent(body, container) || isCaretContainer(container)) {
                return Option.none();
              }
              if (container.hasChildNodes() && isTable$2(container) === false) {
                node2 = container;
                walker = new TreeWalker(container, body);
                do {
                  if (NodeType.isContentEditableFalse(node2) || isCaretContainer(node2)) {
                    normalized = false;
                    break;
                  }
                  if (NodeType.isText(node2) && node2.nodeValue.length > 0) {
                    offset = directionLeft ? 0 : node2.nodeValue.length;
                    container = node2;
                    normalized = true;
                    break;
                  }
                  if (nonEmptyElementsMap[node2.nodeName.toLowerCase()] && !isTableCell$3(node2)) {
                    offset = dom2.nodeIndex(node2);
                    container = node2.parentNode;
                    if (!directionLeft) {
                      offset++;
                    }
                    normalized = true;
                    break;
                  }
                } while (node2 = directionLeft ? walker.next() : walker.prev());
              }
            }
          }
          if (collapsed) {
            if (NodeType.isText(container) && offset === 0) {
              findTextNodeRelative(dom2, isAfterNode, collapsed, true, container).each(function(pos) {
                container = pos.container();
                offset = pos.offset();
                normalized = true;
              });
            }
            if (NodeType.isElement(container)) {
              node2 = container.childNodes[offset];
              if (!node2) {
                node2 = container.childNodes[offset - 1];
              }
              if (node2 && NodeType.isBr(node2) && !isPrevNode(node2, "A") && !hasBrBeforeAfter(dom2, node2, false) && !hasBrBeforeAfter(dom2, node2, true)) {
                findTextNodeRelative(dom2, isAfterNode, collapsed, true, node2).each(function(pos) {
                  container = pos.container();
                  offset = pos.offset();
                  normalized = true;
                });
              }
            }
          }
          if (directionLeft && !collapsed && NodeType.isText(container) && offset === container.nodeValue.length) {
            findTextNodeRelative(dom2, isAfterNode, collapsed, false, container).each(function(pos) {
              container = pos.container();
              offset = pos.offset();
              normalized = true;
            });
          }
          return normalized ? Option.some(CaretPosition(container, offset)) : Option.none();
        };
        var normalize$2 = function(dom2, rng) {
          var collapsed = rng.collapsed, normRng = rng.cloneRange();
          var startPos = CaretPosition.fromRangeStart(rng);
          normalizeEndPoint(dom2, collapsed, true, normRng).each(function(pos) {
            if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
              normRng.setStart(pos.container(), pos.offset());
            }
          });
          if (!collapsed) {
            normalizeEndPoint(dom2, collapsed, false, normRng).each(function(pos) {
              normRng.setEnd(pos.container(), pos.offset());
            });
          }
          if (collapsed) {
            normRng.collapse(true);
          }
          return RangeCompare.isEq(rng, normRng) ? Option.none() : Option.some(normRng);
        };
        var NormalizeRange = { normalize: normalize$2 };
        var hasRightSideContent = function(schema, container, parentBlock) {
          var walker = new TreeWalker(container, parentBlock);
          var node2;
          var nonEmptyElementsMap = schema.getNonEmptyElements();
          while (node2 = walker.next()) {
            if (nonEmptyElementsMap[node2.nodeName.toLowerCase()] || node2.length > 0) {
              return true;
            }
          }
        };
        var scrollToBr = function(dom2, selection, brElm) {
          var marker = dom2.create("span", {}, "&nbsp;");
          brElm.parentNode.insertBefore(marker, brElm);
          selection.scrollIntoView(marker);
          dom2.remove(marker);
        };
        var moveSelectionToBr = function(dom2, selection, brElm, extraBr) {
          var rng = dom2.createRng();
          if (!extraBr) {
            rng.setStartAfter(brElm);
            rng.setEndAfter(brElm);
          } else {
            rng.setStartBefore(brElm);
            rng.setEndBefore(brElm);
          }
          selection.setRng(rng);
        };
        var insertBrAtCaret = function(editor, evt) {
          var selection = editor.selection;
          var dom2 = editor.dom;
          var rng = selection.getRng();
          var brElm;
          var extraBr;
          NormalizeRange.normalize(dom2, rng).each(function(normRng) {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
          });
          var offset = rng.startOffset;
          var container = rng.startContainer;
          if (container.nodeType === 1 && container.hasChildNodes()) {
            var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && container.nodeType === 3) {
              offset = container.nodeValue.length;
            } else {
              offset = 0;
            }
          }
          var parentBlock = dom2.getParent(container, dom2.isBlock);
          var containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
          var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
          var isControlKey = evt && evt.ctrlKey;
          if (containerBlockName === "LI" && !isControlKey) {
            parentBlock = containerBlock;
          }
          if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {
            if (!hasRightSideContent(editor.schema, container, parentBlock)) {
              brElm = dom2.create("br");
              rng.insertNode(brElm);
              rng.setStartAfter(brElm);
              rng.setEndAfter(brElm);
              extraBr = true;
            }
          }
          brElm = dom2.create("br");
          rangeInsertNode(dom2, rng, brElm);
          scrollToBr(dom2, selection, brElm);
          moveSelectionToBr(dom2, selection, brElm, extraBr);
          editor.undoManager.add();
        };
        var insertBrBefore = function(editor, inline) {
          var br = Element.fromTag("br");
          before(Element.fromDom(inline), br);
          editor.undoManager.add();
        };
        var insertBrAfter = function(editor, inline) {
          if (!hasBrAfter(editor.getBody(), inline)) {
            after(Element.fromDom(inline), Element.fromTag("br"));
          }
          var br = Element.fromTag("br");
          after(Element.fromDom(inline), br);
          scrollToBr(editor.dom, editor.selection, br.dom());
          moveSelectionToBr(editor.dom, editor.selection, br.dom(), false);
          editor.undoManager.add();
        };
        var isBeforeBr$1 = function(pos) {
          return NodeType.isBr(pos.getNode());
        };
        var hasBrAfter = function(rootNode, startNode) {
          if (isBeforeBr$1(CaretPosition$1.after(startNode))) {
            return true;
          } else {
            return CaretFinder.nextPosition(rootNode, CaretPosition$1.after(startNode)).map(function(pos) {
              return NodeType.isBr(pos.getNode());
            }).getOr(false);
          }
        };
        var isAnchorLink = function(elm) {
          return elm && elm.nodeName === "A" && "href" in elm;
        };
        var isInsideAnchor = function(location) {
          return location.fold(constant(false), isAnchorLink, isAnchorLink, constant(false));
        };
        var readInlineAnchorLocation = function(editor) {
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          var position = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          return BoundaryLocation.readLocation(isInlineTarget2, editor.getBody(), position).filter(isInsideAnchor);
        };
        var insertBrOutsideAnchor = function(editor, location) {
          location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
        };
        var insert = function(editor, evt) {
          var anchorLocation = readInlineAnchorLocation(editor);
          if (anchorLocation.isSome()) {
            anchorLocation.each(curry(insertBrOutsideAnchor, editor));
          } else {
            insertBrAtCaret(editor, evt);
          }
        };
        var InsertBr = { insert };
        var create$3 = Immutable("start", "soffset", "finish", "foffset");
        var SimRange = { create: create$3 };
        var adt = Adt.generate([
          { before: ["element"] },
          {
            on: [
              "element",
              "offset"
            ]
          },
          { after: ["element"] }
        ]);
        var cata = function(subject, onBefore, onOn, onAfter) {
          return subject.fold(onBefore, onOn, onAfter);
        };
        var getStart = function(situ) {
          return situ.fold(identity, identity, identity);
        };
        var before$4 = adt.before;
        var on = adt.on;
        var after$3 = adt.after;
        var Situ = {
          before: before$4,
          on,
          after: after$3,
          cata,
          getStart
        };
        var adt$1 = Adt.generate([
          { domRange: ["rng"] },
          {
            relative: [
              "startSitu",
              "finishSitu"
            ]
          },
          {
            exact: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          }
        ]);
        var exactFromRange = function(simRange) {
          return adt$1.exact(simRange.start(), simRange.soffset(), simRange.finish(), simRange.foffset());
        };
        var getStart$1 = function(selection) {
          return selection.match({
            domRange: function(rng) {
              return Element.fromDom(rng.startContainer);
            },
            relative: function(startSitu, finishSitu) {
              return Situ.getStart(startSitu);
            },
            exact: function(start2, soffset, finish, foffset) {
              return start2;
            }
          });
        };
        var domRange = adt$1.domRange;
        var relative = adt$1.relative;
        var exact = adt$1.exact;
        var getWin = function(selection) {
          var start2 = getStart$1(selection);
          return defaultView(start2);
        };
        var range = SimRange.create;
        var Selection = {
          domRange,
          relative,
          exact,
          exactFromRange,
          getWin,
          range
        };
        var browser$3 = PlatformDetection$1.detect().browser;
        var clamp = function(offset, element) {
          var max2 = isText(element) ? get$4(element).length : children(element).length + 1;
          if (offset > max2) {
            return max2;
          } else if (offset < 0) {
            return 0;
          }
          return offset;
        };
        var normalizeRng = function(rng) {
          return Selection.range(rng.start(), clamp(rng.soffset(), rng.start()), rng.finish(), clamp(rng.foffset(), rng.finish()));
        };
        var isOrContains = function(root, elm) {
          return !NodeType.isRestrictedNode(elm.dom()) && (contains$3(root, elm) || eq(root, elm));
        };
        var isRngInRoot = function(root) {
          return function(rng) {
            return isOrContains(root, rng.start()) && isOrContains(root, rng.finish());
          };
        };
        var shouldStore = function(editor) {
          return editor.inline === true || browser$3.isIE();
        };
        var nativeRangeToSelectionRange = function(r) {
          return Selection.range(Element.fromDom(r.startContainer), r.startOffset, Element.fromDom(r.endContainer), r.endOffset);
        };
        var readRange = function(win) {
          var selection = win.getSelection();
          var rng = !selection || selection.rangeCount === 0 ? Option.none() : Option.from(selection.getRangeAt(0));
          return rng.map(nativeRangeToSelectionRange);
        };
        var getBookmark$2 = function(root) {
          var win = defaultView(root);
          return readRange(win.dom()).filter(isRngInRoot(root));
        };
        var validate = function(root, bookmark) {
          return Option.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
        };
        var bookmarkToNativeRng = function(bookmark) {
          var rng = domGlobals.document.createRange();
          try {
            rng.setStart(bookmark.start().dom(), bookmark.soffset());
            rng.setEnd(bookmark.finish().dom(), bookmark.foffset());
            return Option.some(rng);
          } catch (_) {
            return Option.none();
          }
        };
        var store = function(editor) {
          var newBookmark = shouldStore(editor) ? getBookmark$2(Element.fromDom(editor.getBody())) : Option.none();
          editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
        };
        var storeNative = function(editor, rng) {
          var root = Element.fromDom(editor.getBody());
          var range2 = shouldStore(editor) ? Option.from(rng) : Option.none();
          var newBookmark = range2.map(nativeRangeToSelectionRange).filter(isRngInRoot(root));
          editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
        };
        var getRng = function(editor) {
          var bookmark = editor.bookmark ? editor.bookmark : Option.none();
          return bookmark.bind(curry(validate, Element.fromDom(editor.getBody()))).bind(bookmarkToNativeRng);
        };
        var restore = function(editor) {
          getRng(editor).each(function(rng) {
            editor.selection.setRng(rng);
          });
        };
        var SelectionBookmark = {
          store,
          storeNative,
          readRange,
          restore,
          getRng,
          getBookmark: getBookmark$2,
          validate
        };
        var indentElement = function(dom2, command, useMargin, value2, unit, element) {
          if (dom2.getContentEditable(element) === "false") {
            return;
          }
          var indentStyleName = useMargin ? "margin" : "padding";
          indentStyleName = element.nodeName === "TABLE" ? "margin" : indentStyleName;
          indentStyleName += dom2.getStyle(element, "direction", true) === "rtl" ? "Right" : "Left";
          if (command === "outdent") {
            var styleValue = Math.max(0, parseInt(element.style[indentStyleName] || 0, 10) - value2);
            dom2.setStyle(element, indentStyleName, styleValue ? styleValue + unit : "");
          } else {
            var styleValue = parseInt(element.style[indentStyleName] || 0, 10) + value2 + unit;
            dom2.setStyle(element, indentStyleName, styleValue);
          }
        };
        var isListComponent = function(el) {
          return isList(el) || isListItem(el);
        };
        var parentIsListComponent = function(el) {
          return parent(el).map(isListComponent).getOr(false);
        };
        var getBlocksToIndent = function(editor) {
          return filter(map(editor.selection.getSelectedBlocks(), Element.fromDom), function(el) {
            return !isListComponent(el) && !parentIsListComponent(el);
          });
        };
        var handle = function(editor, command) {
          var settings = editor.settings, dom2 = editor.dom, selection = editor.selection, formatter = editor.formatter;
          var indentUnit = /[a-z%]+$/i.exec(settings.indentation)[0];
          var indentValue = parseInt(settings.indentation, 10);
          var useMargin = editor.getParam("indent_use_margin", false);
          if (!editor.queryCommandState("InsertUnorderedList") && !editor.queryCommandState("InsertOrderedList")) {
            if (!settings.forced_root_block && !dom2.getParent(selection.getNode(), dom2.isBlock)) {
              formatter.apply("div");
            }
          }
          each(getBlocksToIndent(editor), function(block) {
            indentElement(dom2, command, useMargin, indentValue, indentUnit, block.dom());
          });
        };
        var each$a = Tools.each, extend$2 = Tools.extend;
        var map$3 = Tools.map, inArray$2 = Tools.inArray;
        function EditorCommands(editor) {
          var dom2, selection, formatter;
          var commands = {
            state: {},
            exec: {},
            value: {}
          };
          var settings = editor.settings, bookmark;
          editor.on("PreInit", function() {
            dom2 = editor.dom;
            selection = editor.selection;
            settings = editor.settings;
            formatter = editor.formatter;
          });
          var execCommand = function(command, ui, value2, args) {
            var func, customCommand, state = false;
            if (editor.removed) {
              return;
            }
            if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
              editor.focus();
            } else {
              SelectionBookmark.restore(editor);
            }
            args = editor.fire("BeforeExecCommand", {
              command,
              ui,
              value: value2
            });
            if (args.isDefaultPrevented()) {
              return false;
            }
            customCommand = command.toLowerCase();
            if (func = commands.exec[customCommand]) {
              func(customCommand, ui, value2);
              editor.fire("ExecCommand", {
                command,
                ui,
                value: value2
              });
              return true;
            }
            each$a(editor.plugins, function(p) {
              if (p.execCommand && p.execCommand(command, ui, value2)) {
                editor.fire("ExecCommand", {
                  command,
                  ui,
                  value: value2
                });
                state = true;
                return false;
              }
            });
            if (state) {
              return state;
            }
            if (editor.theme && editor.theme.execCommand && editor.theme.execCommand(command, ui, value2)) {
              editor.fire("ExecCommand", {
                command,
                ui,
                value: value2
              });
              return true;
            }
            try {
              state = editor.getDoc().execCommand(command, ui, value2);
            } catch (ex) {
            }
            if (state) {
              editor.fire("ExecCommand", {
                command,
                ui,
                value: value2
              });
              return true;
            }
            return false;
          };
          var queryCommandState = function(command) {
            var func;
            if (editor.quirks.isHidden() || editor.removed) {
              return;
            }
            command = command.toLowerCase();
            if (func = commands.state[command]) {
              return func(command);
            }
            try {
              return editor.getDoc().queryCommandState(command);
            } catch (ex) {
            }
            return false;
          };
          var queryCommandValue = function(command) {
            var func;
            if (editor.quirks.isHidden() || editor.removed) {
              return;
            }
            command = command.toLowerCase();
            if (func = commands.value[command]) {
              return func(command);
            }
            try {
              return editor.getDoc().queryCommandValue(command);
            } catch (ex) {
            }
          };
          var addCommands = function(commandList, type2) {
            type2 = type2 || "exec";
            each$a(commandList, function(callback, command) {
              each$a(command.toLowerCase().split(","), function(command2) {
                commands[type2][command2] = callback;
              });
            });
          };
          var addCommand = function(command, callback, scope) {
            command = command.toLowerCase();
            commands.exec[command] = function(command2, ui, value2, args) {
              return callback.call(scope || editor, ui, value2, args);
            };
          };
          var queryCommandSupported = function(command) {
            command = command.toLowerCase();
            if (commands.exec[command]) {
              return true;
            }
            try {
              return editor.getDoc().queryCommandSupported(command);
            } catch (ex) {
            }
            return false;
          };
          var addQueryStateHandler = function(command, callback, scope) {
            command = command.toLowerCase();
            commands.state[command] = function() {
              return callback.call(scope || editor);
            };
          };
          var addQueryValueHandler = function(command, callback, scope) {
            command = command.toLowerCase();
            commands.value[command] = function() {
              return callback.call(scope || editor);
            };
          };
          var hasCustomCommand = function(command) {
            command = command.toLowerCase();
            return !!commands.exec[command];
          };
          extend$2(this, {
            execCommand,
            queryCommandState,
            queryCommandValue,
            queryCommandSupported,
            addCommands,
            addCommand,
            addQueryStateHandler,
            addQueryValueHandler,
            hasCustomCommand
          });
          var execNativeCommand = function(command, ui, value2) {
            if (ui === void 0) {
              ui = false;
            }
            if (value2 === void 0) {
              value2 = null;
            }
            return editor.getDoc().execCommand(command, ui, value2);
          };
          var isFormatMatch = function(name2) {
            return formatter.match(name2);
          };
          var toggleFormat = function(name2, value2) {
            formatter.toggle(name2, value2 ? { value: value2 } : void 0);
            editor.nodeChanged();
          };
          var storeSelection = function(type2) {
            bookmark = selection.getBookmark(type2);
          };
          var restoreSelection = function() {
            selection.moveToBookmark(bookmark);
          };
          addCommands({
            "mceResetDesignMode,mceBeginUndoLevel": function() {
            },
            "mceEndUndoLevel,mceAddUndoLevel": function() {
              editor.undoManager.add();
            },
            "Cut,Copy,Paste": function(command) {
              var doc2 = editor.getDoc();
              var failed;
              try {
                execNativeCommand(command);
              } catch (ex) {
                failed = true;
              }
              if (command === "paste" && !doc2.queryCommandEnabled(command)) {
                failed = true;
              }
              if (failed || !doc2.queryCommandSupported(command)) {
                var msg = editor.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
                if (Env.mac) {
                  msg = msg.replace(/Ctrl\+/g, "\u2318+");
                }
                editor.notificationManager.open({
                  text: msg,
                  type: "error"
                });
              }
            },
            "unlink": function() {
              if (selection.isCollapsed()) {
                var elm = editor.dom.getParent(editor.selection.getStart(), "a");
                if (elm) {
                  editor.dom.remove(elm, true);
                }
                return;
              }
              formatter.remove("link");
            },
            "JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone": function(command) {
              var align = command.substring(7);
              if (align === "full") {
                align = "justify";
              }
              each$a("left,center,right,justify".split(","), function(name2) {
                if (align !== name2) {
                  formatter.remove("align" + name2);
                }
              });
              if (align !== "none") {
                toggleFormat("align" + align);
              }
            },
            "InsertUnorderedList,InsertOrderedList": function(command) {
              var listElm, listParent;
              execNativeCommand(command);
              listElm = dom2.getParent(selection.getNode(), "ol,ul");
              if (listElm) {
                listParent = listElm.parentNode;
                if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
                  storeSelection();
                  dom2.split(listParent, listElm);
                  restoreSelection();
                }
              }
            },
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
              toggleFormat(command);
            },
            "ForeColor,HiliteColor": function(command, ui, value2) {
              toggleFormat(command, value2);
            },
            "FontName": function(command, ui, value2) {
              fontNameAction(editor, value2);
            },
            "FontSize": function(command, ui, value2) {
              fontSizeAction(editor, value2);
            },
            "RemoveFormat": function(command) {
              formatter.remove(command);
            },
            "mceBlockQuote": function() {
              toggleFormat("blockquote");
            },
            "FormatBlock": function(command, ui, value2) {
              return toggleFormat(value2 || "p");
            },
            "mceCleanup": function() {
              var bookmark2 = selection.getBookmark();
              editor.setContent(editor.getContent());
              selection.moveToBookmark(bookmark2);
            },
            "mceRemoveNode": function(command, ui, value2) {
              var node2 = value2 || selection.getNode();
              if (node2 !== editor.getBody()) {
                storeSelection();
                editor.dom.remove(node2, true);
                restoreSelection();
              }
            },
            "mceSelectNodeDepth": function(command, ui, value2) {
              var counter = 0;
              dom2.getParent(selection.getNode(), function(node2) {
                if (node2.nodeType === 1 && counter++ === value2) {
                  selection.select(node2);
                  return false;
                }
              }, editor.getBody());
            },
            "mceSelectNode": function(command, ui, value2) {
              selection.select(value2);
            },
            "mceInsertContent": function(command, ui, value2) {
              InsertContent.insertAtCaret(editor, value2);
            },
            "mceInsertRawHTML": function(command, ui, value2) {
              selection.setContent("tiny_mce_marker");
              var content = editor.getContent();
              editor.setContent(content.replace(/tiny_mce_marker/g, function() {
                return value2;
              }));
            },
            "mceToggleFormat": function(command, ui, value2) {
              toggleFormat(value2);
            },
            "mceSetContent": function(command, ui, value2) {
              editor.setContent(value2);
            },
            "Indent,Outdent": function(command) {
              handle(editor, command);
            },
            "mceRepaint": function() {
            },
            "InsertHorizontalRule": function() {
              editor.execCommand("mceInsertContent", false, "<hr />");
            },
            "mceToggleVisualAid": function() {
              editor.hasVisual = !editor.hasVisual;
              editor.addVisual();
            },
            "mceReplaceContent": function(command, ui, value2) {
              editor.execCommand("mceInsertContent", false, value2.replace(/\{\$selection\}/g, selection.getContent({ format: "text" })));
            },
            "mceInsertLink": function(command, ui, value2) {
              var anchor;
              if (typeof value2 === "string") {
                value2 = { href: value2 };
              }
              anchor = dom2.getParent(selection.getNode(), "a");
              value2.href = value2.href.replace(" ", "%20");
              if (!anchor || !value2.href) {
                formatter.remove("link");
              }
              if (value2.href) {
                formatter.apply("link", value2, anchor);
              }
            },
            "selectAll": function() {
              var editingHost = dom2.getParent(selection.getStart(), NodeType.isContentEditableTrue);
              if (editingHost) {
                var rng = dom2.createRng();
                rng.selectNodeContents(editingHost);
                selection.setRng(rng);
              }
            },
            "delete": function() {
              DeleteCommands.deleteCommand(editor);
            },
            "forwardDelete": function() {
              DeleteCommands.forwardDeleteCommand(editor);
            },
            "mceNewDocument": function() {
              editor.setContent("");
            },
            "InsertLineBreak": function(command, ui, value2) {
              InsertBr.insert(editor, value2);
              return true;
            }
          });
          var alignStates = function(name2) {
            return function() {
              var nodes = selection.isCollapsed() ? [dom2.getParent(selection.getNode(), dom2.isBlock)] : selection.getSelectedBlocks();
              var matches2 = map$3(nodes, function(node2) {
                return !!formatter.matchNode(node2, name2);
              });
              return inArray$2(matches2, true) !== -1;
            };
          };
          addCommands({
            "JustifyLeft": alignStates("alignleft"),
            "JustifyCenter": alignStates("aligncenter"),
            "JustifyRight": alignStates("alignright"),
            "JustifyFull": alignStates("alignjustify"),
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
              return isFormatMatch(command);
            },
            "mceBlockQuote": function() {
              return isFormatMatch("blockquote");
            },
            "Outdent": function() {
              var node2;
              if (settings.inline_styles) {
                if ((node2 = dom2.getParent(selection.getStart(), dom2.isBlock)) && parseInt(node2.style.paddingLeft, 10) > 0) {
                  return true;
                }
                if ((node2 = dom2.getParent(selection.getEnd(), dom2.isBlock)) && parseInt(node2.style.paddingLeft, 10) > 0) {
                  return true;
                }
              }
              return queryCommandState("InsertUnorderedList") || queryCommandState("InsertOrderedList") || !settings.inline_styles && !!dom2.getParent(selection.getNode(), "BLOCKQUOTE");
            },
            "InsertUnorderedList,InsertOrderedList": function(command) {
              var list = dom2.getParent(selection.getNode(), "ul,ol");
              return list && (command === "insertunorderedlist" && list.tagName === "UL" || command === "insertorderedlist" && list.tagName === "OL");
            }
          }, "state");
          addCommands({
            Undo: function() {
              editor.undoManager.undo();
            },
            Redo: function() {
              editor.undoManager.redo();
            }
          });
          addQueryValueHandler("FontName", function() {
            return fontNameQuery(editor);
          }, this);
          addQueryValueHandler("FontSize", function() {
            return fontSizeQuery(editor);
          }, this);
        }
        var nativeEvents = Tools.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend", " ");
        var Dispatcher = function(settings) {
          var self2 = this;
          var scope, bindings = {}, toggleEvent;
          var returnFalse2 = function() {
            return false;
          };
          var returnTrue2 = function() {
            return true;
          };
          settings = settings || {};
          scope = settings.scope || self2;
          toggleEvent = settings.toggleEvent || returnFalse2;
          var fire = function(name2, args) {
            var handlers, i2, l, callback;
            name2 = name2.toLowerCase();
            args = args || {};
            args.type = name2;
            if (!args.target) {
              args.target = scope;
            }
            if (!args.preventDefault) {
              args.preventDefault = function() {
                args.isDefaultPrevented = returnTrue2;
              };
              args.stopPropagation = function() {
                args.isPropagationStopped = returnTrue2;
              };
              args.stopImmediatePropagation = function() {
                args.isImmediatePropagationStopped = returnTrue2;
              };
              args.isDefaultPrevented = returnFalse2;
              args.isPropagationStopped = returnFalse2;
              args.isImmediatePropagationStopped = returnFalse2;
            }
            if (settings.beforeFire) {
              settings.beforeFire(args);
            }
            handlers = bindings[name2];
            if (handlers) {
              for (i2 = 0, l = handlers.length; i2 < l; i2++) {
                callback = handlers[i2];
                if (callback.once) {
                  off(name2, callback.func);
                }
                if (args.isImmediatePropagationStopped()) {
                  args.stopPropagation();
                  return args;
                }
                if (callback.func.call(scope, args) === false) {
                  args.preventDefault();
                  return args;
                }
              }
            }
            return args;
          };
          var on2 = function(name2, callback, prepend2, extra) {
            var handlers, names, i2;
            if (callback === false) {
              callback = returnFalse2;
            }
            if (callback) {
              callback = { func: callback };
              if (extra) {
                Tools.extend(callback, extra);
              }
              names = name2.toLowerCase().split(" ");
              i2 = names.length;
              while (i2--) {
                name2 = names[i2];
                handlers = bindings[name2];
                if (!handlers) {
                  handlers = bindings[name2] = [];
                  toggleEvent(name2, true);
                }
                if (prepend2) {
                  handlers.unshift(callback);
                } else {
                  handlers.push(callback);
                }
              }
            }
            return self2;
          };
          var off = function(name2, callback) {
            var i2, handlers, bindingName, names, hi;
            if (name2) {
              names = name2.toLowerCase().split(" ");
              i2 = names.length;
              while (i2--) {
                name2 = names[i2];
                handlers = bindings[name2];
                if (!name2) {
                  for (bindingName in bindings) {
                    toggleEvent(bindingName, false);
                    delete bindings[bindingName];
                  }
                  return self2;
                }
                if (handlers) {
                  if (!callback) {
                    handlers.length = 0;
                  } else {
                    hi = handlers.length;
                    while (hi--) {
                      if (handlers[hi].func === callback) {
                        handlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));
                        bindings[name2] = handlers;
                      }
                    }
                  }
                  if (!handlers.length) {
                    toggleEvent(name2, false);
                    delete bindings[name2];
                  }
                }
              }
            } else {
              for (name2 in bindings) {
                toggleEvent(name2, false);
              }
              bindings = {};
            }
            return self2;
          };
          var once = function(name2, callback, prepend2) {
            return on2(name2, callback, prepend2, { once: true });
          };
          var has2 = function(name2) {
            name2 = name2.toLowerCase();
            return !(!bindings[name2] || bindings[name2].length === 0);
          };
          self2.fire = fire;
          self2.on = on2;
          self2.off = off;
          self2.once = once;
          self2.has = has2;
        };
        Dispatcher.isNative = function(name2) {
          return !!nativeEvents[name2.toLowerCase()];
        };
        var getEventDispatcher = function(obj) {
          if (!obj._eventDispatcher) {
            obj._eventDispatcher = new Dispatcher({
              scope: obj,
              toggleEvent: function(name2, state) {
                if (Dispatcher.isNative(name2) && obj.toggleNativeEvent) {
                  obj.toggleNativeEvent(name2, state);
                }
              }
            });
          }
          return obj._eventDispatcher;
        };
        var Observable = {
          fire: function(name2, args, bubble) {
            var self2 = this;
            if (self2.removed && name2 !== "remove" && name2 !== "detach") {
              return args;
            }
            args = getEventDispatcher(self2).fire(name2, args, bubble);
            if (bubble !== false && self2.parent) {
              var parent2 = self2.parent();
              while (parent2 && !args.isPropagationStopped()) {
                parent2.fire(name2, args, false);
                parent2 = parent2.parent();
              }
            }
            return args;
          },
          on: function(name2, callback, prepend2) {
            return getEventDispatcher(this).on(name2, callback, prepend2);
          },
          off: function(name2, callback) {
            return getEventDispatcher(this).off(name2, callback);
          },
          once: function(name2, callback) {
            return getEventDispatcher(this).once(name2, callback);
          },
          hasEventListeners: function(name2) {
            return getEventDispatcher(this).has(name2);
          }
        };
        var firePreProcess = function(editor, args) {
          return editor.fire("PreProcess", args);
        };
        var firePostProcess = function(editor, args) {
          return editor.fire("PostProcess", args);
        };
        var fireRemove = function(editor) {
          return editor.fire("remove");
        };
        var fireDetach = function(editor) {
          return editor.fire("detach");
        };
        var fireSwitchMode = function(editor, mode) {
          return editor.fire("SwitchMode", { mode });
        };
        var fireObjectResizeStart = function(editor, target, width, height) {
          editor.fire("ObjectResizeStart", {
            target,
            width,
            height
          });
        };
        var fireObjectResized = function(editor, target, width, height) {
          editor.fire("ObjectResized", {
            target,
            width,
            height
          });
        };
        var Events = {
          firePreProcess,
          firePostProcess,
          fireRemove,
          fireDetach,
          fireSwitchMode,
          fireObjectResizeStart,
          fireObjectResized
        };
        var setEditorCommandState = function(editor, cmd, state) {
          try {
            editor.getDoc().execCommand(cmd, false, state);
          } catch (ex) {
          }
        };
        var toggleClass = function(elm, cls, state) {
          if (has$2(elm, cls) && state === false) {
            remove$4(elm, cls);
          } else if (state) {
            add$2(elm, cls);
          }
        };
        var toggleReadOnly = function(editor, state) {
          toggleClass(Element.fromDom(editor.getBody()), "mce-content-readonly", state);
          if (state) {
            editor.selection.controlSelection.hideResizeRect();
            editor.readonly = true;
            editor.getBody().contentEditable = "false";
          } else {
            editor.readonly = false;
            editor.getBody().contentEditable = "true";
            setEditorCommandState(editor, "StyleWithCSS", false);
            setEditorCommandState(editor, "enableInlineTableEditing", false);
            setEditorCommandState(editor, "enableObjectResizing", false);
            editor.focus();
            editor.nodeChanged();
          }
        };
        var setMode = function(editor, mode) {
          if (mode === getMode(editor)) {
            return;
          }
          if (editor.initialized) {
            toggleReadOnly(editor, mode === "readonly");
          } else {
            editor.on("init", function() {
              toggleReadOnly(editor, mode === "readonly");
            });
          }
          Events.fireSwitchMode(editor, mode);
        };
        var getMode = function(editor) {
          return editor.readonly ? "readonly" : "design";
        };
        var isReadOnly = function(editor) {
          return editor.readonly === true;
        };
        var DOM$1 = DOMUtils$1.DOM;
        var customEventRootDelegates;
        var getEventTarget = function(editor, eventName) {
          if (eventName === "selectionchange") {
            return editor.getDoc();
          }
          if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
            return editor.getDoc().documentElement;
          }
          if (editor.settings.event_root) {
            if (!editor.eventRoot) {
              editor.eventRoot = DOM$1.select(editor.settings.event_root)[0];
            }
            return editor.eventRoot;
          }
          return editor.getBody();
        };
        var isListening = function(editor) {
          return !editor.hidden && !editor.readonly;
        };
        var fireEvent = function(editor, eventName, e) {
          if (isListening(editor)) {
            editor.fire(eventName, e);
          } else if (isReadOnly(editor)) {
            e.preventDefault();
          }
        };
        var bindEventDelegate = function(editor, eventName) {
          var eventRootElm, delegate;
          if (!editor.delegates) {
            editor.delegates = {};
          }
          if (editor.delegates[eventName] || editor.removed) {
            return;
          }
          eventRootElm = getEventTarget(editor, eventName);
          if (editor.settings.event_root) {
            if (!customEventRootDelegates) {
              customEventRootDelegates = {};
              editor.editorManager.on("removeEditor", function() {
                var name2;
                if (!editor.editorManager.activeEditor) {
                  if (customEventRootDelegates) {
                    for (name2 in customEventRootDelegates) {
                      editor.dom.unbind(getEventTarget(editor, name2));
                    }
                    customEventRootDelegates = null;
                  }
                }
              });
            }
            if (customEventRootDelegates[eventName]) {
              return;
            }
            delegate = function(e) {
              var target = e.target;
              var editors2 = editor.editorManager.get();
              var i2 = editors2.length;
              while (i2--) {
                var body = editors2[i2].getBody();
                if (body === target || DOM$1.isChildOf(target, body)) {
                  fireEvent(editors2[i2], eventName, e);
                }
              }
            };
            customEventRootDelegates[eventName] = delegate;
            DOM$1.bind(eventRootElm, eventName, delegate);
          } else {
            delegate = function(e) {
              fireEvent(editor, eventName, e);
            };
            DOM$1.bind(eventRootElm, eventName, delegate);
            editor.delegates[eventName] = delegate;
          }
        };
        var EditorObservable = {
          bindPendingEventDelegates: function() {
            var self2 = this;
            Tools.each(self2._pendingNativeEvents, function(name2) {
              bindEventDelegate(self2, name2);
            });
          },
          toggleNativeEvent: function(name2, state) {
            var self2 = this;
            if (name2 === "focus" || name2 === "blur") {
              return;
            }
            if (state) {
              if (self2.initialized) {
                bindEventDelegate(self2, name2);
              } else {
                if (!self2._pendingNativeEvents) {
                  self2._pendingNativeEvents = [name2];
                } else {
                  self2._pendingNativeEvents.push(name2);
                }
              }
            } else if (self2.initialized) {
              self2.dom.unbind(getEventTarget(self2, name2), name2, self2.delegates[name2]);
              delete self2.delegates[name2];
            }
          },
          unbindAllNativeEvents: function() {
            var self2 = this;
            var body = self2.getBody();
            var dom2 = self2.dom;
            var name2;
            if (self2.delegates) {
              for (name2 in self2.delegates) {
                self2.dom.unbind(getEventTarget(self2, name2), name2, self2.delegates[name2]);
              }
              delete self2.delegates;
            }
            if (!self2.inline && body && dom2) {
              body.onload = null;
              dom2.unbind(self2.getWin());
              dom2.unbind(self2.getDoc());
            }
            if (dom2) {
              dom2.unbind(body);
              dom2.unbind(self2.getContainer());
            }
          }
        };
        EditorObservable = Tools.extend({}, Observable, EditorObservable);
        var EditorObservable$1 = EditorObservable;
        var sectionResult = Immutable("sections", "settings");
        var detection = PlatformDetection$1.detect();
        var isTouch = detection.deviceType.isTouch();
        var mobilePlugins = [
          "lists",
          "autolink",
          "autosave"
        ];
        var defaultMobileSettings = { theme: "mobile" };
        var normalizePlugins = function(plugins) {
          var pluginNames = isArray(plugins) ? plugins.join(" ") : plugins;
          var trimmedPlugins = map(isString(pluginNames) ? pluginNames.split(" ") : [], trim$2);
          return filter(trimmedPlugins, function(item) {
            return item.length > 0;
          });
        };
        var filterMobilePlugins = function(plugins) {
          return filter(plugins, curry(contains, mobilePlugins));
        };
        var extractSections = function(keys2, settings) {
          var result = bifilter(settings, function(value2, key) {
            return contains(keys2, key);
          });
          return sectionResult(result.t, result.f);
        };
        var getSection = function(sectionResult2, name2, defaults) {
          var sections = sectionResult2.sections();
          var sectionSettings = sections.hasOwnProperty(name2) ? sections[name2] : {};
          return Tools.extend({}, defaults, sectionSettings);
        };
        var hasSection = function(sectionResult2, name2) {
          return sectionResult2.sections().hasOwnProperty(name2);
        };
        var getDefaultSettings = function(id, documentBaseUrl, editor) {
          return {
            id,
            theme: "modern",
            delta_width: 0,
            delta_height: 0,
            popup_css: "",
            plugins: "",
            document_base_url: documentBaseUrl,
            add_form_submit_trigger: true,
            submit_patch: true,
            add_unload_trigger: true,
            convert_urls: true,
            relative_urls: true,
            remove_script_host: true,
            object_resizing: true,
            doctype: "<!DOCTYPE html>",
            visual: true,
            font_size_style_values: "xx-small,x-small,small,medium,large,x-large,xx-large",
            font_size_legacy_values: "xx-small,small,medium,large,x-large,xx-large,300%",
            forced_root_block: "p",
            hidden_input: true,
            render_ui: true,
            indentation: "40px",
            inline_styles: true,
            convert_fonts_to_spans: true,
            indent: "simple",
            indent_before: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
            indent_after: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
            entity_encoding: "named",
            url_converter: editor.convertURL,
            url_converter_scope: editor,
            ie7_compat: true
          };
        };
        var getExternalPlugins = function(overrideSettings, settings) {
          var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};
          if (overrideSettings && overrideSettings.external_plugins) {
            return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);
          } else {
            return userDefinedExternalPlugins;
          }
        };
        var combinePlugins = function(forcedPlugins, plugins) {
          return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));
        };
        var processPlugins = function(isTouchDevice, sectionResult2, defaultOverrideSettings, settings) {
          var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);
          var plugins = normalizePlugins(settings.plugins);
          var platformPlugins = isTouchDevice && hasSection(sectionResult2, "mobile") ? filterMobilePlugins(plugins) : plugins;
          var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
          return Tools.extend(settings, { plugins: combinedPlugins.join(" ") });
        };
        var isOnMobile = function(isTouchDevice, sectionResult2) {
          var isInline2 = sectionResult2.settings().inline;
          return isTouchDevice && hasSection(sectionResult2, "mobile") && !isInline2;
        };
        var combineSettings = function(isTouchDevice, defaultSettings, defaultOverrideSettings, settings) {
          var sectionResult2 = extractSections(["mobile"], settings);
          var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult2.settings(), isOnMobile(isTouchDevice, sectionResult2) ? getSection(sectionResult2, "mobile", defaultMobileSettings) : {}, {
            validate: true,
            content_editable: sectionResult2.settings().inline,
            external_plugins: getExternalPlugins(defaultOverrideSettings, sectionResult2.settings())
          });
          return processPlugins(isTouchDevice, sectionResult2, defaultOverrideSettings, extendedSettings);
        };
        var getEditorSettings = function(editor, id, documentBaseUrl, defaultOverrideSettings, settings) {
          var defaultSettings = getDefaultSettings(id, documentBaseUrl, editor);
          return combineSettings(isTouch, defaultSettings, defaultOverrideSettings, settings);
        };
        var getFiltered = function(predicate, editor, name2) {
          return Option.from(editor.settings[name2]).filter(predicate);
        };
        var getParamObject = function(value2) {
          var output = {};
          if (typeof value2 === "string") {
            each(value2.indexOf("=") > 0 ? value2.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value2.split(","), function(val) {
              var arr2 = val.split("=");
              if (arr2.length > 1) {
                output[Tools.trim(arr2[0])] = Tools.trim(arr2[1]);
              } else {
                output[Tools.trim(arr2[0])] = Tools.trim(arr2);
              }
            });
          } else {
            output = value2;
          }
          return output;
        };
        var isArrayOf = function(p) {
          return function(a) {
            return isArray(a) && forall(a, p);
          };
        };
        var getParam = function(editor, name2, defaultVal, type2) {
          var value2 = name2 in editor.settings ? editor.settings[name2] : defaultVal;
          if (type2 === "hash") {
            return getParamObject(value2);
          } else if (type2 === "string") {
            return getFiltered(isString, editor, name2).getOr(defaultVal);
          } else if (type2 === "number") {
            return getFiltered(isNumber, editor, name2).getOr(defaultVal);
          } else if (type2 === "boolean") {
            return getFiltered(isBoolean, editor, name2).getOr(defaultVal);
          } else if (type2 === "object") {
            return getFiltered(isObject, editor, name2).getOr(defaultVal);
          } else if (type2 === "array") {
            return getFiltered(isArray, editor, name2).getOr(defaultVal);
          } else if (type2 === "string[]") {
            return getFiltered(isArrayOf(isString), editor, name2).getOr(defaultVal);
          } else if (type2 === "function") {
            return getFiltered(isFunction, editor, name2).getOr(defaultVal);
          } else {
            return value2;
          }
        };
        var each$b = Tools.each, explode$2 = Tools.explode;
        var keyCodeLookup = {
          f1: 112,
          f2: 113,
          f3: 114,
          f4: 115,
          f5: 116,
          f6: 117,
          f7: 118,
          f8: 119,
          f9: 120,
          f10: 121,
          f11: 122,
          f12: 123
        };
        var modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
        function Shortcuts(editor) {
          var self2 = this;
          var shortcuts = {};
          var pendingPatterns = [];
          var parseShortcut = function(pattern) {
            var id, key;
            var shortcut = {};
            each$b(explode$2(pattern, "+"), function(value2) {
              if (value2 in modifierNames) {
                shortcut[value2] = true;
              } else {
                if (/^[0-9]{2,}$/.test(value2)) {
                  shortcut.keyCode = parseInt(value2, 10);
                } else {
                  shortcut.charCode = value2.charCodeAt(0);
                  shortcut.keyCode = keyCodeLookup[value2] || value2.toUpperCase().charCodeAt(0);
                }
              }
            });
            id = [shortcut.keyCode];
            for (key in modifierNames) {
              if (shortcut[key]) {
                id.push(key);
              } else {
                shortcut[key] = false;
              }
            }
            shortcut.id = id.join(",");
            if (shortcut.access) {
              shortcut.alt = true;
              if (Env.mac) {
                shortcut.ctrl = true;
              } else {
                shortcut.shift = true;
              }
            }
            if (shortcut.meta) {
              if (Env.mac) {
                shortcut.meta = true;
              } else {
                shortcut.ctrl = true;
                shortcut.meta = false;
              }
            }
            return shortcut;
          };
          var createShortcut = function(pattern, desc, cmdFunc, scope) {
            var shortcuts2;
            shortcuts2 = Tools.map(explode$2(pattern, ">"), parseShortcut);
            shortcuts2[shortcuts2.length - 1] = Tools.extend(shortcuts2[shortcuts2.length - 1], {
              func: cmdFunc,
              scope: scope || editor
            });
            return Tools.extend(shortcuts2[0], {
              desc: editor.translate(desc),
              subpatterns: shortcuts2.slice(1)
            });
          };
          var hasModifier = function(e) {
            return e.altKey || e.ctrlKey || e.metaKey;
          };
          var isFunctionKey = function(e) {
            return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
          };
          var matchShortcut = function(e, shortcut) {
            if (!shortcut) {
              return false;
            }
            if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
              return false;
            }
            if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
              return false;
            }
            if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
              e.preventDefault();
              return true;
            }
            return false;
          };
          var executeShortcutAction = function(shortcut) {
            return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
          };
          editor.on("keyup keypress keydown", function(e) {
            if ((hasModifier(e) || isFunctionKey(e)) && !e.isDefaultPrevented()) {
              each$b(shortcuts, function(shortcut) {
                if (matchShortcut(e, shortcut)) {
                  pendingPatterns = shortcut.subpatterns.slice(0);
                  if (e.type === "keydown") {
                    executeShortcutAction(shortcut);
                  }
                  return true;
                }
              });
              if (matchShortcut(e, pendingPatterns[0])) {
                if (pendingPatterns.length === 1) {
                  if (e.type === "keydown") {
                    executeShortcutAction(pendingPatterns[0]);
                  }
                }
                pendingPatterns.shift();
              }
            }
          });
          self2.add = function(pattern, desc, cmdFunc, scope) {
            var cmd;
            cmd = cmdFunc;
            if (typeof cmdFunc === "string") {
              cmdFunc = function() {
                editor.execCommand(cmd, false, null);
              };
            } else if (Tools.isArray(cmd)) {
              cmdFunc = function() {
                editor.execCommand(cmd[0], cmd[1], cmd[2]);
              };
            }
            each$b(explode$2(Tools.trim(pattern.toLowerCase())), function(pattern2) {
              var shortcut = createShortcut(pattern2, desc, cmdFunc, scope);
              shortcuts[shortcut.id] = shortcut;
            });
            return true;
          };
          self2.remove = function(pattern) {
            var shortcut = createShortcut(pattern);
            if (shortcuts[shortcut.id]) {
              delete shortcuts[shortcut.id];
              return true;
            }
            return false;
          };
        }
        var hasFocus = function(element) {
          var doc2 = owner(element).dom();
          return element.dom() === doc2.activeElement;
        };
        var active = function(_doc) {
          var doc2 = _doc !== void 0 ? _doc.dom() : domGlobals.document;
          return Option.from(doc2.activeElement).map(Element.fromDom);
        };
        var search = function(element) {
          return active(owner(element)).filter(function(e) {
            return element.dom().contains(e.dom());
          });
        };
        var getContentEditableHost = function(editor, node2) {
          return editor.dom.getParent(node2, function(node3) {
            return editor.dom.getContentEditable(node3) === "true";
          });
        };
        var getCollapsedNode = function(rng) {
          return rng.collapsed ? Option.from(getNode(rng.startContainer, rng.startOffset)).map(Element.fromDom) : Option.none();
        };
        var getFocusInElement = function(root, rng) {
          return getCollapsedNode(rng).bind(function(node2) {
            if (isTableSection(node2)) {
              return Option.some(node2);
            } else if (contains$3(root, node2) === false) {
              return Option.some(root);
            } else {
              return Option.none();
            }
          });
        };
        var normalizeSelection = function(editor, rng) {
          getFocusInElement(Element.fromDom(editor.getBody()), rng).bind(function(elm) {
            return CaretFinder.firstPositionIn(elm.dom());
          }).fold(function() {
            editor.selection.normalize();
            return;
          }, function(caretPos) {
            return editor.selection.setRng(caretPos.toRange());
          });
        };
        var focusBody = function(body) {
          if (body.setActive) {
            try {
              body.setActive();
            } catch (ex) {
              body.focus();
            }
          } else {
            body.focus();
          }
        };
        var hasElementFocus = function(elm) {
          return hasFocus(elm) || search(elm).isSome();
        };
        var hasIframeFocus = function(editor) {
          return editor.iframeElement && hasFocus(Element.fromDom(editor.iframeElement));
        };
        var hasInlineFocus = function(editor) {
          var rawBody = editor.getBody();
          return rawBody && hasElementFocus(Element.fromDom(rawBody));
        };
        var hasFocus$1 = function(editor) {
          return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
        };
        var focusEditor = function(editor) {
          var selection = editor.selection, contentEditable2 = editor.settings.content_editable;
          var body = editor.getBody();
          var rng = selection.getRng();
          editor.quirks.refreshContentEditable();
          var contentEditableHost = getContentEditableHost(editor, selection.getNode());
          if (editor.$.contains(body, contentEditableHost)) {
            focusBody(contentEditableHost);
            normalizeSelection(editor, rng);
            activateEditor(editor);
            return;
          }
          if (editor.bookmark !== void 0 && hasFocus$1(editor) === false) {
            SelectionBookmark.getRng(editor).each(function(bookmarkRng) {
              editor.selection.setRng(bookmarkRng);
              rng = bookmarkRng;
            });
          }
          if (!contentEditable2) {
            if (!Env.opera) {
              focusBody(body);
            }
            editor.getWin().focus();
          }
          if (Env.gecko || contentEditable2) {
            focusBody(body);
            normalizeSelection(editor, rng);
          }
          activateEditor(editor);
        };
        var activateEditor = function(editor) {
          return editor.editorManager.setActive(editor);
        };
        var focus = function(editor, skipFocus) {
          if (editor.removed) {
            return;
          }
          skipFocus ? activateEditor(editor) : focusEditor(editor);
        };
        var EditorFocus = {
          focus,
          hasFocus: hasFocus$1
        };
        var getProp = function(propName, elm) {
          var rawElm = elm.dom();
          return rawElm[propName];
        };
        var getComputedSizeProp = function(propName, elm) {
          return parseInt(get$1(elm, propName), 10);
        };
        var getClientWidth = curry(getProp, "clientWidth");
        var getClientHeight = curry(getProp, "clientHeight");
        var getMarginTop = curry(getComputedSizeProp, "margin-top");
        var getMarginLeft = curry(getComputedSizeProp, "margin-left");
        var getBoundingClientRect$1 = function(elm) {
          return elm.dom().getBoundingClientRect();
        };
        var isInsideElementContentArea = function(bodyElm, clientX, clientY) {
          var clientWidth = getClientWidth(bodyElm);
          var clientHeight = getClientHeight(bodyElm);
          return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
        };
        var transpose = function(inline, elm, clientX, clientY) {
          var clientRect = getBoundingClientRect$1(elm);
          var deltaX = inline ? clientRect.left + elm.dom().clientLeft + getMarginLeft(elm) : 0;
          var deltaY = inline ? clientRect.top + elm.dom().clientTop + getMarginTop(elm) : 0;
          var x = clientX - deltaX;
          var y = clientY - deltaY;
          return {
            x,
            y
          };
        };
        var isXYInContentArea = function(editor, clientX, clientY) {
          var bodyElm = Element.fromDom(editor.getBody());
          var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
          var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
          return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
        };
        var fromDomSafe = function(node2) {
          return Option.from(node2).map(Element.fromDom);
        };
        var isEditorAttachedToDom = function(editor) {
          var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
          return fromDomSafe(rawContainer).map(function(container) {
            return contains$3(owner(container), container);
          }).getOr(false);
        };
        var EditorView = {
          isXYInContentArea,
          isEditorAttachedToDom
        };
        function NotificationManagerImpl() {
          var unimplemented = function() {
            throw new Error("Theme did not provide a NotificationManager implementation.");
          };
          return {
            open: unimplemented,
            close: unimplemented,
            reposition: unimplemented,
            getArgs: unimplemented
          };
        }
        function NotificationManager(editor) {
          var notifications = [];
          var getImplementation = function() {
            var theme = editor.theme;
            return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
          };
          var getTopNotification = function() {
            return Option.from(notifications[0]);
          };
          var isEqual2 = function(a, b) {
            return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
          };
          var reposition2 = function() {
            if (notifications.length > 0) {
              getImplementation().reposition(notifications);
            }
          };
          var addNotification = function(notification) {
            notifications.push(notification);
          };
          var closeNotification = function(notification) {
            findIndex(notifications, function(otherNotification) {
              return otherNotification === notification;
            }).each(function(index) {
              notifications.splice(index, 1);
            });
          };
          var open = function(args) {
            if (editor.removed || !EditorView.isEditorAttachedToDom(editor)) {
              return;
            }
            return find(notifications, function(notification) {
              return isEqual2(getImplementation().getArgs(notification), args);
            }).getOrThunk(function() {
              editor.editorManager.setActive(editor);
              var notification = getImplementation().open(args, function() {
                closeNotification(notification);
                reposition2();
              });
              addNotification(notification);
              reposition2();
              return notification;
            });
          };
          var close = function() {
            getTopNotification().each(function(notification) {
              getImplementation().close(notification);
              closeNotification(notification);
              reposition2();
            });
          };
          var getNotifications = function() {
            return notifications;
          };
          var registerEvents2 = function(editor2) {
            editor2.on("SkinLoaded", function() {
              var serviceMessage = editor2.settings.service_message;
              if (serviceMessage) {
                open({
                  text: serviceMessage,
                  type: "warning",
                  timeout: 0,
                  icon: ""
                });
              }
            });
            editor2.on("ResizeEditor ResizeWindow", function() {
              Delay.requestAnimationFrame(reposition2);
            });
            editor2.on("remove", function() {
              each(notifications.slice(), function(notification) {
                getImplementation().close(notification);
              });
            });
          };
          registerEvents2(editor);
          return {
            open,
            close,
            getNotifications
          };
        }
        function WindowManagerImpl() {
          var unimplemented = function() {
            throw new Error("Theme did not provide a WindowManager implementation.");
          };
          return {
            open: unimplemented,
            alert: unimplemented,
            confirm: unimplemented,
            close: unimplemented,
            getParams: unimplemented,
            setParams: unimplemented
          };
        }
        function WindowManager(editor) {
          var windows2 = [];
          var getImplementation = function() {
            var theme = editor.theme;
            return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
          };
          var funcBind = function(scope, f) {
            return function() {
              return f ? f.apply(scope, arguments) : void 0;
            };
          };
          var fireOpenEvent = function(win) {
            editor.fire("OpenWindow", { win });
          };
          var fireCloseEvent = function(win) {
            editor.fire("CloseWindow", { win });
          };
          var addWindow = function(win) {
            windows2.push(win);
            fireOpenEvent(win);
          };
          var closeWindow = function(win) {
            findIndex(windows2, function(otherWindow) {
              return otherWindow === win;
            }).each(function(index) {
              windows2.splice(index, 1);
              fireCloseEvent(win);
              if (windows2.length === 0) {
                editor.focus();
              }
            });
          };
          var getTopWindow = function() {
            return Option.from(windows2[windows2.length - 1]);
          };
          var open = function(args, params) {
            editor.editorManager.setActive(editor);
            SelectionBookmark.store(editor);
            var win = getImplementation().open(args, params, closeWindow);
            addWindow(win);
            return win;
          };
          var alert = function(message, callback, scope) {
            var win = getImplementation().alert(message, funcBind(scope ? scope : this, callback), closeWindow);
            addWindow(win);
          };
          var confirm = function(message, callback, scope) {
            var win = getImplementation().confirm(message, funcBind(scope ? scope : this, callback), closeWindow);
            addWindow(win);
          };
          var close = function() {
            getTopWindow().each(function(win) {
              getImplementation().close(win);
              closeWindow(win);
            });
          };
          var getParams = function() {
            return getTopWindow().map(getImplementation().getParams).getOr(null);
          };
          var setParams = function(params) {
            getTopWindow().each(function(win) {
              getImplementation().setParams(win, params);
            });
          };
          var getWindows = function() {
            return windows2;
          };
          editor.on("remove", function() {
            each(windows2.slice(0), function(win) {
              getImplementation().close(win);
            });
          });
          return {
            windows: windows2,
            open,
            alert,
            confirm,
            close,
            getParams,
            setParams,
            getWindows
          };
        }
        var data = {};
        var code = "en";
        var I18n = {
          setCode: function(newCode) {
            if (newCode) {
              code = newCode;
              this.rtl = this.data[newCode] ? this.data[newCode]._dir === "rtl" : false;
            }
          },
          getCode: function() {
            return code;
          },
          rtl: false,
          add: function(code2, items) {
            var langData = data[code2];
            if (!langData) {
              data[code2] = langData = {};
            }
            for (var name2 in items) {
              langData[name2] = items[name2];
            }
            this.setCode(code2);
          },
          translate: function(text) {
            var langData = data[code] || {};
            var toString = function(obj) {
              if (Tools.is(obj, "function")) {
                return Object.prototype.toString.call(obj);
              }
              return !isEmpty2(obj) ? "" + obj : "";
            };
            var isEmpty2 = function(text2) {
              return text2 === "" || text2 === null || Tools.is(text2, "undefined");
            };
            var getLangData = function(text2) {
              text2 = toString(text2);
              return Tools.hasOwn(langData, text2) ? toString(langData[text2]) : text2;
            };
            if (isEmpty2(text)) {
              return "";
            }
            if (Tools.is(text, "object") && Tools.hasOwn(text, "raw")) {
              return toString(text.raw);
            }
            if (Tools.is(text, "array")) {
              var values_1 = text.slice(1);
              text = getLangData(text[0]).replace(/\{([0-9]+)\}/g, function($1, $2) {
                return Tools.hasOwn(values_1, $2) ? toString(values_1[$2]) : $1;
              });
            }
            return getLangData(text).replace(/{context:\w+}$/, "");
          },
          data
        };
        var PluginManager = AddOnManager.PluginManager;
        var resolvePluginName = function(targetUrl, suffix) {
          for (var name2 in PluginManager.urls) {
            var matchUrl = PluginManager.urls[name2] + "/plugin" + suffix + ".js";
            if (matchUrl === targetUrl) {
              return name2;
            }
          }
          return null;
        };
        var pluginUrlToMessage = function(editor, url2) {
          var plugin = resolvePluginName(url2, editor.suffix);
          return plugin ? I18n.translate([
            "Failed to load plugin: {0} from url {1}",
            plugin,
            url2
          ]) : I18n.translate([
            "Failed to load plugin url: {0}",
            url2
          ]);
        };
        var displayNotification = function(editor, message) {
          editor.notificationManager.open({
            type: "error",
            text: message
          });
        };
        var displayError = function(editor, message) {
          if (editor._skinLoaded) {
            displayNotification(editor, message);
          } else {
            editor.on("SkinLoaded", function() {
              displayNotification(editor, message);
            });
          }
        };
        var uploadError = function(editor, message) {
          displayError(editor, I18n.translate([
            "Failed to upload image: {0}",
            message
          ]));
        };
        var pluginLoadError = function(editor, url2) {
          displayError(editor, pluginUrlToMessage(editor, url2));
        };
        var pluginInitError = function(editor, name2, err) {
          var message = I18n.translate([
            "Failed to initialize plugin: {0}",
            name2
          ]);
          initError(message, err);
          displayError(editor, message);
        };
        var initError = function(message) {
          var x = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            x[_i - 1] = arguments[_i];
          }
          var console2 = domGlobals.window.console;
          if (console2) {
            if (console2.error) {
              console2.error.apply(console2, arguments);
            } else {
              console2.log.apply(console2, arguments);
            }
          }
        };
        var ErrorReporter = {
          pluginLoadError,
          pluginInitError,
          uploadError,
          displayError,
          initError
        };
        var PluginManager$1 = AddOnManager.PluginManager;
        var ThemeManager = AddOnManager.ThemeManager;
        function XMLHttpRequest() {
          var f = Global$1.getOrDie("XMLHttpRequest");
          return new f();
        }
        function Uploader(uploadStatus, settings) {
          var pendingPromises = {};
          var pathJoin = function(path1, path2) {
            if (path1) {
              return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
            }
            return path2;
          };
          var defaultHandler = function(blobInfo, success, failure, progress) {
            var xhr, formData;
            xhr = XMLHttpRequest();
            xhr.open("POST", settings.url);
            xhr.withCredentials = settings.credentials;
            xhr.upload.onprogress = function(e) {
              progress(e.loaded / e.total * 100);
            };
            xhr.onerror = function() {
              failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
            };
            xhr.onload = function() {
              var json;
              if (xhr.status < 200 || xhr.status >= 300) {
                failure("HTTP Error: " + xhr.status);
                return;
              }
              json = JSON.parse(xhr.responseText);
              if (!json || typeof json.location !== "string") {
                failure("Invalid JSON: " + xhr.responseText);
                return;
              }
              success(pathJoin(settings.basePath, json.location));
            };
            formData = new domGlobals.FormData();
            formData.append("file", blobInfo.blob(), blobInfo.filename());
            xhr.send(formData);
          };
          var noUpload = function() {
            return new promiseObj(function(resolve2) {
              resolve2([]);
            });
          };
          var handlerSuccess = function(blobInfo, url2) {
            return {
              url: url2,
              blobInfo,
              status: true
            };
          };
          var handlerFailure = function(blobInfo, error2) {
            return {
              url: "",
              blobInfo,
              status: false,
              error: error2
            };
          };
          var resolvePending = function(blobUri, result) {
            Tools.each(pendingPromises[blobUri], function(resolve2) {
              resolve2(result);
            });
            delete pendingPromises[blobUri];
          };
          var uploadBlobInfo = function(blobInfo, handler, openNotification) {
            uploadStatus.markPending(blobInfo.blobUri());
            return new promiseObj(function(resolve2) {
              var notification, progress;
              var noop2 = function() {
              };
              try {
                var closeNotification_1 = function() {
                  if (notification) {
                    notification.close();
                    progress = noop2;
                  }
                };
                var success = function(url2) {
                  closeNotification_1();
                  uploadStatus.markUploaded(blobInfo.blobUri(), url2);
                  resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url2));
                  resolve2(handlerSuccess(blobInfo, url2));
                };
                var failure = function(error2) {
                  closeNotification_1();
                  uploadStatus.removeFailed(blobInfo.blobUri());
                  resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error2));
                  resolve2(handlerFailure(blobInfo, error2));
                };
                progress = function(percent) {
                  if (percent < 0 || percent > 100) {
                    return;
                  }
                  if (!notification) {
                    notification = openNotification();
                  }
                  notification.progressBar.value(percent);
                };
                handler(blobInfo, success, failure, progress);
              } catch (ex) {
                resolve2(handlerFailure(blobInfo, ex.message));
              }
            });
          };
          var isDefaultHandler = function(handler) {
            return handler === defaultHandler;
          };
          var pendingUploadBlobInfo = function(blobInfo) {
            var blobUri = blobInfo.blobUri();
            return new promiseObj(function(resolve2) {
              pendingPromises[blobUri] = pendingPromises[blobUri] || [];
              pendingPromises[blobUri].push(resolve2);
            });
          };
          var uploadBlobs = function(blobInfos, openNotification) {
            blobInfos = Tools.grep(blobInfos, function(blobInfo) {
              return !uploadStatus.isUploaded(blobInfo.blobUri());
            });
            return promiseObj.all(Tools.map(blobInfos, function(blobInfo) {
              return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
            }));
          };
          var upload = function(blobInfos, openNotification) {
            return !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);
          };
          if (isFunction(settings.handler) === false) {
            settings.handler = defaultHandler;
          }
          return { upload };
        }
        function FileReader() {
          var f = Global$1.getOrDie("FileReader");
          return new f();
        }
        function Uint8Array(arr2) {
          var f = Global$1.getOrDie("Uint8Array");
          return new f(arr2);
        }
        var requestAnimationFrame$1 = function(callback) {
          var f = Global$1.getOrDie("requestAnimationFrame");
          f(callback);
        };
        var atob = function(base64) {
          var f = Global$1.getOrDie("atob");
          return f(base64);
        };
        var Window = {
          atob,
          requestAnimationFrame: requestAnimationFrame$1
        };
        var blobUriToBlob = function(url2) {
          return new promiseObj(function(resolve2, reject) {
            var rejectWithError = function() {
              reject("Cannot convert " + url2 + " to Blob. Resource might not exist or is inaccessible.");
            };
            try {
              var xhr = XMLHttpRequest();
              xhr.open("GET", url2, true);
              xhr.responseType = "blob";
              xhr.onload = function() {
                if (this.status === 200) {
                  resolve2(this.response);
                } else {
                  rejectWithError();
                }
              };
              xhr.onerror = rejectWithError;
              xhr.send();
            } catch (ex) {
              rejectWithError();
            }
          });
        };
        var parseDataUri = function(uri) {
          var type2, matches2;
          var uriParts = decodeURIComponent(uri).split(",");
          matches2 = /data:([^;]+)/.exec(uriParts[0]);
          if (matches2) {
            type2 = matches2[1];
          }
          return {
            type: type2,
            data: uriParts[1]
          };
        };
        var dataUriToBlob = function(uri) {
          return new promiseObj(function(resolve2) {
            var str, arr2, i2;
            var uriParts = parseDataUri(uri);
            try {
              str = Window.atob(uriParts.data);
            } catch (e) {
              resolve2(new domGlobals.Blob([]));
              return;
            }
            arr2 = Uint8Array(str.length);
            for (i2 = 0; i2 < arr2.length; i2++) {
              arr2[i2] = str.charCodeAt(i2);
            }
            resolve2(new domGlobals.Blob([arr2], { type: uriParts.type }));
          });
        };
        var uriToBlob = function(url2) {
          if (url2.indexOf("blob:") === 0) {
            return blobUriToBlob(url2);
          }
          if (url2.indexOf("data:") === 0) {
            return dataUriToBlob(url2);
          }
          return null;
        };
        var blobToDataUri = function(blob) {
          return new promiseObj(function(resolve2) {
            var reader = FileReader();
            reader.onloadend = function() {
              resolve2(reader.result);
            };
            reader.readAsDataURL(blob);
          });
        };
        var Conversions = {
          uriToBlob,
          blobToDataUri,
          parseDataUri
        };
        var count = 0;
        var uniqueId = function(prefix) {
          return (prefix || "blobid") + count++;
        };
        var imageToBlobInfo = function(blobCache, img, resolve2, reject) {
          var base64, blobInfo;
          if (img.src.indexOf("blob:") === 0) {
            blobInfo = blobCache.getByUri(img.src);
            if (blobInfo) {
              resolve2({
                image: img,
                blobInfo
              });
            } else {
              Conversions.uriToBlob(img.src).then(function(blob) {
                Conversions.blobToDataUri(blob).then(function(dataUri) {
                  base64 = Conversions.parseDataUri(dataUri).data;
                  blobInfo = blobCache.create(uniqueId(), blob, base64);
                  blobCache.add(blobInfo);
                  resolve2({
                    image: img,
                    blobInfo
                  });
                });
              }, function(err) {
                reject(err);
              });
            }
            return;
          }
          base64 = Conversions.parseDataUri(img.src).data;
          blobInfo = blobCache.findFirst(function(cachedBlobInfo) {
            return cachedBlobInfo.base64() === base64;
          });
          if (blobInfo) {
            resolve2({
              image: img,
              blobInfo
            });
          } else {
            Conversions.uriToBlob(img.src).then(function(blob) {
              blobInfo = blobCache.create(uniqueId(), blob, base64);
              blobCache.add(blobInfo);
              resolve2({
                image: img,
                blobInfo
              });
            }, function(err) {
              reject(err);
            });
          }
        };
        var getAllImages = function(elm) {
          return elm ? from$1(elm.getElementsByTagName("img")) : [];
        };
        function ImageScanner(uploadStatus, blobCache) {
          var cachedPromises = {};
          var findAll2 = function(elm, predicate) {
            var images;
            if (!predicate) {
              predicate = constant(true);
            }
            images = filter(getAllImages(elm), function(img) {
              var src = img.src;
              if (!Env.fileApi) {
                return false;
              }
              if (img.hasAttribute("data-mce-bogus")) {
                return false;
              }
              if (img.hasAttribute("data-mce-placeholder")) {
                return false;
              }
              if (!src || src === Env.transparentSrc) {
                return false;
              }
              if (src.indexOf("blob:") === 0) {
                return !uploadStatus.isUploaded(src) && predicate(img);
              }
              if (src.indexOf("data:") === 0) {
                return predicate(img);
              }
              return false;
            });
            var promises = map(images, function(img) {
              if (cachedPromises[img.src]) {
                return new promiseObj(function(resolve2) {
                  cachedPromises[img.src].then(function(imageInfo) {
                    if (typeof imageInfo === "string") {
                      return imageInfo;
                    }
                    resolve2({
                      image: img,
                      blobInfo: imageInfo.blobInfo
                    });
                  });
                });
              }
              var newPromise = new promiseObj(function(resolve2, reject) {
                imageToBlobInfo(blobCache, img, resolve2, reject);
              }).then(function(result) {
                delete cachedPromises[result.image.src];
                return result;
              }).catch(function(error2) {
                delete cachedPromises[img.src];
                return error2;
              });
              cachedPromises[img.src] = newPromise;
              return newPromise;
            });
            return promiseObj.all(promises);
          };
          return { findAll: findAll2 };
        }
        var count$1 = 0;
        var seed = function() {
          var rnd = function() {
            return Math.round(Math.random() * 4294967295).toString(36);
          };
          var now = new Date().getTime();
          return "s" + now.toString(36) + rnd() + rnd() + rnd();
        };
        var uuid = function(prefix) {
          return prefix + count$1++ + seed();
        };
        var Uuid = { uuid };
        function BlobCache() {
          var cache = [];
          var mimeToExt = function(mime) {
            var mimes = {
              "image/jpeg": "jpg",
              "image/jpg": "jpg",
              "image/gif": "gif",
              "image/png": "png"
            };
            return mimes[mime.toLowerCase()] || "dat";
          };
          var create2 = function(o, blob, base64, filename) {
            if (isString(o)) {
              var id = o;
              return toBlobInfo({
                id,
                name: filename,
                blob,
                base64
              });
            } else if (isObject(o)) {
              return toBlobInfo(o);
            } else {
              throw new Error("Unknown input type");
            }
          };
          var toBlobInfo = function(o) {
            var id, name2;
            if (!o.blob || !o.base64) {
              throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
            }
            id = o.id || Uuid.uuid("blobid");
            name2 = o.name || id;
            return {
              id: constant(id),
              name: constant(name2),
              filename: constant(name2 + "." + mimeToExt(o.blob.type)),
              blob: constant(o.blob),
              base64: constant(o.base64),
              blobUri: constant(o.blobUri || URL.createObjectURL(o.blob)),
              uri: constant(o.uri)
            };
          };
          var add2 = function(blobInfo) {
            if (!get2(blobInfo.id())) {
              cache.push(blobInfo);
            }
          };
          var get2 = function(id) {
            return findFirst(function(cachedBlobInfo) {
              return cachedBlobInfo.id() === id;
            });
          };
          var findFirst = function(predicate) {
            return filter(cache, predicate)[0];
          };
          var getByUri = function(blobUri) {
            return findFirst(function(blobInfo) {
              return blobInfo.blobUri() === blobUri;
            });
          };
          var removeByUri = function(blobUri) {
            cache = filter(cache, function(blobInfo) {
              if (blobInfo.blobUri() === blobUri) {
                URL.revokeObjectURL(blobInfo.blobUri());
                return false;
              }
              return true;
            });
          };
          var destroy2 = function() {
            each(cache, function(cachedBlobInfo) {
              URL.revokeObjectURL(cachedBlobInfo.blobUri());
            });
            cache = [];
          };
          return {
            create: create2,
            add: add2,
            get: get2,
            getByUri,
            findFirst,
            removeByUri,
            destroy: destroy2
          };
        }
        function UploadStatus() {
          var PENDING = 1, UPLOADED = 2;
          var blobUriStatuses = {};
          var createStatus = function(status, resultUri) {
            return {
              status,
              resultUri
            };
          };
          var hasBlobUri = function(blobUri) {
            return blobUri in blobUriStatuses;
          };
          var getResultUri = function(blobUri) {
            var result = blobUriStatuses[blobUri];
            return result ? result.resultUri : null;
          };
          var isPending = function(blobUri) {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
          };
          var isUploaded = function(blobUri) {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
          };
          var markPending = function(blobUri) {
            blobUriStatuses[blobUri] = createStatus(PENDING, null);
          };
          var markUploaded = function(blobUri, resultUri) {
            blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
          };
          var removeFailed = function(blobUri) {
            delete blobUriStatuses[blobUri];
          };
          var destroy2 = function() {
            blobUriStatuses = {};
          };
          return {
            hasBlobUri,
            getResultUri,
            isPending,
            isUploaded,
            markPending,
            markUploaded,
            removeFailed,
            destroy: destroy2
          };
        }
        function EditorUpload(editor) {
          var blobCache = BlobCache();
          var uploader, imageScanner;
          var uploadStatus = UploadStatus();
          var urlFilters = [];
          var aliveGuard = function(callback) {
            return function(result) {
              if (editor.selection) {
                return callback(result);
              }
              return [];
            };
          };
          var cacheInvalidator = function() {
            return "?" + new Date().getTime();
          };
          var replaceString = function(content, search2, replace) {
            var index = 0;
            do {
              index = content.indexOf(search2, index);
              if (index !== -1) {
                content = content.substring(0, index) + replace + content.substr(index + search2.length);
                index += replace.length - search2.length + 1;
              }
            } while (index !== -1);
            return content;
          };
          var replaceImageUrl = function(content, targetUrl, replacementUrl) {
            content = replaceString(content, 'src="' + targetUrl + '"', 'src="' + replacementUrl + '"');
            content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
            return content;
          };
          var replaceUrlInUndoStack = function(targetUrl, replacementUrl) {
            each(editor.undoManager.data, function(level) {
              if (level.type === "fragmented") {
                level.fragments = map(level.fragments, function(fragment) {
                  return replaceImageUrl(fragment, targetUrl, replacementUrl);
                });
              } else {
                level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
              }
            });
          };
          var openNotification = function() {
            return editor.notificationManager.open({
              text: editor.translate("Image uploading..."),
              type: "info",
              timeout: -1,
              progressBar: true
            });
          };
          var replaceImageUri = function(image, resultUri) {
            blobCache.removeByUri(image.src);
            replaceUrlInUndoStack(image.src, resultUri);
            editor.$(image).attr({
              "src": Settings.shouldReuseFileName(editor) ? resultUri + cacheInvalidator() : resultUri,
              "data-mce-src": editor.convertURL(resultUri, "src")
            });
          };
          var uploadImages = function(callback) {
            if (!uploader) {
              uploader = Uploader(uploadStatus, {
                url: Settings.getImageUploadUrl(editor),
                basePath: Settings.getImageUploadBasePath(editor),
                credentials: Settings.getImagesUploadCredentials(editor),
                handler: Settings.getImagesUploadHandler(editor)
              });
            }
            return scanForImages().then(aliveGuard(function(imageInfos) {
              var blobInfos;
              blobInfos = map(imageInfos, function(imageInfo) {
                return imageInfo.blobInfo;
              });
              return uploader.upload(blobInfos, openNotification).then(aliveGuard(function(result) {
                var filteredResult = map(result, function(uploadInfo, index) {
                  var image = imageInfos[index].image;
                  if (uploadInfo.status && Settings.shouldReplaceBlobUris(editor)) {
                    replaceImageUri(image, uploadInfo.url);
                  } else if (uploadInfo.error) {
                    ErrorReporter.uploadError(editor, uploadInfo.error);
                  }
                  return {
                    element: image,
                    status: uploadInfo.status
                  };
                });
                if (callback) {
                  callback(filteredResult);
                }
                return filteredResult;
              }));
            }));
          };
          var uploadImagesAuto = function(callback) {
            if (Settings.isAutomaticUploadsEnabled(editor)) {
              return uploadImages(callback);
            }
          };
          var isValidDataUriImage = function(imgElm) {
            if (forall(urlFilters, function(filter2) {
              return filter2(imgElm);
            }) === false) {
              return false;
            }
            if (imgElm.getAttribute("src").indexOf("data:") === 0) {
              var dataImgFilter = Settings.getImagesDataImgFilter(editor);
              return dataImgFilter(imgElm);
            }
            return true;
          };
          var addFilter = function(filter2) {
            urlFilters.push(filter2);
          };
          var scanForImages = function() {
            if (!imageScanner) {
              imageScanner = ImageScanner(uploadStatus, blobCache);
            }
            return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function(result) {
              result = filter(result, function(resultItem) {
                if (typeof resultItem === "string") {
                  ErrorReporter.displayError(editor, resultItem);
                  return false;
                }
                return true;
              });
              each(result, function(resultItem) {
                replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
                resultItem.image.src = resultItem.blobInfo.blobUri();
                resultItem.image.removeAttribute("data-mce-src");
              });
              return result;
            }));
          };
          var destroy2 = function() {
            blobCache.destroy();
            uploadStatus.destroy();
            imageScanner = uploader = null;
          };
          var replaceBlobUris = function(content) {
            return content.replace(/src="(blob:[^"]+)"/g, function(match2, blobUri) {
              var resultUri = uploadStatus.getResultUri(blobUri);
              if (resultUri) {
                return 'src="' + resultUri + '"';
              }
              var blobInfo = blobCache.getByUri(blobUri);
              if (!blobInfo) {
                blobInfo = foldl(editor.editorManager.get(), function(result, editor2) {
                  return result || editor2.editorUpload && editor2.editorUpload.blobCache.getByUri(blobUri);
                }, null);
              }
              if (blobInfo) {
                var blob = blobInfo.blob();
                return 'src="data:' + blob.type + ";base64," + blobInfo.base64() + '"';
              }
              return match2;
            });
          };
          editor.on("setContent", function() {
            if (Settings.isAutomaticUploadsEnabled(editor)) {
              uploadImagesAuto();
            } else {
              scanForImages();
            }
          });
          editor.on("RawSaveContent", function(e) {
            e.content = replaceBlobUris(e.content);
          });
          editor.on("getContent", function(e) {
            if (e.source_view || e.format === "raw") {
              return;
            }
            e.content = replaceBlobUris(e.content);
          });
          editor.on("PostRender", function() {
            editor.parser.addNodeFilter("img", function(images) {
              each(images, function(img) {
                var src = img.attr("src");
                if (blobCache.getByUri(src)) {
                  return;
                }
                var resultUri = uploadStatus.getResultUri(src);
                if (resultUri) {
                  img.attr("src", resultUri);
                }
              });
            });
          });
          return {
            blobCache,
            addFilter,
            uploadImages,
            uploadImagesAuto,
            scanForImages,
            destroy: destroy2
          };
        }
        var isBlockElement = function(blockElements, node2) {
          return blockElements.hasOwnProperty(node2.nodeName);
        };
        var isValidTarget = function(blockElements, node2) {
          if (NodeType.isText(node2)) {
            return true;
          } else if (NodeType.isElement(node2)) {
            return !isBlockElement(blockElements, node2) && !Bookmarks.isBookmarkNode(node2);
          } else {
            return false;
          }
        };
        var hasBlockParent = function(blockElements, root, node2) {
          return exists(Parents.parents(Element.fromDom(node2), Element.fromDom(root)), function(elm) {
            return isBlockElement(blockElements, elm.dom());
          });
        };
        var shouldRemoveTextNode = function(blockElements, node2) {
          if (NodeType.isText(node2)) {
            if (node2.nodeValue.length === 0) {
              return true;
            } else if (/^\s+$/.test(node2.nodeValue) && (!node2.nextSibling || isBlockElement(blockElements, node2.nextSibling))) {
              return true;
            }
          }
          return false;
        };
        var addRootBlocks = function(editor) {
          var settings = editor.settings, dom2 = editor.dom, selection = editor.selection;
          var schema = editor.schema, blockElements = schema.getBlockElements();
          var node2 = selection.getStart();
          var rootNode = editor.getBody();
          var rng;
          var startContainer, startOffset, endContainer, endOffset, rootBlockNode;
          var tempNode, wrapped, restoreSelection;
          var rootNodeName, forcedRootBlock;
          forcedRootBlock = settings.forced_root_block;
          if (!node2 || !NodeType.isElement(node2) || !forcedRootBlock) {
            return;
          }
          rootNodeName = rootNode.nodeName.toLowerCase();
          if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node2)) {
            return;
          }
          rng = selection.getRng();
          startContainer = rng.startContainer;
          startOffset = rng.startOffset;
          endContainer = rng.endContainer;
          endOffset = rng.endOffset;
          restoreSelection = EditorFocus.hasFocus(editor);
          node2 = rootNode.firstChild;
          while (node2) {
            if (isValidTarget(blockElements, node2)) {
              if (shouldRemoveTextNode(blockElements, node2)) {
                tempNode = node2;
                node2 = node2.nextSibling;
                dom2.remove(tempNode);
                continue;
              }
              if (!rootBlockNode) {
                rootBlockNode = dom2.create(forcedRootBlock, editor.settings.forced_root_block_attrs);
                node2.parentNode.insertBefore(rootBlockNode, node2);
                wrapped = true;
              }
              tempNode = node2;
              node2 = node2.nextSibling;
              rootBlockNode.appendChild(tempNode);
            } else {
              rootBlockNode = null;
              node2 = node2.nextSibling;
            }
          }
          if (wrapped && restoreSelection) {
            rng.setStart(startContainer, startOffset);
            rng.setEnd(endContainer, endOffset);
            selection.setRng(rng);
            editor.nodeChanged();
          }
        };
        var setup$3 = function(editor) {
          if (editor.settings.forced_root_block) {
            editor.on("NodeChange", curry(addRootBlocks, editor));
          }
        };
        var ForceBlocks = { setup: setup$3 };
        var getStartNode = function(rng) {
          var sc = rng.startContainer, so = rng.startOffset;
          if (NodeType.isText(sc)) {
            return so === 0 ? Option.some(Element.fromDom(sc)) : Option.none();
          } else {
            return Option.from(sc.childNodes[so]).map(Element.fromDom);
          }
        };
        var getEndNode = function(rng) {
          var ec = rng.endContainer, eo = rng.endOffset;
          if (NodeType.isText(ec)) {
            return eo === ec.data.length ? Option.some(Element.fromDom(ec)) : Option.none();
          } else {
            return Option.from(ec.childNodes[eo - 1]).map(Element.fromDom);
          }
        };
        var getFirstChildren = function(node2) {
          return firstChild(node2).fold(constant([node2]), function(child2) {
            return [node2].concat(getFirstChildren(child2));
          });
        };
        var getLastChildren$1 = function(node2) {
          return lastChild(node2).fold(constant([node2]), function(child2) {
            if (name(child2) === "br") {
              return prevSibling(child2).map(function(sibling2) {
                return [node2].concat(getLastChildren$1(sibling2));
              }).getOr([]);
            } else {
              return [node2].concat(getLastChildren$1(child2));
            }
          });
        };
        var hasAllContentsSelected = function(elm, rng) {
          return lift2(getStartNode(rng), getEndNode(rng), function(startNode, endNode) {
            var start2 = find(getFirstChildren(elm), curry(eq, startNode));
            var end2 = find(getLastChildren$1(elm), curry(eq, endNode));
            return start2.isSome() && end2.isSome();
          }).getOr(false);
        };
        var moveEndPoint$1 = function(dom2, rng, node2, start2) {
          var root = node2, walker = new TreeWalker(node2, root);
          var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          do {
            if (node2.nodeType === 3 && Tools.trim(node2.nodeValue).length !== 0) {
              if (start2) {
                rng.setStart(node2, 0);
              } else {
                rng.setEnd(node2, node2.nodeValue.length);
              }
              return;
            }
            if (nonEmptyElementsMap[node2.nodeName] && !/^(TD|TH)$/.test(node2.nodeName)) {
              if (start2) {
                rng.setStartBefore(node2);
              } else {
                if (node2.nodeName === "BR") {
                  rng.setEndBefore(node2);
                } else {
                  rng.setEndAfter(node2);
                }
              }
              return;
            }
            if (Env.ie && Env.ie < 11 && dom2.isBlock(node2) && dom2.isEmpty(node2)) {
              if (start2) {
                rng.setStart(node2, 0);
              } else {
                rng.setEnd(node2, 0);
              }
              return;
            }
          } while (node2 = start2 ? walker.next() : walker.prev());
          if (root.nodeName === "BODY") {
            if (start2) {
              rng.setStart(root, 0);
            } else {
              rng.setEnd(root, root.childNodes.length);
            }
          }
        };
        var hasAnyRanges = function(editor) {
          var sel = editor.selection.getSel();
          return sel && sel.rangeCount > 0;
        };
        function NodeChange(editor) {
          var lastRng, lastPath = [];
          var isSameElementPath = function(startElm) {
            var i2, currentPath;
            currentPath = editor.$(startElm).parentsUntil(editor.getBody()).add(startElm);
            if (currentPath.length === lastPath.length) {
              for (i2 = currentPath.length; i2 >= 0; i2--) {
                if (currentPath[i2] !== lastPath[i2]) {
                  break;
                }
              }
              if (i2 === -1) {
                lastPath = currentPath;
                return true;
              }
            }
            lastPath = currentPath;
            return false;
          };
          if (!("onselectionchange" in editor.getDoc())) {
            editor.on("NodeChange Click MouseUp KeyUp Focus", function(e) {
              var nativeRng, fakeRng;
              nativeRng = editor.selection.getRng();
              fakeRng = {
                startContainer: nativeRng.startContainer,
                startOffset: nativeRng.startOffset,
                endContainer: nativeRng.endContainer,
                endOffset: nativeRng.endOffset
              };
              if (e.type === "nodechange" || !RangeCompare.isEq(fakeRng, lastRng)) {
                editor.fire("SelectionChange");
              }
              lastRng = fakeRng;
            });
          }
          editor.on("contextmenu", function() {
            editor.fire("SelectionChange");
          });
          editor.on("SelectionChange", function() {
            var startElm = editor.selection.getStart(true);
            if (!startElm || !Env.range && editor.selection.isCollapsed()) {
              return;
            }
            if (hasAnyRanges(editor) && !isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
              editor.nodeChanged({ selectionChange: true });
            }
          });
          editor.on("MouseUp", function(e) {
            if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
              if (editor.selection.getNode().nodeName === "IMG") {
                Delay.setEditorTimeout(editor, function() {
                  editor.nodeChanged();
                });
              } else {
                editor.nodeChanged();
              }
            }
          });
          this.nodeChanged = function(args) {
            var selection = editor.selection;
            var node2, parents2, root;
            if (editor.initialized && selection && !editor.settings.disable_nodechange && !editor.readonly) {
              root = editor.getBody();
              node2 = selection.getStart(true) || root;
              if (node2.ownerDocument !== editor.getDoc() || !editor.dom.isChildOf(node2, root)) {
                node2 = root;
              }
              parents2 = [];
              editor.dom.getParent(node2, function(node3) {
                if (node3 === root) {
                  return true;
                }
                parents2.push(node3);
              });
              args = args || {};
              args.element = node2;
              args.parents = parents2;
              editor.fire("NodeChange", args);
            }
          };
        }
        var VK = {
          BACKSPACE: 8,
          DELETE: 46,
          DOWN: 40,
          ENTER: 13,
          LEFT: 37,
          RIGHT: 39,
          SPACEBAR: 32,
          TAB: 9,
          UP: 38,
          END: 35,
          HOME: 36,
          modifierPressed: function(e) {
            return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);
          },
          metaKeyPressed: function(e) {
            return Env.mac ? e.metaKey : e.ctrlKey && !e.altKey;
          }
        };
        var getNodeClientRects = function(node2) {
          var toArrayWithNode = function(clientRects) {
            return map(clientRects, function(clientRect) {
              clientRect = clone$1(clientRect);
              clientRect.node = node2;
              return clientRect;
            });
          };
          if (NodeType.isElement(node2)) {
            return toArrayWithNode(node2.getClientRects());
          }
          if (NodeType.isText(node2)) {
            var rng = node2.ownerDocument.createRange();
            rng.setStart(node2, 0);
            rng.setEnd(node2, node2.data.length);
            return toArrayWithNode(rng.getClientRects());
          }
        };
        var getClientRects = function(node2) {
          return foldl(node2, function(result, node3) {
            return result.concat(getNodeClientRects(node3));
          }, []);
        };
        var VDirection;
        (function(VDirection2) {
          VDirection2[VDirection2["Up"] = -1] = "Up";
          VDirection2[VDirection2["Down"] = 1] = "Down";
        })(VDirection || (VDirection = {}));
        var findUntil = function(direction, root, predicateFn, node2) {
          while (node2 = findNode(node2, direction, isEditableCaretCandidate, root)) {
            if (predicateFn(node2)) {
              return;
            }
          }
        };
        var walkUntil = function(direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) {
          var line = 0, node2;
          var result = [];
          var targetClientRect;
          var add2 = function(node3) {
            var i2, clientRect, clientRects;
            clientRects = getClientRects([node3]);
            if (direction === -1) {
              clientRects = clientRects.reverse();
            }
            for (i2 = 0; i2 < clientRects.length; i2++) {
              clientRect = clientRects[i2];
              if (isBeflowFn(clientRect, targetClientRect)) {
                continue;
              }
              if (result.length > 0 && isAboveFn(clientRect, ArrUtils.last(result))) {
                line++;
              }
              clientRect.line = line;
              if (predicateFn(clientRect)) {
                return true;
              }
              result.push(clientRect);
            }
          };
          targetClientRect = ArrUtils.last(caretPosition.getClientRects());
          if (!targetClientRect) {
            return result;
          }
          node2 = caretPosition.getNode();
          add2(node2);
          findUntil(direction, root, add2, node2);
          return result;
        };
        var aboveLineNumber = function(lineNumber, clientRect) {
          return clientRect.line > lineNumber;
        };
        var isLineNumber = function(lineNumber, clientRect) {
          return clientRect.line === lineNumber;
        };
        var upUntil = curry(walkUntil, VDirection.Up, isAbove, isBelow);
        var downUntil = curry(walkUntil, VDirection.Down, isBelow, isAbove);
        var positionsUntil = function(direction, root, predicateFn, node2) {
          var caretWalker = CaretWalker(root);
          var walkFn, isBelowFn, isAboveFn, caretPosition;
          var result = [];
          var line = 0, clientRect, targetClientRect;
          var getClientRect = function(caretPosition2) {
            if (direction === 1) {
              return ArrUtils.last(caretPosition2.getClientRects());
            }
            return ArrUtils.last(caretPosition2.getClientRects());
          };
          if (direction === 1) {
            walkFn = caretWalker.next;
            isBelowFn = isBelow;
            isAboveFn = isAbove;
            caretPosition = CaretPosition$1.after(node2);
          } else {
            walkFn = caretWalker.prev;
            isBelowFn = isAbove;
            isAboveFn = isBelow;
            caretPosition = CaretPosition$1.before(node2);
          }
          targetClientRect = getClientRect(caretPosition);
          do {
            if (!caretPosition.isVisible()) {
              continue;
            }
            clientRect = getClientRect(caretPosition);
            if (isAboveFn(clientRect, targetClientRect)) {
              continue;
            }
            if (result.length > 0 && isBelowFn(clientRect, ArrUtils.last(result))) {
              line++;
            }
            clientRect = clone$1(clientRect);
            clientRect.position = caretPosition;
            clientRect.line = line;
            if (predicateFn(clientRect)) {
              return result;
            }
            result.push(clientRect);
          } while (caretPosition = walkFn(caretPosition));
          return result;
        };
        var isAboveLine = function(lineNumber) {
          return function(clientRect) {
            return aboveLineNumber(lineNumber, clientRect);
          };
        };
        var isLine = function(lineNumber) {
          return function(clientRect) {
            return isLineNumber(lineNumber, clientRect);
          };
        };
        var isContentEditableFalse$7 = NodeType.isContentEditableFalse;
        var findNode$1 = findNode;
        var distanceToRectLeft = function(clientRect, clientX) {
          return Math.abs(clientRect.left - clientX);
        };
        var distanceToRectRight = function(clientRect, clientX) {
          return Math.abs(clientRect.right - clientX);
        };
        var isInside = function(clientX, clientRect) {
          return clientX >= clientRect.left && clientX <= clientRect.right;
        };
        var findClosestClientRect = function(clientRects, clientX) {
          return ArrUtils.reduce(clientRects, function(oldClientRect, clientRect) {
            var oldDistance, newDistance;
            oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
            newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
            if (isInside(clientX, clientRect)) {
              return clientRect;
            }
            if (isInside(clientX, oldClientRect)) {
              return oldClientRect;
            }
            if (newDistance === oldDistance && isContentEditableFalse$7(clientRect.node)) {
              return clientRect;
            }
            if (newDistance < oldDistance) {
              return clientRect;
            }
            return oldClientRect;
          });
        };
        var walkUntil$1 = function(direction, root, predicateFn, node2) {
          while (node2 = findNode$1(node2, direction, isEditableCaretCandidate, root)) {
            if (predicateFn(node2)) {
              return;
            }
          }
        };
        var findLineNodeRects = function(root, targetNodeRect) {
          var clientRects = [];
          var collect = function(checkPosFn, node2) {
            var lineRects;
            lineRects = filter(getClientRects([node2]), function(clientRect) {
              return !checkPosFn(clientRect, targetNodeRect);
            });
            clientRects = clientRects.concat(lineRects);
            return lineRects.length === 0;
          };
          clientRects.push(targetNodeRect);
          walkUntil$1(VDirection.Up, root, curry(collect, isAbove), targetNodeRect.node);
          walkUntil$1(VDirection.Down, root, curry(collect, isBelow), targetNodeRect.node);
          return clientRects;
        };
        var getFakeCaretTargets = function(root) {
          return filter(from$1(root.getElementsByTagName("*")), isFakeCaretTarget);
        };
        var caretInfo = function(clientRect, clientX) {
          return {
            node: clientRect.node,
            before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
          };
        };
        var closestCaret = function(root, clientX, clientY) {
          var closestNodeRect;
          var contentEditableFalseNodeRects = getClientRects(getFakeCaretTargets(root));
          var targetNodeRects = filter(contentEditableFalseNodeRects, function(rect) {
            return clientY >= rect.top && clientY <= rect.bottom;
          });
          closestNodeRect = findClosestClientRect(targetNodeRects, clientX);
          if (closestNodeRect) {
            closestNodeRect = findClosestClientRect(findLineNodeRects(root, closestNodeRect), clientX);
            if (closestNodeRect && isFakeCaretTarget(closestNodeRect.node)) {
              return caretInfo(closestNodeRect, clientX);
            }
          }
          return null;
        };
        var isXYWithinRange = function(clientX, clientY, range2) {
          if (range2.collapsed) {
            return false;
          }
          if (Env.ie && Env.ie <= 11 && range2.startOffset === range2.endOffset - 1 && range2.startContainer === range2.endContainer) {
            var elm = range2.startContainer.childNodes[range2.startOffset];
            if (NodeType.isElement(elm)) {
              return exists(elm.getClientRects(), function(rect) {
                return containsXY(rect, clientX, clientY);
              });
            }
          }
          return exists(range2.getClientRects(), function(rect) {
            return containsXY(rect, clientX, clientY);
          });
        };
        var RangePoint = { isXYWithinRange };
        var getAbsolutePosition = function(elm) {
          var doc2, docElem2, win, clientRect;
          clientRect = elm.getBoundingClientRect();
          doc2 = elm.ownerDocument;
          docElem2 = doc2.documentElement;
          win = doc2.defaultView;
          return {
            top: clientRect.top + win.pageYOffset - docElem2.clientTop,
            left: clientRect.left + win.pageXOffset - docElem2.clientLeft
          };
        };
        var getBodyPosition = function(editor) {
          return editor.inline ? getAbsolutePosition(editor.getBody()) : {
            left: 0,
            top: 0
          };
        };
        var getScrollPosition = function(editor) {
          var body = editor.getBody();
          return editor.inline ? {
            left: body.scrollLeft,
            top: body.scrollTop
          } : {
            left: 0,
            top: 0
          };
        };
        var getBodyScroll = function(editor) {
          var body = editor.getBody(), docElm = editor.getDoc().documentElement;
          var inlineScroll = {
            left: body.scrollLeft,
            top: body.scrollTop
          };
          var iframeScroll = {
            left: body.scrollLeft || docElm.scrollLeft,
            top: body.scrollTop || docElm.scrollTop
          };
          return editor.inline ? inlineScroll : iframeScroll;
        };
        var getMousePosition = function(editor, event) {
          if (event.target.ownerDocument !== editor.getDoc()) {
            var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
            var scrollPosition = getBodyScroll(editor);
            return {
              left: event.pageX - iframePosition.left + scrollPosition.left,
              top: event.pageY - iframePosition.top + scrollPosition.top
            };
          }
          return {
            left: event.pageX,
            top: event.pageY
          };
        };
        var calculatePosition = function(bodyPosition, scrollPosition, mousePosition) {
          return {
            pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
            pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
          };
        };
        var calc = function(editor, event) {
          return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
        };
        var MousePosition = { calc };
        var isContentEditableFalse$8 = NodeType.isContentEditableFalse, isContentEditableTrue$3 = NodeType.isContentEditableTrue;
        var isDraggable = function(rootElm, elm) {
          return isContentEditableFalse$8(elm) && elm !== rootElm;
        };
        var isValidDropTarget = function(editor, targetElement, dragElement) {
          if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
            return false;
          }
          if (isContentEditableFalse$8(targetElement)) {
            return false;
          }
          return true;
        };
        var cloneElement = function(elm) {
          var cloneElm = elm.cloneNode(true);
          cloneElm.removeAttribute("data-mce-selected");
          return cloneElm;
        };
        var createGhost = function(editor, elm, width, height) {
          var clonedElm = elm.cloneNode(true);
          editor.dom.setStyles(clonedElm, {
            width,
            height
          });
          editor.dom.setAttrib(clonedElm, "data-mce-selected", null);
          var ghostElm = editor.dom.create("div", {
            "class": "mce-drag-container",
            "data-mce-bogus": "all",
            "unselectable": "on",
            "contenteditable": "false"
          });
          editor.dom.setStyles(ghostElm, {
            position: "absolute",
            opacity: 0.5,
            overflow: "hidden",
            border: 0,
            padding: 0,
            margin: 0,
            width,
            height
          });
          editor.dom.setStyles(clonedElm, {
            margin: 0,
            boxSizing: "border-box"
          });
          ghostElm.appendChild(clonedElm);
          return ghostElm;
        };
        var appendGhostToBody = function(ghostElm, bodyElm) {
          if (ghostElm.parentNode !== bodyElm) {
            bodyElm.appendChild(ghostElm);
          }
        };
        var moveGhost = function(ghostElm, position, width, height, maxX, maxY) {
          var overflowX2 = 0, overflowY2 = 0;
          ghostElm.style.left = position.pageX + "px";
          ghostElm.style.top = position.pageY + "px";
          if (position.pageX + width > maxX) {
            overflowX2 = position.pageX + width - maxX;
          }
          if (position.pageY + height > maxY) {
            overflowY2 = position.pageY + height - maxY;
          }
          ghostElm.style.width = width - overflowX2 + "px";
          ghostElm.style.height = height - overflowY2 + "px";
        };
        var removeElement = function(elm) {
          if (elm && elm.parentNode) {
            elm.parentNode.removeChild(elm);
          }
        };
        var isLeftMouseButtonPressed = function(e) {
          return e.button === 0;
        };
        var hasDraggableElement = function(state) {
          return state.element;
        };
        var applyRelPos = function(state, position) {
          return {
            pageX: position.pageX - state.relX,
            pageY: position.pageY + 5
          };
        };
        var start$1 = function(state, editor) {
          return function(e) {
            if (isLeftMouseButtonPressed(e)) {
              var ceElm = find(editor.dom.getParents(e.target), Predicate.or(isContentEditableFalse$8, isContentEditableTrue$3)).getOr(null);
              if (isDraggable(editor.getBody(), ceElm)) {
                var elmPos = editor.dom.getPos(ceElm);
                var bodyElm = editor.getBody();
                var docElm = editor.getDoc().documentElement;
                state.element = ceElm;
                state.screenX = e.screenX;
                state.screenY = e.screenY;
                state.maxX = (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2;
                state.maxY = (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2;
                state.relX = e.pageX - elmPos.x;
                state.relY = e.pageY - elmPos.y;
                state.width = ceElm.offsetWidth;
                state.height = ceElm.offsetHeight;
                state.ghost = createGhost(editor, ceElm, state.width, state.height);
              }
            }
          };
        };
        var move$1 = function(state, editor) {
          var throttledPlaceCaretAt = Delay.throttle(function(clientX, clientY) {
            editor._selectionOverrides.hideFakeCaret();
            editor.selection.placeCaretAt(clientX, clientY);
          }, 0);
          return function(e) {
            var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
            if (hasDraggableElement(state) && !state.dragging && movement > 10) {
              var args = editor.fire("dragstart", { target: state.element });
              if (args.isDefaultPrevented()) {
                return;
              }
              state.dragging = true;
              editor.focus();
            }
            if (state.dragging) {
              var targetPos = applyRelPos(state, MousePosition.calc(editor, e));
              appendGhostToBody(state.ghost, editor.getBody());
              moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);
              throttledPlaceCaretAt(e.clientX, e.clientY);
            }
          };
        };
        var getRawTarget = function(selection) {
          var rng = selection.getSel().getRangeAt(0);
          var startContainer = rng.startContainer;
          return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
        };
        var drop = function(state, editor) {
          return function(e) {
            if (state.dragging) {
              if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
                var targetClone_1 = cloneElement(state.element);
                var args = editor.fire("drop", {
                  targetClone: targetClone_1,
                  clientX: e.clientX,
                  clientY: e.clientY
                });
                if (!args.isDefaultPrevented()) {
                  targetClone_1 = args.targetClone;
                  editor.undoManager.transact(function() {
                    removeElement(state.element);
                    editor.insertContent(editor.dom.getOuterHTML(targetClone_1));
                    editor._selectionOverrides.hideFakeCaret();
                  });
                }
              }
            }
            removeDragState(state);
          };
        };
        var stop = function(state, editor) {
          return function() {
            if (state.dragging) {
              editor.fire("dragend");
            }
            removeDragState(state);
          };
        };
        var removeDragState = function(state) {
          state.dragging = false;
          state.element = null;
          removeElement(state.ghost);
        };
        var bindFakeDragEvents = function(editor) {
          var state = {};
          var pageDom, dragStartHandler, dragHandler, dropHandler, dragEndHandler, rootDocument;
          pageDom = DOMUtils$1.DOM;
          rootDocument = domGlobals.document;
          dragStartHandler = start$1(state, editor);
          dragHandler = move$1(state, editor);
          dropHandler = drop(state, editor);
          dragEndHandler = stop(state, editor);
          editor.on("mousedown", dragStartHandler);
          editor.on("mousemove", dragHandler);
          editor.on("mouseup", dropHandler);
          pageDom.bind(rootDocument, "mousemove", dragHandler);
          pageDom.bind(rootDocument, "mouseup", dragEndHandler);
          editor.on("remove", function() {
            pageDom.unbind(rootDocument, "mousemove", dragHandler);
            pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
          });
        };
        var blockIeDrop = function(editor) {
          editor.on("drop", function(e) {
            var realTarget = typeof e.clientX !== "undefined" ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
            if (isContentEditableFalse$8(realTarget) || isContentEditableFalse$8(editor.dom.getContentEditableParent(realTarget))) {
              e.preventDefault();
            }
          });
        };
        var init = function(editor) {
          bindFakeDragEvents(editor);
          blockIeDrop(editor);
        };
        var DragDropOverrides = { init };
        var setup$4 = function(editor) {
          var renderFocusCaret = first(function() {
            if (!editor.removed) {
              var rng = editor.selection.getRng();
              if (rng.collapsed) {
                var caretRange = renderRangeCaret(editor, editor.selection.getRng(), false);
                editor.selection.setRng(caretRange);
              }
            }
          }, 0);
          editor.on("focus", function() {
            renderFocusCaret.throttle();
          });
          editor.on("blur", function() {
            renderFocusCaret.cancel();
          });
        };
        var CefFocus = { setup: setup$4 };
        var isContentEditableTrue$4 = NodeType.isContentEditableTrue;
        var isContentEditableFalse$9 = NodeType.isContentEditableFalse;
        var getContentEditableRoot$1 = function(editor, node2) {
          var root = editor.getBody();
          while (node2 && node2 !== root) {
            if (isContentEditableTrue$4(node2) || isContentEditableFalse$9(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var SelectionOverrides = function(editor) {
          var isBlock2 = function(node2) {
            return editor.dom.isBlock(node2);
          };
          var rootNode = editor.getBody();
          var fakeCaret = FakeCaret(editor.getBody(), isBlock2, function() {
            return EditorFocus.hasFocus(editor);
          });
          var realSelectionId = "sel-" + editor.dom.uniqueId();
          var selectedContentEditableNode;
          var isFakeSelectionElement = function(elm) {
            return editor.dom.hasClass(elm, "mce-offscreen-selection");
          };
          var getRealSelectionElement = function() {
            var container = editor.dom.get(realSelectionId);
            return container ? container.getElementsByTagName("*")[0] : container;
          };
          var setRange = function(range2) {
            if (range2) {
              editor.selection.setRng(range2);
            }
          };
          var getRange = function() {
            return editor.selection.getRng();
          };
          var showCaret2 = function(direction, node2, before2, scrollIntoView) {
            if (scrollIntoView === void 0) {
              scrollIntoView = true;
            }
            var e;
            e = editor.fire("ShowCaret", {
              target: node2,
              direction,
              before: before2
            });
            if (e.isDefaultPrevented()) {
              return null;
            }
            if (scrollIntoView) {
              editor.selection.scrollIntoView(node2, direction === -1);
            }
            return fakeCaret.show(before2, node2);
          };
          var getNormalizedRangeEndPoint2 = function(direction, range2) {
            range2 = normalizeRange(direction, rootNode, range2);
            if (direction === -1) {
              return CaretPosition$1.fromRangeStart(range2);
            }
            return CaretPosition$1.fromRangeEnd(range2);
          };
          var showBlockCaretContainer2 = function(blockCaretContainer) {
            if (blockCaretContainer.hasAttribute("data-mce-caret")) {
              showCaretContainerBlock(blockCaretContainer);
              setRange(getRange());
              editor.selection.scrollIntoView(blockCaretContainer[0]);
            }
          };
          var registerEvents2 = function() {
            editor.on("mouseup", function(e) {
              var range2 = getRange();
              if (range2.collapsed && EditorView.isXYInContentArea(editor, e.clientX, e.clientY)) {
                setRange(renderCaretAtRange(editor, range2, false));
              }
            });
            editor.on("click", function(e) {
              var contentEditableRoot;
              contentEditableRoot = getContentEditableRoot$1(editor, e.target);
              if (contentEditableRoot) {
                if (isContentEditableFalse$9(contentEditableRoot)) {
                  e.preventDefault();
                  editor.focus();
                }
                if (isContentEditableTrue$4(contentEditableRoot)) {
                  if (editor.dom.isChildOf(contentEditableRoot, editor.selection.getNode())) {
                    removeContentEditableSelection();
                  }
                }
              }
            });
            editor.on("blur NewBlock", function() {
              removeContentEditableSelection();
            });
            editor.on("ResizeWindow FullscreenStateChanged", function() {
              return fakeCaret.reposition();
            });
            var handleTouchSelect = function(editor2) {
              var moved = false;
              editor2.on("touchstart", function() {
                moved = false;
              });
              editor2.on("touchmove", function() {
                moved = true;
              });
              editor2.on("touchend", function(e) {
                var contentEditableRoot = getContentEditableRoot$1(editor2, e.target);
                if (isContentEditableFalse$9(contentEditableRoot)) {
                  if (!moved) {
                    e.preventDefault();
                    setContentEditableSelection(selectNode(editor2, contentEditableRoot));
                  }
                }
              });
            };
            var hasNormalCaretPosition = function(elm) {
              var caretWalker = CaretWalker(elm);
              if (!elm.firstChild) {
                return false;
              }
              var startPos = CaretPosition$1.before(elm.firstChild);
              var newPos = caretWalker.next(startPos);
              return newPos && !isBeforeContentEditableFalse(newPos) && !isAfterContentEditableFalse(newPos);
            };
            var isInSameBlock2 = function(node1, node2) {
              var block1 = editor.dom.getParent(node1, editor.dom.isBlock);
              var block2 = editor.dom.getParent(node2, editor.dom.isBlock);
              return block1 === block2;
            };
            var hasBetterMouseTarget = function(targetNode, caretNode) {
              var targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
              var caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);
              if (targetBlock && editor.dom.isChildOf(targetBlock, caretBlock) && isContentEditableFalse$9(getContentEditableRoot$1(editor, targetBlock)) === false) {
                return true;
              }
              return targetBlock && !isInSameBlock2(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
            };
            handleTouchSelect(editor);
            editor.on("mousedown", function(e) {
              var contentEditableRoot;
              var targetElm = e.target;
              if (targetElm !== rootNode && targetElm.nodeName !== "HTML" && !editor.dom.isChildOf(targetElm, rootNode)) {
                return;
              }
              if (EditorView.isXYInContentArea(editor, e.clientX, e.clientY) === false) {
                return;
              }
              contentEditableRoot = getContentEditableRoot$1(editor, targetElm);
              if (contentEditableRoot) {
                if (isContentEditableFalse$9(contentEditableRoot)) {
                  e.preventDefault();
                  setContentEditableSelection(selectNode(editor, contentEditableRoot));
                } else {
                  removeContentEditableSelection();
                  if (!(isContentEditableTrue$4(contentEditableRoot) && e.shiftKey) && !RangePoint.isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
                    hideFakeCaret();
                    editor.selection.placeCaretAt(e.clientX, e.clientY);
                  }
                }
              } else if (isFakeCaretTarget(targetElm) === false) {
                removeContentEditableSelection();
                hideFakeCaret();
                var caretInfo2 = closestCaret(rootNode, e.clientX, e.clientY);
                if (caretInfo2) {
                  if (!hasBetterMouseTarget(e.target, caretInfo2.node)) {
                    e.preventDefault();
                    var range2 = showCaret2(1, caretInfo2.node, caretInfo2.before, false);
                    editor.getBody().focus();
                    setRange(range2);
                  }
                }
              }
            });
            editor.on("keypress", function(e) {
              if (VK.modifierPressed(e)) {
                return;
              }
              switch (e.keyCode) {
                default:
                  if (isContentEditableFalse$9(editor.selection.getNode())) {
                    e.preventDefault();
                  }
                  break;
              }
            });
            editor.on("getSelectionRange", function(e) {
              var rng = e.range;
              if (selectedContentEditableNode) {
                if (!selectedContentEditableNode.parentNode) {
                  selectedContentEditableNode = null;
                  return;
                }
                rng = rng.cloneRange();
                rng.selectNode(selectedContentEditableNode);
                e.range = rng;
              }
            });
            editor.on("setSelectionRange", function(e) {
              e.range = normalizeShortEndedElementSelection(e.range);
              var rng = setContentEditableSelection(e.range, e.forward);
              if (rng) {
                e.range = rng;
              }
            });
            var isPasteBin = function(node2) {
              return node2.id === "mcepastebin";
            };
            editor.on("AfterSetSelectionRange", function(e) {
              var rng = e.range;
              if (!isRangeInCaretContainer(rng) && !isPasteBin(rng.startContainer.parentNode)) {
                hideFakeCaret();
              }
              if (!isFakeSelectionElement(rng.startContainer.parentNode)) {
                removeContentEditableSelection();
              }
            });
            editor.on("copy", function(e) {
              var clipboardData = e.clipboardData;
              if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {
                var realSelectionElement = getRealSelectionElement();
                if (realSelectionElement) {
                  e.preventDefault();
                  clipboardData.clearData();
                  clipboardData.setData("text/html", realSelectionElement.outerHTML);
                  clipboardData.setData("text/plain", realSelectionElement.outerText);
                }
              }
            });
            DragDropOverrides.init(editor);
            CefFocus.setup(editor);
          };
          var addCss = function() {
            var styles = editor.contentStyles, rootClass = ".mce-content-body";
            styles.push(fakeCaret.getCss());
            styles.push(rootClass + " .mce-offscreen-selection {position: absolute;left: -9999999999px;max-width: 1000000px;}" + rootClass + " *[contentEditable=false] {cursor: default;}" + rootClass + " *[contentEditable=true] {cursor: text;}");
          };
          var isWithinCaretContainer = function(node2) {
            return isCaretContainer(node2) || startsWithCaretContainer(node2) || endsWithCaretContainer(node2);
          };
          var isRangeInCaretContainer = function(rng) {
            return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
          };
          var normalizeShortEndedElementSelection = function(rng) {
            var shortEndedElements = editor.schema.getShortEndedElements();
            var newRng = editor.dom.createRng();
            var startContainer = rng.startContainer;
            var startOffset = rng.startOffset;
            var endContainer = rng.endContainer;
            var endOffset = rng.endOffset;
            if (has(shortEndedElements, startContainer.nodeName.toLowerCase())) {
              if (startOffset === 0) {
                newRng.setStartBefore(startContainer);
              } else {
                newRng.setStartAfter(startContainer);
              }
            } else {
              newRng.setStart(startContainer, startOffset);
            }
            if (has(shortEndedElements, endContainer.nodeName.toLowerCase())) {
              if (endOffset === 0) {
                newRng.setEndBefore(endContainer);
              } else {
                newRng.setEndAfter(endContainer);
              }
            } else {
              newRng.setEnd(endContainer, endOffset);
            }
            return newRng;
          };
          var setContentEditableSelection = function(range2, forward) {
            var node2;
            var $ = editor.$;
            var dom2 = editor.dom;
            var $realSelectionContainer, sel, startContainer, startOffset, endOffset, e, caretPosition, targetClone, origTargetClone;
            if (!range2) {
              return null;
            }
            if (range2.collapsed) {
              if (!isRangeInCaretContainer(range2)) {
                if (forward === false) {
                  caretPosition = getNormalizedRangeEndPoint2(-1, range2);
                  if (isFakeCaretTarget(caretPosition.getNode(true))) {
                    return showCaret2(-1, caretPosition.getNode(true), false, false);
                  }
                  if (isFakeCaretTarget(caretPosition.getNode())) {
                    return showCaret2(-1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
                  }
                } else {
                  caretPosition = getNormalizedRangeEndPoint2(1, range2);
                  if (isFakeCaretTarget(caretPosition.getNode())) {
                    return showCaret2(1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
                  }
                  if (isFakeCaretTarget(caretPosition.getNode(true))) {
                    return showCaret2(1, caretPosition.getNode(true), false, false);
                  }
                }
              }
              return null;
            }
            startContainer = range2.startContainer;
            startOffset = range2.startOffset;
            endOffset = range2.endOffset;
            if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse$9(startContainer.parentNode)) {
              startContainer = startContainer.parentNode;
              startOffset = dom2.nodeIndex(startContainer);
              startContainer = startContainer.parentNode;
            }
            if (startContainer.nodeType !== 1) {
              return null;
            }
            if (endOffset === startOffset + 1 && startContainer === range2.endContainer) {
              node2 = startContainer.childNodes[startOffset];
            }
            if (!isContentEditableFalse$9(node2)) {
              return null;
            }
            targetClone = origTargetClone = node2.cloneNode(true);
            e = editor.fire("ObjectSelected", {
              target: node2,
              targetClone
            });
            if (e.isDefaultPrevented()) {
              return null;
            }
            $realSelectionContainer = descendant(Element.fromDom(editor.getBody()), "#" + realSelectionId).fold(function() {
              return $([]);
            }, function(elm) {
              return $([elm.dom()]);
            });
            targetClone = e.targetClone;
            if ($realSelectionContainer.length === 0) {
              $realSelectionContainer = $('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr("id", realSelectionId);
              $realSelectionContainer.appendTo(editor.getBody());
            }
            range2 = editor.dom.createRng();
            if (targetClone === origTargetClone && Env.ie) {
              $realSelectionContainer.empty().append('<p style="font-size: 0" data-mce-bogus="all">\xA0</p>').append(targetClone);
              range2.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
              range2.setEndAfter(targetClone);
            } else {
              $realSelectionContainer.empty().append("\xA0").append(targetClone).append("\xA0");
              range2.setStart($realSelectionContainer[0].firstChild, 1);
              range2.setEnd($realSelectionContainer[0].lastChild, 0);
            }
            $realSelectionContainer.css({ top: dom2.getPos(node2, editor.getBody()).y });
            $realSelectionContainer[0].focus();
            sel = editor.selection.getSel();
            sel.removeAllRanges();
            sel.addRange(range2);
            each(descendants$1(Element.fromDom(editor.getBody()), "*[data-mce-selected]"), function(elm) {
              remove(elm, "data-mce-selected");
            });
            node2.setAttribute("data-mce-selected", "1");
            selectedContentEditableNode = node2;
            hideFakeCaret();
            return range2;
          };
          var removeContentEditableSelection = function() {
            if (selectedContentEditableNode) {
              selectedContentEditableNode.removeAttribute("data-mce-selected");
              descendant(Element.fromDom(editor.getBody()), "#" + realSelectionId).each(remove$1);
              selectedContentEditableNode = null;
            }
            descendant(Element.fromDom(editor.getBody()), "#" + realSelectionId).each(remove$1);
            selectedContentEditableNode = null;
          };
          var destroy2 = function() {
            fakeCaret.destroy();
            selectedContentEditableNode = null;
          };
          var hideFakeCaret = function() {
            fakeCaret.hide();
          };
          if (Env.ceFalse) {
            registerEvents2();
            addCss();
          }
          return {
            showCaret: showCaret2,
            showBlockCaretContainer: showBlockCaretContainer2,
            hideFakeCaret,
            destroy: destroy2
          };
        };
        var isValidPrefixAttrName = function(name2) {
          return name2.indexOf("data-") === 0 || name2.indexOf("aria-") === 0;
        };
        var trimComments = function(text) {
          var sanitizedText = text;
          while (/<!--|--!?>/g.test(sanitizedText)) {
            sanitizedText = sanitizedText.replace(/<!--|--!?>/g, "");
          }
          return sanitizedText;
        };
        var isInvalidUri = function(settings, uri) {
          if (settings.allow_html_data_urls) {
            return false;
          } else if (/^data:image\//i.test(uri)) {
            return settings.allow_svg_data_urls === false && /^data:image\/svg\+xml/i.test(uri);
          } else {
            return /^data:/i.test(uri);
          }
        };
        var findEndTagIndex = function(schema, html, startIndex) {
          var count2 = 1, index, matches2, tokenRegExp, shortEndedElements;
          shortEndedElements = schema.getShortEndedElements();
          tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g;
          tokenRegExp.lastIndex = index = startIndex;
          while (matches2 = tokenRegExp.exec(html)) {
            index = tokenRegExp.lastIndex;
            if (matches2[1] === "/") {
              count2--;
            } else if (!matches2[1]) {
              if (matches2[2] in shortEndedElements) {
                continue;
              }
              count2++;
            }
            if (count2 === 0) {
              break;
            }
          }
          return index;
        };
        var checkBogusAttribute = function(regExp, attrString) {
          var matches2 = regExp.exec(attrString);
          if (matches2) {
            var name2 = matches2[1];
            var value2 = matches2[2];
            return typeof name2 === "string" && name2.toLowerCase() === "data-mce-bogus" ? value2 : null;
          } else {
            return null;
          }
        };
        function SaxParser(settings, schema) {
          if (schema === void 0) {
            schema = Schema();
          }
          var noop2 = function() {
          };
          settings = settings || {};
          if (settings.fix_self_closing !== false) {
            settings.fix_self_closing = true;
          }
          var comment = settings.comment ? settings.comment : noop2;
          var cdata = settings.cdata ? settings.cdata : noop2;
          var text = settings.text ? settings.text : noop2;
          var start2 = settings.start ? settings.start : noop2;
          var end2 = settings.end ? settings.end : noop2;
          var pi = settings.pi ? settings.pi : noop2;
          var doctype = settings.doctype ? settings.doctype : noop2;
          var parse = function(html) {
            var matches2, index = 0, value2, endRegExp;
            var stack = [];
            var attrList, i2, textData, name2;
            var isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
            var validate2, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
            var attributesRequired, attributesDefault, attributesForced, processHtml;
            var anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;
            var decode2 = Entities.decode;
            var fixSelfClosing;
            var filteredUrlAttrs = Tools.makeMap("src,href,data,background,formaction,poster,xlink:href");
            var scriptUriRegExp = /((java|vb)script|mhtml):/i;
            var processEndTag = function(name3) {
              var pos, i3;
              pos = stack.length;
              while (pos--) {
                if (stack[pos].name === name3) {
                  break;
                }
              }
              if (pos >= 0) {
                for (i3 = stack.length - 1; i3 >= pos; i3--) {
                  name3 = stack[i3];
                  if (name3.valid) {
                    end2(name3.name);
                  }
                }
                stack.length = pos;
              }
            };
            var parseAttribute = function(match2, name3, value3, val2, val3) {
              var attrRule, i3;
              var trimRegExp = /[\s\u0000-\u001F]+/g;
              name3 = name3.toLowerCase();
              value3 = name3 in fillAttrsMap ? name3 : decode2(value3 || val2 || val3 || "");
              if (validate2 && !isInternalElement && isValidPrefixAttrName(name3) === false) {
                attrRule = validAttributesMap[name3];
                if (!attrRule && validAttributePatterns) {
                  i3 = validAttributePatterns.length;
                  while (i3--) {
                    attrRule = validAttributePatterns[i3];
                    if (attrRule.pattern.test(name3)) {
                      break;
                    }
                  }
                  if (i3 === -1) {
                    attrRule = null;
                  }
                }
                if (!attrRule) {
                  return;
                }
                if (attrRule.validValues && !(value3 in attrRule.validValues)) {
                  return;
                }
              }
              if (filteredUrlAttrs[name3] && !settings.allow_script_urls) {
                var uri = value3.replace(trimRegExp, "");
                try {
                  uri = decodeURIComponent(uri);
                } catch (ex) {
                  uri = unescape(uri);
                }
                if (scriptUriRegExp.test(uri)) {
                  return;
                }
                if (isInvalidUri(settings, uri)) {
                  return;
                }
              }
              if (isInternalElement && (name3 in filteredUrlAttrs || name3.indexOf("on") === 0)) {
                return;
              }
              attrList.map[name3] = value3;
              attrList.push({
                name: name3,
                value: value3
              });
            };
            tokenRegExp = new RegExp(`<(?:(?:!--([\\w\\W]*?)--!?>)|(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|(?:!DOCTYPE([\\w\\W]*?)>)|(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|(?:([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)((?:\\s+[^"'>]+(?:(?:"[^"]*")|(?:'[^']*')|[^>]*))*|\\/|\\s+)>))`, "g");
            attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
            shortEndedElements = schema.getShortEndedElements();
            selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
            fillAttrsMap = schema.getBoolAttrs();
            validate2 = settings.validate;
            removeInternalElements = settings.remove_internals;
            fixSelfClosing = settings.fix_self_closing;
            specialElements = schema.getSpecialElements();
            processHtml = html + ">";
            while (matches2 = tokenRegExp.exec(processHtml)) {
              if (index < matches2.index) {
                text(decode2(html.substr(index, matches2.index - index)));
              }
              if (value2 = matches2[6]) {
                value2 = value2.toLowerCase();
                if (value2.charAt(0) === ":") {
                  value2 = value2.substr(1);
                }
                processEndTag(value2);
              } else if (value2 = matches2[7]) {
                if (matches2.index + matches2[0].length > html.length) {
                  text(decode2(html.substr(matches2.index)));
                  index = matches2.index + matches2[0].length;
                  continue;
                }
                value2 = value2.toLowerCase();
                if (value2.charAt(0) === ":") {
                  value2 = value2.substr(1);
                }
                isShortEnded = value2 in shortEndedElements;
                if (fixSelfClosing && selfClosing[value2] && stack.length > 0 && stack[stack.length - 1].name === value2) {
                  processEndTag(value2);
                }
                var bogusValue = checkBogusAttribute(attrRegExp, matches2[8]);
                if (bogusValue !== null) {
                  if (bogusValue === "all") {
                    index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
                    tokenRegExp.lastIndex = index;
                    continue;
                  }
                  isValidElement = false;
                }
                if (!validate2 || (elementRule = schema.getElementRule(value2))) {
                  isValidElement = true;
                  if (validate2) {
                    validAttributesMap = elementRule.attributes;
                    validAttributePatterns = elementRule.attributePatterns;
                  }
                  if (attribsValue = matches2[8]) {
                    isInternalElement = attribsValue.indexOf("data-mce-type") !== -1;
                    if (isInternalElement && removeInternalElements) {
                      isValidElement = false;
                    }
                    attrList = [];
                    attrList.map = {};
                    attribsValue.replace(attrRegExp, parseAttribute);
                  } else {
                    attrList = [];
                    attrList.map = {};
                  }
                  if (validate2 && !isInternalElement) {
                    attributesRequired = elementRule.attributesRequired;
                    attributesDefault = elementRule.attributesDefault;
                    attributesForced = elementRule.attributesForced;
                    anyAttributesRequired = elementRule.removeEmptyAttrs;
                    if (anyAttributesRequired && !attrList.length) {
                      isValidElement = false;
                    }
                    if (attributesForced) {
                      i2 = attributesForced.length;
                      while (i2--) {
                        attr = attributesForced[i2];
                        name2 = attr.name;
                        attrValue = attr.value;
                        if (attrValue === "{$uid}") {
                          attrValue = "mce_" + idCount++;
                        }
                        attrList.map[name2] = attrValue;
                        attrList.push({
                          name: name2,
                          value: attrValue
                        });
                      }
                    }
                    if (attributesDefault) {
                      i2 = attributesDefault.length;
                      while (i2--) {
                        attr = attributesDefault[i2];
                        name2 = attr.name;
                        if (!(name2 in attrList.map)) {
                          attrValue = attr.value;
                          if (attrValue === "{$uid}") {
                            attrValue = "mce_" + idCount++;
                          }
                          attrList.map[name2] = attrValue;
                          attrList.push({
                            name: name2,
                            value: attrValue
                          });
                        }
                      }
                    }
                    if (attributesRequired) {
                      i2 = attributesRequired.length;
                      while (i2--) {
                        if (attributesRequired[i2] in attrList.map) {
                          break;
                        }
                      }
                      if (i2 === -1) {
                        isValidElement = false;
                      }
                    }
                    if (attr = attrList.map["data-mce-bogus"]) {
                      if (attr === "all") {
                        index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
                        tokenRegExp.lastIndex = index;
                        continue;
                      }
                      isValidElement = false;
                    }
                  }
                  if (isValidElement) {
                    start2(value2, attrList, isShortEnded);
                  }
                } else {
                  isValidElement = false;
                }
                if (endRegExp = specialElements[value2]) {
                  endRegExp.lastIndex = index = matches2.index + matches2[0].length;
                  if (matches2 = endRegExp.exec(html)) {
                    if (isValidElement) {
                      textData = html.substr(index, matches2.index - index);
                    }
                    index = matches2.index + matches2[0].length;
                  } else {
                    textData = html.substr(index);
                    index = html.length;
                  }
                  if (isValidElement) {
                    if (textData.length > 0) {
                      text(textData, true);
                    }
                    end2(value2);
                  }
                  tokenRegExp.lastIndex = index;
                  continue;
                }
                if (!isShortEnded) {
                  if (!attribsValue || attribsValue.indexOf("/") !== attribsValue.length - 1) {
                    stack.push({
                      name: value2,
                      valid: isValidElement
                    });
                  } else if (isValidElement) {
                    end2(value2);
                  }
                }
              } else if (value2 = matches2[1]) {
                if (value2.charAt(0) === ">") {
                  value2 = " " + value2;
                }
                if (!settings.allow_conditional_comments && value2.substr(0, 3).toLowerCase() === "[if") {
                  value2 = " " + value2;
                }
                comment(value2);
              } else if (value2 = matches2[2]) {
                cdata(trimComments(value2));
              } else if (value2 = matches2[3]) {
                doctype(value2);
              } else if (value2 = matches2[4]) {
                pi(value2, matches2[5]);
              }
              index = matches2.index + matches2[0].length;
            }
            if (index < html.length) {
              text(decode2(html.substr(index)));
            }
            for (i2 = stack.length - 1; i2 >= 0; i2--) {
              value2 = stack[i2];
              if (value2.valid) {
                end2(value2.name);
              }
            }
          };
          return { parse };
        }
        (function(SaxParser2) {
          SaxParser2.findEndTag = findEndTagIndex;
        })(SaxParser || (SaxParser = {}));
        var SaxParser$1 = SaxParser;
        var trimHtml = function(tempAttrs, html) {
          var trimContentRegExp = new RegExp(["\\s?(" + tempAttrs.join("|") + ')="[^"]+"'].join("|"), "gi");
          return html.replace(trimContentRegExp, "");
        };
        var trimInternal = function(serializer, html) {
          var content = html;
          var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
          var endTagIndex, index, matchLength, matches2, shortEndedElements;
          var schema = serializer.schema;
          content = trimHtml(serializer.getTempAttrs(), content);
          shortEndedElements = schema.getShortEndedElements();
          while (matches2 = bogusAllRegExp.exec(content)) {
            index = bogusAllRegExp.lastIndex;
            matchLength = matches2[0].length;
            if (shortEndedElements[matches2[1]]) {
              endTagIndex = index;
            } else {
              endTagIndex = SaxParser$1.findEndTag(schema, content, index);
            }
            content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
            bogusAllRegExp.lastIndex = index - matchLength;
          }
          return Zwsp.trim(content);
        };
        var trimExternal = trimInternal;
        var TrimHtml = {
          trimExternal,
          trimInternal
        };
        var KEEP = 0, INSERT = 1, DELETE = 2;
        var diff = function(left, right) {
          var size = left.length + right.length + 2;
          var vDown = new Array(size);
          var vUp = new Array(size);
          var snake = function(start2, end2, diag) {
            return {
              start: start2,
              end: end2,
              diag
            };
          };
          var buildScript = function(start1, end1, start2, end2, script2) {
            var middle = getMiddleSnake(start1, end1, start2, end2);
            if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
              var i2 = start1;
              var j = start2;
              while (i2 < end1 || j < end2) {
                if (i2 < end1 && j < end2 && left[i2] === right[j]) {
                  script2.push([
                    KEEP,
                    left[i2]
                  ]);
                  ++i2;
                  ++j;
                } else {
                  if (end1 - start1 > end2 - start2) {
                    script2.push([
                      DELETE,
                      left[i2]
                    ]);
                    ++i2;
                  } else {
                    script2.push([
                      INSERT,
                      right[j]
                    ]);
                    ++j;
                  }
                }
              }
            } else {
              buildScript(start1, middle.start, start2, middle.start - middle.diag, script2);
              for (var i22 = middle.start; i22 < middle.end; ++i22) {
                script2.push([
                  KEEP,
                  left[i22]
                ]);
              }
              buildScript(middle.end, end1, middle.end - middle.diag, end2, script2);
            }
          };
          var buildSnake = function(start2, diag, end1, end2) {
            var end3 = start2;
            while (end3 - diag < end2 && end3 < end1 && left[end3] === right[end3 - diag]) {
              ++end3;
            }
            return snake(start2, end3, diag);
          };
          var getMiddleSnake = function(start1, end1, start2, end2) {
            var m = end1 - start1;
            var n = end2 - start2;
            if (m === 0 || n === 0) {
              return null;
            }
            var delta = m - n;
            var sum = n + m;
            var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
            vDown[1 + offset] = start1;
            vUp[1 + offset] = end1 + 1;
            var d, k, i2, x, y;
            for (d = 0; d <= offset; ++d) {
              for (k = -d; k <= d; k += 2) {
                i2 = k + offset;
                if (k === -d || k !== d && vDown[i2 - 1] < vDown[i2 + 1]) {
                  vDown[i2] = vDown[i2 + 1];
                } else {
                  vDown[i2] = vDown[i2 - 1] + 1;
                }
                x = vDown[i2];
                y = x - start1 + start2 - k;
                while (x < end1 && y < end2 && left[x] === right[y]) {
                  vDown[i2] = ++x;
                  ++y;
                }
                if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
                  if (vUp[i2 - delta] <= vDown[i2]) {
                    return buildSnake(vUp[i2 - delta], k + start1 - start2, end1, end2);
                  }
                }
              }
              for (k = delta - d; k <= delta + d; k += 2) {
                i2 = k + offset - delta;
                if (k === delta - d || k !== delta + d && vUp[i2 + 1] <= vUp[i2 - 1]) {
                  vUp[i2] = vUp[i2 + 1] - 1;
                } else {
                  vUp[i2] = vUp[i2 - 1];
                }
                x = vUp[i2] - 1;
                y = x - start1 + start2 - k;
                while (x >= start1 && y >= start2 && left[x] === right[y]) {
                  vUp[i2] = x--;
                  y--;
                }
                if (delta % 2 === 0 && -d <= k && k <= d) {
                  if (vUp[i2] <= vDown[i2 + delta]) {
                    return buildSnake(vUp[i2], k + start1 - start2, end1, end2);
                  }
                }
              }
            }
          };
          var script = [];
          buildScript(0, left.length, 0, right.length, script);
          return script;
        };
        var Diff = {
          KEEP,
          DELETE,
          INSERT,
          diff
        };
        var getOuterHtml = function(elm) {
          if (NodeType.isElement(elm)) {
            return elm.outerHTML;
          } else if (NodeType.isText(elm)) {
            return Entities.encodeRaw(elm.data, false);
          } else if (NodeType.isComment(elm)) {
            return "<!--" + elm.data + "-->";
          }
          return "";
        };
        var createFragment$1 = function(html) {
          var frag, node2, container;
          container = domGlobals.document.createElement("div");
          frag = domGlobals.document.createDocumentFragment();
          if (html) {
            container.innerHTML = html;
          }
          while (node2 = container.firstChild) {
            frag.appendChild(node2);
          }
          return frag;
        };
        var insertAt = function(elm, html, index) {
          var fragment = createFragment$1(html);
          if (elm.hasChildNodes() && index < elm.childNodes.length) {
            var target = elm.childNodes[index];
            target.parentNode.insertBefore(fragment, target);
          } else {
            elm.appendChild(fragment);
          }
        };
        var removeAt = function(elm, index) {
          if (elm.hasChildNodes() && index < elm.childNodes.length) {
            var target = elm.childNodes[index];
            target.parentNode.removeChild(target);
          }
        };
        var applyDiff = function(diff2, elm) {
          var index = 0;
          each(diff2, function(action2) {
            if (action2[0] === Diff.KEEP) {
              index++;
            } else if (action2[0] === Diff.INSERT) {
              insertAt(elm, action2[1], index);
              index++;
            } else if (action2[0] === Diff.DELETE) {
              removeAt(elm, index);
            }
          });
        };
        var read$3 = function(elm) {
          return filter(map(from$1(elm.childNodes), getOuterHtml), function(item) {
            return item.length > 0;
          });
        };
        var write = function(fragments, elm) {
          var currentFragments = map(from$1(elm.childNodes), getOuterHtml);
          applyDiff(Diff.diff(currentFragments, fragments), elm);
          return elm;
        };
        var Fragments = {
          read: read$3,
          write
        };
        var undoLevelDocument = Cell(Option.none());
        var lazyTempDocument = function() {
          return undoLevelDocument.get().getOrThunk(function() {
            var doc2 = domGlobals.document.implementation.createHTMLDocument("undo");
            undoLevelDocument.set(Option.some(doc2));
            return doc2;
          });
        };
        var hasIframes = function(html) {
          return html.indexOf("</iframe>") !== -1;
        };
        var createFragmentedLevel = function(fragments) {
          return {
            type: "fragmented",
            fragments,
            content: "",
            bookmark: null,
            beforeBookmark: null
          };
        };
        var createCompleteLevel = function(content) {
          return {
            type: "complete",
            fragments: null,
            content,
            bookmark: null,
            beforeBookmark: null
          };
        };
        var createFromEditor = function(editor) {
          var fragments, content, trimmedFragments;
          fragments = Fragments.read(editor.getBody());
          trimmedFragments = bind(fragments, function(html) {
            var trimmed = TrimHtml.trimInternal(editor.serializer, html);
            return trimmed.length > 0 ? [trimmed] : [];
          });
          content = trimmedFragments.join("");
          return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
        };
        var applyToEditor = function(editor, level, before2) {
          if (level.type === "fragmented") {
            Fragments.write(level.fragments, editor.getBody());
          } else {
            editor.setContent(level.content, { format: "raw" });
          }
          editor.selection.moveToBookmark(before2 ? level.beforeBookmark : level.bookmark);
        };
        var getLevelContent = function(level) {
          return level.type === "fragmented" ? level.fragments.join("") : level.content;
        };
        var getCleanLevelContent = function(level) {
          var elm = Element.fromTag("body", lazyTempDocument());
          set$1(elm, getLevelContent(level));
          each(descendants$1(elm, "*[data-mce-bogus]"), unwrap);
          return get$3(elm);
        };
        var hasEqualContent = function(level1, level2) {
          return getLevelContent(level1) === getLevelContent(level2);
        };
        var hasEqualCleanedContent = function(level1, level2) {
          return getCleanLevelContent(level1) === getCleanLevelContent(level2);
        };
        var isEq$4 = function(level1, level2) {
          if (!level1 || !level2) {
            return false;
          } else if (hasEqualContent(level1, level2)) {
            return true;
          } else {
            return hasEqualCleanedContent(level1, level2);
          }
        };
        var Levels = {
          createFragmentedLevel,
          createCompleteLevel,
          createFromEditor,
          applyToEditor,
          isEq: isEq$4
        };
        function UndoManager(editor) {
          var self2 = this, index = 0, data2 = [], beforeBookmark, isFirstTypedCharacter, locks = 0;
          var isUnlocked = function() {
            return locks === 0;
          };
          var setTyping = function(typing) {
            if (isUnlocked()) {
              self2.typing = typing;
            }
          };
          var setDirty = function(state) {
            editor.setDirty(state);
          };
          var addNonTypingUndoLevel = function(e) {
            setTyping(false);
            self2.add({}, e);
          };
          var endTyping = function() {
            if (self2.typing) {
              setTyping(false);
              self2.add();
            }
          };
          editor.on("init", function() {
            self2.add();
          });
          editor.on("BeforeExecCommand", function(e) {
            var cmd = e.command;
            if (cmd !== "Undo" && cmd !== "Redo" && cmd !== "mceRepaint") {
              endTyping();
              self2.beforeChange();
            }
          });
          editor.on("ExecCommand", function(e) {
            var cmd = e.command;
            if (cmd !== "Undo" && cmd !== "Redo" && cmd !== "mceRepaint") {
              addNonTypingUndoLevel(e);
            }
          });
          editor.on("ObjectResizeStart Cut", function() {
            self2.beforeChange();
          });
          editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
          editor.on("DragEnd", addNonTypingUndoLevel);
          editor.on("KeyUp", function(e) {
            var keyCode = e.keyCode;
            if (e.isDefaultPrevented()) {
              return;
            }
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
              addNonTypingUndoLevel();
              editor.nodeChanged();
            }
            if (keyCode === 46 || keyCode === 8) {
              editor.nodeChanged();
            }
            if (isFirstTypedCharacter && self2.typing && Levels.isEq(Levels.createFromEditor(editor), data2[0]) === false) {
              if (editor.isDirty() === false) {
                setDirty(true);
                editor.fire("change", {
                  level: data2[0],
                  lastLevel: null
                });
              }
              editor.fire("TypingUndo");
              isFirstTypedCharacter = false;
              editor.nodeChanged();
            }
          });
          editor.on("KeyDown", function(e) {
            var keyCode = e.keyCode;
            if (e.isDefaultPrevented()) {
              return;
            }
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
              if (self2.typing) {
                addNonTypingUndoLevel(e);
              }
              return;
            }
            var modKey = e.ctrlKey && !e.altKey || e.metaKey;
            if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !self2.typing && !modKey) {
              self2.beforeChange();
              setTyping(true);
              self2.add({}, e);
              isFirstTypedCharacter = true;
            }
          });
          editor.on("MouseDown", function(e) {
            if (self2.typing) {
              addNonTypingUndoLevel(e);
            }
          });
          var isInsertReplacementText = function(event) {
            return event.inputType === "insertReplacementText";
          };
          var isInsertTextDataNull = function(event) {
            return event.inputType === "insertText" && event.data === null;
          };
          editor.on("input", function(e) {
            if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e))) {
              addNonTypingUndoLevel(e);
            }
          });
          editor.addShortcut("meta+z", "", "Undo");
          editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
          editor.on("AddUndo Undo Redo ClearUndos", function(e) {
            if (!e.isDefaultPrevented()) {
              editor.nodeChanged();
            }
          });
          self2 = {
            data: data2,
            typing: false,
            beforeChange: function() {
              if (isUnlocked()) {
                beforeBookmark = GetBookmark.getUndoBookmark(editor.selection);
              }
            },
            add: function(level, event) {
              var i2;
              var settings = editor.settings;
              var lastLevel, currentLevel;
              currentLevel = Levels.createFromEditor(editor);
              level = level || {};
              level = Tools.extend(level, currentLevel);
              if (isUnlocked() === false || editor.removed) {
                return null;
              }
              lastLevel = data2[index];
              if (editor.fire("BeforeAddUndo", {
                level,
                lastLevel,
                originalEvent: event
              }).isDefaultPrevented()) {
                return null;
              }
              if (lastLevel && Levels.isEq(lastLevel, level)) {
                return null;
              }
              if (data2[index]) {
                data2[index].beforeBookmark = beforeBookmark;
              }
              if (settings.custom_undo_redo_levels) {
                if (data2.length > settings.custom_undo_redo_levels) {
                  for (i2 = 0; i2 < data2.length - 1; i2++) {
                    data2[i2] = data2[i2 + 1];
                  }
                  data2.length--;
                  index = data2.length;
                }
              }
              level.bookmark = GetBookmark.getUndoBookmark(editor.selection);
              if (index < data2.length - 1) {
                data2.length = index + 1;
              }
              data2.push(level);
              index = data2.length - 1;
              var args = {
                level,
                lastLevel,
                originalEvent: event
              };
              editor.fire("AddUndo", args);
              if (index > 0) {
                setDirty(true);
                editor.fire("change", args);
              }
              return level;
            },
            undo: function() {
              var level;
              if (self2.typing) {
                self2.add();
                self2.typing = false;
                setTyping(false);
              }
              if (index > 0) {
                level = data2[--index];
                Levels.applyToEditor(editor, level, true);
                setDirty(true);
                editor.fire("undo", { level });
              }
              return level;
            },
            redo: function() {
              var level;
              if (index < data2.length - 1) {
                level = data2[++index];
                Levels.applyToEditor(editor, level, false);
                setDirty(true);
                editor.fire("redo", { level });
              }
              return level;
            },
            clear: function() {
              data2 = [];
              index = 0;
              self2.typing = false;
              self2.data = data2;
              editor.fire("ClearUndos");
            },
            hasUndo: function() {
              return index > 0 || self2.typing && data2[0] && !Levels.isEq(Levels.createFromEditor(editor), data2[0]);
            },
            hasRedo: function() {
              return index < data2.length - 1 && !self2.typing;
            },
            transact: function(callback) {
              endTyping();
              self2.beforeChange();
              self2.ignore(callback);
              return self2.add();
            },
            ignore: function(callback) {
              try {
                locks++;
                callback();
              } finally {
                locks--;
              }
            },
            extra: function(callback1, callback2) {
              var lastLevel, bookmark;
              if (self2.transact(callback1)) {
                bookmark = data2[index].bookmark;
                lastLevel = data2[index - 1];
                Levels.applyToEditor(editor, lastLevel, true);
                if (self2.transact(callback2)) {
                  data2[index - 1].beforeBookmark = bookmark;
                }
              }
            }
          };
          return self2;
        }
        var postProcessHooks = {}, filter$2 = ArrUtils.filter, each$c = ArrUtils.each;
        var addPostProcessHook = function(name2, hook) {
          var hooks = postProcessHooks[name2];
          if (!hooks) {
            postProcessHooks[name2] = hooks = [];
          }
          postProcessHooks[name2].push(hook);
        };
        var postProcess = function(name2, editor) {
          each$c(postProcessHooks[name2], function(hook) {
            hook(editor);
          });
        };
        addPostProcessHook("pre", function(editor) {
          var rng = editor.selection.getRng();
          var isPre, blocks2;
          var hasPreSibling = function(pre) {
            return isPre(pre.previousSibling) && ArrUtils.indexOf(blocks2, pre.previousSibling) !== -1;
          };
          var joinPre = function(pre1, pre2) {
            DomQuery(pre2).remove();
            DomQuery(pre1).append("<br><br>").append(pre2.childNodes);
          };
          isPre = NodeType.matchNodeNames("pre");
          if (!rng.collapsed) {
            blocks2 = editor.selection.getSelectedBlocks();
            each$c(filter$2(filter$2(blocks2, isPre), hasPreSibling), function(pre) {
              joinPre(pre.previousSibling, pre);
            });
          }
        });
        var Hooks = { postProcess };
        var MCE_ATTR_RE = /^(src|href|style)$/;
        var each$d = Tools.each;
        var isEq$5 = FormatUtils.isEq;
        var isTableCell$4 = function(node2) {
          return /^(TH|TD)$/.test(node2.nodeName);
        };
        var isChildOfInlineParent = function(dom2, node2, parent2) {
          return dom2.isChildOf(node2, parent2) && node2 !== parent2 && !dom2.isBlock(parent2);
        };
        var getContainer = function(ed, rng, start2) {
          var container, offset, lastIdx;
          container = rng[start2 ? "startContainer" : "endContainer"];
          offset = rng[start2 ? "startOffset" : "endOffset"];
          if (NodeType.isElement(container)) {
            lastIdx = container.childNodes.length - 1;
            if (!start2 && offset) {
              offset--;
            }
            container = container.childNodes[offset > lastIdx ? lastIdx : offset];
          }
          if (NodeType.isText(container) && start2 && offset >= container.nodeValue.length) {
            container = new TreeWalker(container, ed.getBody()).next() || container;
          }
          if (NodeType.isText(container) && !start2 && offset === 0) {
            container = new TreeWalker(container, ed.getBody()).prev() || container;
          }
          return container;
        };
        var wrap$2 = function(dom2, node2, name2, attrs) {
          var wrapper = dom2.create(name2, attrs);
          node2.parentNode.insertBefore(wrapper, node2);
          wrapper.appendChild(node2);
          return wrapper;
        };
        var wrapWithSiblings = function(dom2, node2, next, name2, attrs) {
          var start2 = Element.fromDom(node2);
          var wrapper = Element.fromDom(dom2.create(name2, attrs));
          var siblings = next ? nextSiblings(start2) : prevSiblings(start2);
          append$1(wrapper, siblings);
          if (next) {
            before(start2, wrapper);
            prepend(wrapper, start2);
          } else {
            after(start2, wrapper);
            append(wrapper, start2);
          }
          return wrapper.dom();
        };
        var matchName$1 = function(dom2, node2, format) {
          if (isEq$5(node2, format.inline)) {
            return true;
          }
          if (isEq$5(node2, format.block)) {
            return true;
          }
          if (format.selector) {
            return NodeType.isElement(node2) && dom2.is(node2, format.selector);
          }
        };
        var isColorFormatAndAnchor = function(node2, format) {
          return format.links && node2.tagName === "A";
        };
        var find$3 = function(dom2, node2, next, inc) {
          node2 = FormatUtils.getNonWhiteSpaceSibling(node2, next, inc);
          return !node2 || (node2.nodeName === "BR" || dom2.isBlock(node2));
        };
        var removeNode$1 = function(ed, node2, format) {
          var parentNode = node2.parentNode;
          var rootBlockElm;
          var dom2 = ed.dom, forcedRootBlock = ed.settings.forced_root_block;
          if (format.block) {
            if (!forcedRootBlock) {
              if (dom2.isBlock(node2) && !dom2.isBlock(parentNode)) {
                if (!find$3(dom2, node2, false) && !find$3(dom2, node2.firstChild, true, 1)) {
                  node2.insertBefore(dom2.create("br"), node2.firstChild);
                }
                if (!find$3(dom2, node2, true) && !find$3(dom2, node2.lastChild, false, 1)) {
                  node2.appendChild(dom2.create("br"));
                }
              }
            } else {
              if (parentNode === dom2.getRoot()) {
                if (!format.list_block || !isEq$5(node2, format.list_block)) {
                  each$d(Tools.grep(node2.childNodes), function(node3) {
                    if (FormatUtils.isValid(ed, forcedRootBlock, node3.nodeName.toLowerCase())) {
                      if (!rootBlockElm) {
                        rootBlockElm = wrap$2(dom2, node3, forcedRootBlock);
                        dom2.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
                      } else {
                        rootBlockElm.appendChild(node3);
                      }
                    } else {
                      rootBlockElm = 0;
                    }
                  });
                }
              }
            }
          }
          if (format.selector && format.inline && !isEq$5(format.inline, node2)) {
            return;
          }
          dom2.remove(node2, 1);
        };
        var removeFormat = function(ed, format, vars, node2, compareNode) {
          var i2, attrs, stylesModified;
          var dom2 = ed.dom;
          if (!matchName$1(dom2, node2, format) && !isColorFormatAndAnchor(node2, format)) {
            return false;
          }
          if (format.remove !== "all") {
            each$d(format.styles, function(value2, name2) {
              value2 = FormatUtils.normalizeStyleValue(dom2, FormatUtils.replaceVars(value2, vars), name2);
              if (typeof name2 === "number") {
                name2 = value2;
                compareNode = 0;
              }
              if (format.remove_similar || (!compareNode || isEq$5(FormatUtils.getStyle(dom2, compareNode, name2), value2))) {
                dom2.setStyle(node2, name2, "");
              }
              stylesModified = 1;
            });
            if (stylesModified && dom2.getAttrib(node2, "style") === "") {
              node2.removeAttribute("style");
              node2.removeAttribute("data-mce-style");
            }
            each$d(format.attributes, function(value2, name2) {
              var valueOut;
              value2 = FormatUtils.replaceVars(value2, vars);
              if (typeof name2 === "number") {
                name2 = value2;
                compareNode = 0;
              }
              if (!compareNode || isEq$5(dom2.getAttrib(compareNode, name2), value2)) {
                if (name2 === "class") {
                  value2 = dom2.getAttrib(node2, name2);
                  if (value2) {
                    valueOut = "";
                    each$d(value2.split(/\s+/), function(cls) {
                      if (/mce\-\w+/.test(cls)) {
                        valueOut += (valueOut ? " " : "") + cls;
                      }
                    });
                    if (valueOut) {
                      dom2.setAttrib(node2, name2, valueOut);
                      return;
                    }
                  }
                }
                if (name2 === "class") {
                  node2.removeAttribute("className");
                }
                if (MCE_ATTR_RE.test(name2)) {
                  node2.removeAttribute("data-mce-" + name2);
                }
                node2.removeAttribute(name2);
              }
            });
            each$d(format.classes, function(value2) {
              value2 = FormatUtils.replaceVars(value2, vars);
              if (!compareNode || dom2.hasClass(compareNode, value2)) {
                dom2.removeClass(node2, value2);
              }
            });
            attrs = dom2.getAttribs(node2);
            for (i2 = 0; i2 < attrs.length; i2++) {
              var attrName = attrs[i2].nodeName;
              if (attrName.indexOf("_") !== 0 && attrName.indexOf("data-") !== 0) {
                return false;
              }
            }
          }
          if (format.remove !== "none") {
            removeNode$1(ed, node2, format);
            return true;
          }
        };
        var findFormatRoot = function(editor, container, name2, vars, similar) {
          var formatRoot;
          each$d(FormatUtils.getParents(editor.dom, container.parentNode).reverse(), function(parent2) {
            var format;
            if (!formatRoot && parent2.id !== "_start" && parent2.id !== "_end") {
              format = MatchFormat.matchNode(editor, parent2, name2, vars, similar);
              if (format && format.split !== false) {
                formatRoot = parent2;
              }
            }
          });
          return formatRoot;
        };
        var wrapAndSplit = function(editor, formatList, formatRoot, container, target, split2, format, vars) {
          var parent2, clone2, lastClone, firstClone, i2, formatRootParent;
          var dom2 = editor.dom;
          if (formatRoot) {
            formatRootParent = formatRoot.parentNode;
            for (parent2 = container.parentNode; parent2 && parent2 !== formatRootParent; parent2 = parent2.parentNode) {
              clone2 = dom2.clone(parent2, false);
              for (i2 = 0; i2 < formatList.length; i2++) {
                if (removeFormat(editor, formatList[i2], vars, clone2, clone2)) {
                  clone2 = 0;
                  break;
                }
              }
              if (clone2) {
                if (lastClone) {
                  clone2.appendChild(lastClone);
                }
                if (!firstClone) {
                  firstClone = clone2;
                }
                lastClone = clone2;
              }
            }
            if (split2 && (!format.mixed || !dom2.isBlock(formatRoot))) {
              container = dom2.split(formatRoot, container);
            }
            if (lastClone) {
              target.parentNode.insertBefore(lastClone, target);
              firstClone.appendChild(target);
            }
          }
          return container;
        };
        var remove$6 = function(ed, name2, vars, node2, similar) {
          var formatList = ed.formatter.get(name2), format = formatList[0];
          var bookmark, rng, contentEditable2 = true;
          var dom2 = ed.dom;
          var selection = ed.selection;
          var splitToFormatRoot = function(container) {
            var formatRoot = findFormatRoot(ed, container, name2, vars, similar);
            return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
          };
          var isRemoveBookmarkNode = function(node3) {
            return Bookmarks.isBookmarkNode(node3) && NodeType.isElement(node3) && (node3.id === "_start" || node3.id === "_end");
          };
          var process2 = function(node3) {
            var children2, i3, l2, lastContentEditable, hasContentEditableState2;
            if (NodeType.isElement(node3) && dom2.getContentEditable(node3)) {
              lastContentEditable = contentEditable2;
              contentEditable2 = dom2.getContentEditable(node3) === "true";
              hasContentEditableState2 = true;
            }
            children2 = Tools.grep(node3.childNodes);
            if (contentEditable2 && !hasContentEditableState2) {
              for (i3 = 0, l2 = formatList.length; i3 < l2; i3++) {
                if (removeFormat(ed, formatList[i3], vars, node3, node3)) {
                  break;
                }
              }
            }
            if (format.deep) {
              if (children2.length) {
                for (i3 = 0, l2 = children2.length; i3 < l2; i3++) {
                  process2(children2[i3]);
                }
                if (hasContentEditableState2) {
                  contentEditable2 = lastContentEditable;
                }
              }
            }
          };
          var unwrap2 = function(start2) {
            var node3 = dom2.get(start2 ? "_start" : "_end");
            var out = node3[start2 ? "firstChild" : "lastChild"];
            if (isRemoveBookmarkNode(out)) {
              out = out[start2 ? "firstChild" : "lastChild"];
            }
            if (NodeType.isText(out) && out.data.length === 0) {
              out = start2 ? node3.previousSibling || node3.nextSibling : node3.nextSibling || node3.previousSibling;
            }
            dom2.remove(node3, true);
            return out;
          };
          var removeRngStyle = function(rng2) {
            var startContainer, endContainer;
            var commonAncestorContainer = rng2.commonAncestorContainer;
            rng2 = ExpandRange.expandRng(ed, rng2, formatList, true);
            if (format.split) {
              rng2 = SplitRange.split(rng2);
              startContainer = getContainer(ed, rng2, true);
              endContainer = getContainer(ed, rng2);
              if (startContainer !== endContainer) {
                if (/^(TR|TH|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) {
                  if (startContainer.nodeName === "TR") {
                    startContainer = startContainer.firstChild.firstChild || startContainer;
                  } else {
                    startContainer = startContainer.firstChild || startContainer;
                  }
                }
                if (commonAncestorContainer && /^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) && isTableCell$4(endContainer) && endContainer.firstChild) {
                  endContainer = endContainer.firstChild || endContainer;
                }
                if (isChildOfInlineParent(dom2, startContainer, endContainer)) {
                  var marker = Option.from(startContainer.firstChild).getOr(startContainer);
                  splitToFormatRoot(wrapWithSiblings(dom2, marker, true, "span", {
                    "id": "_start",
                    "data-mce-type": "bookmark"
                  }));
                  unwrap2(true);
                  return;
                }
                if (isChildOfInlineParent(dom2, endContainer, startContainer)) {
                  var marker = Option.from(endContainer.lastChild).getOr(endContainer);
                  splitToFormatRoot(wrapWithSiblings(dom2, marker, false, "span", {
                    "id": "_end",
                    "data-mce-type": "bookmark"
                  }));
                  unwrap2(false);
                  return;
                }
                startContainer = wrap$2(dom2, startContainer, "span", {
                  "id": "_start",
                  "data-mce-type": "bookmark"
                });
                endContainer = wrap$2(dom2, endContainer, "span", {
                  "id": "_end",
                  "data-mce-type": "bookmark"
                });
                splitToFormatRoot(startContainer);
                splitToFormatRoot(endContainer);
                startContainer = unwrap2(true);
                endContainer = unwrap2();
              } else {
                startContainer = endContainer = splitToFormatRoot(startContainer);
              }
              rng2.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
              rng2.startOffset = dom2.nodeIndex(startContainer);
              rng2.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
              rng2.endOffset = dom2.nodeIndex(endContainer) + 1;
            }
            RangeWalk.walk(dom2, rng2, function(nodes) {
              each$d(nodes, function(node3) {
                process2(node3);
                if (NodeType.isElement(node3) && ed.dom.getStyle(node3, "text-decoration") === "underline" && node3.parentNode && FormatUtils.getTextDecoration(dom2, node3.parentNode) === "underline") {
                  removeFormat(ed, {
                    deep: false,
                    exact: true,
                    inline: "span",
                    styles: { textDecoration: "underline" }
                  }, null, node3);
                }
              });
            });
          };
          if (node2) {
            if (node2.nodeType) {
              rng = dom2.createRng();
              rng.setStartBefore(node2);
              rng.setEndAfter(node2);
              removeRngStyle(rng);
            } else {
              removeRngStyle(node2);
            }
            return;
          }
          if (dom2.getContentEditable(selection.getNode()) === "false") {
            node2 = selection.getNode();
            for (var i2 = 0, l = formatList.length; i2 < l; i2++) {
              if (formatList[i2].ceFalseOverride) {
                if (removeFormat(ed, formatList[i2], vars, node2, node2)) {
                  break;
                }
              }
            }
            return;
          }
          if (!selection.isCollapsed() || !format.inline || dom2.select("td[data-mce-selected],th[data-mce-selected]").length) {
            bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
            removeRngStyle(selection.getRng());
            selection.moveToBookmark(bookmark);
            if (format.inline && MatchFormat.match(ed, name2, vars, selection.getStart())) {
              FormatUtils.moveStart(dom2, selection, selection.getRng());
            }
            ed.nodeChanged();
          } else {
            removeCaretFormat(ed, name2, vars, similar);
          }
        };
        var RemoveFormat = {
          removeFormat,
          remove: remove$6
        };
        var each$e = Tools.each;
        var isElementNode = function(node2) {
          return node2 && node2.nodeType === 1 && !Bookmarks.isBookmarkNode(node2) && !isCaretNode(node2) && !NodeType.isBogus(node2);
        };
        var findElementSibling = function(node2, siblingName) {
          var sibling2;
          for (sibling2 = node2; sibling2; sibling2 = sibling2[siblingName]) {
            if (sibling2.nodeType === 3 && sibling2.nodeValue.length !== 0) {
              return node2;
            }
            if (sibling2.nodeType === 1 && !Bookmarks.isBookmarkNode(sibling2)) {
              return sibling2;
            }
          }
          return node2;
        };
        var mergeSiblingsNodes = function(dom2, prev, next) {
          var sibling2, tmpSibling;
          var elementUtils = new ElementUtils(dom2);
          if (prev && next) {
            prev = findElementSibling(prev, "previousSibling");
            next = findElementSibling(next, "nextSibling");
            if (elementUtils.compare(prev, next)) {
              for (sibling2 = prev.nextSibling; sibling2 && sibling2 !== next; ) {
                tmpSibling = sibling2;
                sibling2 = sibling2.nextSibling;
                prev.appendChild(tmpSibling);
              }
              dom2.remove(next);
              Tools.each(Tools.grep(next.childNodes), function(node2) {
                prev.appendChild(node2);
              });
              return prev;
            }
          }
          return next;
        };
        var processChildElements = function(node2, filter2, process2) {
          each$e(node2.childNodes, function(node3) {
            if (isElementNode(node3)) {
              if (filter2(node3)) {
                process2(node3);
              }
              if (node3.hasChildNodes()) {
                processChildElements(node3, filter2, process2);
              }
            }
          });
        };
        var hasStyle = function(dom2, name2) {
          return curry(function(name3, node2) {
            return !!(node2 && FormatUtils.getStyle(dom2, node2, name3));
          }, name2);
        };
        var applyStyle = function(dom2, name2, value2) {
          return curry(function(name3, value3, node2) {
            dom2.setStyle(node2, name3, value3);
            if (node2.getAttribute("style") === "") {
              node2.removeAttribute("style");
            }
            unwrapEmptySpan(dom2, node2);
          }, name2, value2);
        };
        var unwrapEmptySpan = function(dom2, node2) {
          if (node2.nodeName === "SPAN" && dom2.getAttribs(node2).length === 0) {
            dom2.remove(node2, true);
          }
        };
        var processUnderlineAndColor = function(dom2, node2) {
          var textDecoration;
          if (node2.nodeType === 1 && node2.parentNode && node2.parentNode.nodeType === 1) {
            textDecoration = FormatUtils.getTextDecoration(dom2, node2.parentNode);
            if (dom2.getStyle(node2, "color") && textDecoration) {
              dom2.setStyle(node2, "text-decoration", textDecoration);
            } else if (dom2.getStyle(node2, "text-decoration") === textDecoration) {
              dom2.setStyle(node2, "text-decoration", null);
            }
          }
        };
        var mergeUnderlineAndColor = function(dom2, format, vars, node2) {
          if (format.styles.color || format.styles.textDecoration) {
            Tools.walk(node2, curry(processUnderlineAndColor, dom2), "childNodes");
            processUnderlineAndColor(dom2, node2);
          }
        };
        var mergeBackgroundColorAndFontSize = function(dom2, format, vars, node2) {
          if (format.styles && format.styles.backgroundColor) {
            processChildElements(node2, hasStyle(dom2, "fontSize"), applyStyle(dom2, "backgroundColor", FormatUtils.replaceVars(format.styles.backgroundColor, vars)));
          }
        };
        var mergeSubSup = function(dom2, format, vars, node2) {
          if (format.inline === "sub" || format.inline === "sup") {
            processChildElements(node2, hasStyle(dom2, "fontSize"), applyStyle(dom2, "fontSize", ""));
            dom2.remove(dom2.select(format.inline === "sup" ? "sub" : "sup", node2), true);
          }
        };
        var mergeSiblings = function(dom2, format, vars, node2) {
          if (node2 && format.merge_siblings !== false) {
            node2 = mergeSiblingsNodes(dom2, FormatUtils.getNonWhiteSpaceSibling(node2), node2);
            node2 = mergeSiblingsNodes(dom2, node2, FormatUtils.getNonWhiteSpaceSibling(node2, true));
          }
        };
        var clearChildStyles = function(dom2, format, node2) {
          if (format.clear_child_styles) {
            var selector = format.links ? "*:not(a)" : "*";
            each$e(dom2.select(selector, node2), function(node3) {
              if (isElementNode(node3)) {
                each$e(format.styles, function(value2, name2) {
                  dom2.setStyle(node3, name2, "");
                });
              }
            });
          }
        };
        var mergeWithChildren = function(editor, formatList, vars, node2) {
          each$e(formatList, function(format) {
            each$e(editor.dom.select(format.inline, node2), function(child2) {
              if (!isElementNode(child2)) {
                return;
              }
              RemoveFormat.removeFormat(editor, format, vars, child2, format.exact ? child2 : null);
            });
            clearChildStyles(editor.dom, format, node2);
          });
        };
        var mergeWithParents = function(editor, format, name2, vars, node2) {
          if (MatchFormat.matchNode(editor, node2.parentNode, name2, vars)) {
            if (RemoveFormat.removeFormat(editor, format, vars, node2)) {
              return;
            }
          }
          if (format.merge_with_parents) {
            editor.dom.getParent(node2.parentNode, function(parent2) {
              if (MatchFormat.matchNode(editor, parent2, name2, vars)) {
                RemoveFormat.removeFormat(editor, format, vars, node2);
                return true;
              }
            });
          }
        };
        var MergeFormats = {
          mergeWithChildren,
          mergeUnderlineAndColor,
          mergeBackgroundColorAndFontSize,
          mergeSubSup,
          mergeSiblings,
          mergeWithParents
        };
        var each$f = Tools.each;
        var isElementNode$1 = function(node2) {
          return node2 && node2.nodeType === 1 && !Bookmarks.isBookmarkNode(node2) && !isCaretNode(node2) && !NodeType.isBogus(node2);
        };
        var applyFormat = function(ed, name2, vars, node2) {
          var formatList = ed.formatter.get(name2);
          var format = formatList[0];
          var bookmark, rng;
          var isCollapsed = !node2 && ed.selection.isCollapsed();
          var dom2 = ed.dom, selection = ed.selection;
          var setElementFormat = function(elm, fmt) {
            fmt = fmt || format;
            if (elm) {
              if (fmt.onformat) {
                fmt.onformat(elm, fmt, vars, node2);
              }
              each$f(fmt.styles, function(value2, name3) {
                dom2.setStyle(elm, name3, FormatUtils.replaceVars(value2, vars));
              });
              if (fmt.styles) {
                var styleVal = dom2.getAttrib(elm, "style");
                if (styleVal) {
                  elm.setAttribute("data-mce-style", styleVal);
                }
              }
              each$f(fmt.attributes, function(value2, name3) {
                dom2.setAttrib(elm, name3, FormatUtils.replaceVars(value2, vars));
              });
              each$f(fmt.classes, function(value2) {
                value2 = FormatUtils.replaceVars(value2, vars);
                if (!dom2.hasClass(elm, value2)) {
                  dom2.addClass(elm, value2);
                }
              });
            }
          };
          var applyNodeStyle = function(formatList2, node3) {
            var found = false;
            if (!format.selector) {
              return false;
            }
            each$f(formatList2, function(format2) {
              if ("collapsed" in format2 && format2.collapsed !== isCollapsed) {
                return;
              }
              if (dom2.is(node3, format2.selector) && !isCaretNode(node3)) {
                setElementFormat(node3, format2);
                found = true;
                return false;
              }
            });
            return found;
          };
          var applyRngStyle = function(dom3, rng2, bookmark2, nodeSpecific) {
            var newWrappers = [];
            var wrapName, wrapElm, contentEditable2 = true;
            wrapName = format.inline || format.block;
            wrapElm = dom3.create(wrapName);
            setElementFormat(wrapElm);
            RangeWalk.walk(dom3, rng2, function(nodes) {
              var currentWrapElm;
              var process2 = function(node3) {
                var nodeName, parentName, hasContentEditableState2, lastContentEditable;
                lastContentEditable = contentEditable2;
                nodeName = node3.nodeName.toLowerCase();
                parentName = node3.parentNode.nodeName.toLowerCase();
                if (node3.nodeType === 1 && dom3.getContentEditable(node3)) {
                  lastContentEditable = contentEditable2;
                  contentEditable2 = dom3.getContentEditable(node3) === "true";
                  hasContentEditableState2 = true;
                }
                if (FormatUtils.isEq(nodeName, "br")) {
                  currentWrapElm = 0;
                  if (format.block) {
                    dom3.remove(node3);
                  }
                  return;
                }
                if (format.wrapper && MatchFormat.matchNode(ed, node3, name2, vars)) {
                  currentWrapElm = 0;
                  return;
                }
                if (contentEditable2 && !hasContentEditableState2 && format.block && !format.wrapper && FormatUtils.isTextBlock(ed, nodeName) && FormatUtils.isValid(ed, parentName, wrapName)) {
                  node3 = dom3.rename(node3, wrapName);
                  setElementFormat(node3);
                  newWrappers.push(node3);
                  currentWrapElm = 0;
                  return;
                }
                if (format.selector) {
                  var found = applyNodeStyle(formatList, node3);
                  if (!format.inline || found) {
                    currentWrapElm = 0;
                    return;
                  }
                }
                if (contentEditable2 && !hasContentEditableState2 && FormatUtils.isValid(ed, wrapName, nodeName) && FormatUtils.isValid(ed, parentName, wrapName) && !(!nodeSpecific && node3.nodeType === 3 && node3.nodeValue.length === 1 && node3.nodeValue.charCodeAt(0) === 65279) && !isCaretNode(node3) && (!format.inline || !dom3.isBlock(node3))) {
                  if (!currentWrapElm) {
                    currentWrapElm = dom3.clone(wrapElm, false);
                    node3.parentNode.insertBefore(currentWrapElm, node3);
                    newWrappers.push(currentWrapElm);
                  }
                  currentWrapElm.appendChild(node3);
                } else {
                  currentWrapElm = 0;
                  each$f(Tools.grep(node3.childNodes), process2);
                  if (hasContentEditableState2) {
                    contentEditable2 = lastContentEditable;
                  }
                  currentWrapElm = 0;
                }
              };
              each$f(nodes, process2);
            });
            if (format.links === true) {
              each$f(newWrappers, function(node3) {
                var process2 = function(node4) {
                  if (node4.nodeName === "A") {
                    setElementFormat(node4, format);
                  }
                  each$f(Tools.grep(node4.childNodes), process2);
                };
                process2(node3);
              });
            }
            each$f(newWrappers, function(node3) {
              var childCount;
              var getChildCount = function(node4) {
                var count2 = 0;
                each$f(node4.childNodes, function(node5) {
                  if (!FormatUtils.isWhiteSpaceNode(node5) && !Bookmarks.isBookmarkNode(node5)) {
                    count2++;
                  }
                });
                return count2;
              };
              var getChildElementNode = function(root) {
                var child2 = false;
                each$f(root.childNodes, function(node4) {
                  if (isElementNode$1(node4)) {
                    child2 = node4;
                    return false;
                  }
                });
                return child2;
              };
              var mergeStyles = function(node4) {
                var child2, clone2;
                child2 = getChildElementNode(node4);
                if (child2 && !Bookmarks.isBookmarkNode(child2) && MatchFormat.matchName(dom3, child2, format)) {
                  clone2 = dom3.clone(child2, false);
                  setElementFormat(clone2);
                  dom3.replace(clone2, node4, true);
                  dom3.remove(child2, 1);
                }
                return clone2 || node4;
              };
              childCount = getChildCount(node3);
              if ((newWrappers.length > 1 || !dom3.isBlock(node3)) && childCount === 0) {
                dom3.remove(node3, 1);
                return;
              }
              if (format.inline || format.wrapper) {
                if (!format.exact && childCount === 1) {
                  node3 = mergeStyles(node3);
                }
                MergeFormats.mergeWithChildren(ed, formatList, vars, node3);
                MergeFormats.mergeWithParents(ed, format, name2, vars, node3);
                MergeFormats.mergeBackgroundColorAndFontSize(dom3, format, vars, node3);
                MergeFormats.mergeSubSup(dom3, format, vars, node3);
                MergeFormats.mergeSiblings(dom3, format, vars, node3);
              }
            });
          };
          if (dom2.getContentEditable(selection.getNode()) === "false") {
            node2 = selection.getNode();
            for (var i2 = 0, l = formatList.length; i2 < l; i2++) {
              if (formatList[i2].ceFalseOverride && dom2.is(node2, formatList[i2].selector)) {
                setElementFormat(node2, formatList[i2]);
                return;
              }
            }
            return;
          }
          if (format) {
            if (node2) {
              if (node2.nodeType) {
                if (!applyNodeStyle(formatList, node2)) {
                  rng = dom2.createRng();
                  rng.setStartBefore(node2);
                  rng.setEndAfter(node2);
                  applyRngStyle(dom2, ExpandRange.expandRng(ed, rng, formatList), null, true);
                }
              } else {
                applyRngStyle(dom2, node2, null, true);
              }
            } else {
              if (!isCollapsed || !format.inline || dom2.select("td[data-mce-selected],th[data-mce-selected]").length) {
                var curSelNode = ed.selection.getNode();
                if (!ed.settings.forced_root_block && formatList[0].defaultBlock && !dom2.getParent(curSelNode, dom2.isBlock)) {
                  applyFormat(ed, formatList[0].defaultBlock);
                }
                ed.selection.setRng(RangeNormalizer.normalize(ed.selection.getRng()));
                bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
                applyRngStyle(dom2, ExpandRange.expandRng(ed, selection.getRng(), formatList));
                if (format.styles) {
                  MergeFormats.mergeUnderlineAndColor(dom2, format, vars, curSelNode);
                }
                selection.moveToBookmark(bookmark);
                FormatUtils.moveStart(dom2, selection, selection.getRng());
                ed.nodeChanged();
              } else {
                applyCaretFormat(ed, name2, vars);
              }
            }
            Hooks.postProcess(name2, ed);
          }
        };
        var ApplyFormat = { applyFormat };
        var each$g = Tools.each;
        var setup$5 = function(formatChangeData, editor) {
          var currentFormats = {};
          formatChangeData.set({});
          editor.on("NodeChange", function(e) {
            var parents2 = FormatUtils.getParents(editor.dom, e.element);
            var matchedFormats = {};
            parents2 = Tools.grep(parents2, function(node2) {
              return node2.nodeType === 1 && !node2.getAttribute("data-mce-bogus");
            });
            each$g(formatChangeData.get(), function(callbacks, format) {
              each$g(parents2, function(node2) {
                if (editor.formatter.matchNode(node2, format, {}, callbacks.similar)) {
                  if (!currentFormats[format]) {
                    each$g(callbacks, function(callback) {
                      callback(true, {
                        node: node2,
                        format,
                        parents: parents2
                      });
                    });
                    currentFormats[format] = callbacks;
                  }
                  matchedFormats[format] = callbacks;
                  return false;
                }
                if (MatchFormat.matchesUnInheritedFormatSelector(editor, node2, format)) {
                  return false;
                }
              });
            });
            each$g(currentFormats, function(callbacks, format) {
              if (!matchedFormats[format]) {
                delete currentFormats[format];
                each$g(callbacks, function(callback) {
                  callback(false, {
                    node: e.element,
                    format,
                    parents: parents2
                  });
                });
              }
            });
          });
        };
        var addListeners = function(formatChangeData, formats, callback, similar) {
          var formatChangeItems = formatChangeData.get();
          each$g(formats.split(","), function(format) {
            if (!formatChangeItems[format]) {
              formatChangeItems[format] = [];
              formatChangeItems[format].similar = similar;
            }
            formatChangeItems[format].push(callback);
          });
          formatChangeData.set(formatChangeItems);
        };
        var formatChanged = function(editor, formatChangeState, formats, callback, similar) {
          if (formatChangeState.get() === null) {
            setup$5(formatChangeState, editor);
          }
          addListeners(formatChangeState, formats, callback, similar);
        };
        var FormatChanged = { formatChanged };
        var get$5 = function(dom2) {
          var formats = {
            valigntop: [{
              selector: "td,th",
              styles: { verticalAlign: "top" }
            }],
            valignmiddle: [{
              selector: "td,th",
              styles: { verticalAlign: "middle" }
            }],
            valignbottom: [{
              selector: "td,th",
              styles: { verticalAlign: "bottom" }
            }],
            alignleft: [
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-left",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                styles: { textAlign: "left" },
                inherit: false,
                preview: false,
                defaultBlock: "div"
              },
              {
                selector: "img,table",
                collapsed: false,
                styles: { float: "left" },
                preview: "font-family font-size"
              }
            ],
            aligncenter: [
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                styles: { textAlign: "center" },
                inherit: false,
                preview: "font-family font-size",
                defaultBlock: "div"
              },
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-center",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "img",
                collapsed: false,
                styles: {
                  display: "block",
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: false
              },
              {
                selector: "table",
                collapsed: false,
                styles: {
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: "font-family font-size"
              }
            ],
            alignright: [
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-right",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                styles: { textAlign: "right" },
                inherit: false,
                preview: "font-family font-size",
                defaultBlock: "div"
              },
              {
                selector: "img,table",
                collapsed: false,
                styles: { float: "right" },
                preview: "font-family font-size"
              }
            ],
            alignjustify: [{
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
              styles: { textAlign: "justify" },
              inherit: false,
              defaultBlock: "div",
              preview: "font-family font-size"
            }],
            bold: [
              {
                inline: "strong",
                remove: "all"
              },
              {
                inline: "span",
                styles: { fontWeight: "bold" }
              },
              {
                inline: "b",
                remove: "all"
              }
            ],
            italic: [
              {
                inline: "em",
                remove: "all"
              },
              {
                inline: "span",
                styles: { fontStyle: "italic" }
              },
              {
                inline: "i",
                remove: "all"
              }
            ],
            underline: [
              {
                inline: "span",
                styles: { textDecoration: "underline" },
                exact: true
              },
              {
                inline: "u",
                remove: "all"
              }
            ],
            strikethrough: [
              {
                inline: "span",
                styles: { textDecoration: "line-through" },
                exact: true
              },
              {
                inline: "strike",
                remove: "all"
              }
            ],
            forecolor: {
              inline: "span",
              styles: { color: "%value" },
              links: true,
              remove_similar: true,
              clear_child_styles: true
            },
            hilitecolor: {
              inline: "span",
              styles: { backgroundColor: "%value" },
              links: true,
              remove_similar: true,
              clear_child_styles: true
            },
            fontname: {
              inline: "span",
              toggle: false,
              styles: { fontFamily: "%value" },
              clear_child_styles: true
            },
            fontsize: {
              inline: "span",
              toggle: false,
              styles: { fontSize: "%value" },
              clear_child_styles: true
            },
            fontsize_class: {
              inline: "span",
              attributes: { class: "%value" }
            },
            blockquote: {
              block: "blockquote",
              wrapper: 1,
              remove: "all"
            },
            subscript: { inline: "sub" },
            superscript: { inline: "sup" },
            code: { inline: "code" },
            link: {
              inline: "a",
              selector: "a",
              remove: "all",
              split: true,
              deep: true,
              onmatch: function() {
                return true;
              },
              onformat: function(elm, fmt, vars) {
                Tools.each(vars, function(value2, key) {
                  dom2.setAttrib(elm, key, value2);
                });
              }
            },
            removeformat: [
              {
                selector: "b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins",
                remove: "all",
                split: true,
                expand: false,
                block_expand: true,
                deep: true
              },
              {
                selector: "span",
                attributes: [
                  "style",
                  "class"
                ],
                remove: "empty",
                split: true,
                expand: false,
                deep: true
              },
              {
                selector: "*",
                attributes: [
                  "style",
                  "class"
                ],
                split: false,
                expand: false,
                deep: true
              }
            ]
          };
          Tools.each("p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp".split(/\s/), function(name2) {
            formats[name2] = {
              block: name2,
              remove: "all"
            };
          });
          return formats;
        };
        var DefaultFormats = { get: get$5 };
        function FormatRegistry(editor) {
          var formats = {};
          var get2 = function(name2) {
            return name2 ? formats[name2] : formats;
          };
          var register2 = function(name2, format) {
            if (name2) {
              if (typeof name2 !== "string") {
                Tools.each(name2, function(format2, name3) {
                  register2(name3, format2);
                });
              } else {
                format = format.length ? format : [format];
                Tools.each(format, function(format2) {
                  if (typeof format2.deep === "undefined") {
                    format2.deep = !format2.selector;
                  }
                  if (typeof format2.split === "undefined") {
                    format2.split = !format2.selector || format2.inline;
                  }
                  if (typeof format2.remove === "undefined" && format2.selector && !format2.inline) {
                    format2.remove = "none";
                  }
                  if (format2.selector && format2.inline) {
                    format2.mixed = true;
                    format2.block_expand = true;
                  }
                  if (typeof format2.classes === "string") {
                    format2.classes = format2.classes.split(/\s+/);
                  }
                });
                formats[name2] = format;
              }
            }
          };
          var unregister = function(name2) {
            if (name2 && formats[name2]) {
              delete formats[name2];
            }
            return formats;
          };
          register2(DefaultFormats.get(editor.dom));
          register2(editor.settings.formats);
          return {
            get: get2,
            register: register2,
            unregister
          };
        }
        var each$h = Tools.each;
        var dom = DOMUtils$1.DOM;
        var parsedSelectorToHtml = function(ancestry, editor) {
          var elm, item, fragment;
          var schema = editor && editor.schema || Schema({});
          var decorate = function(elm2, item2) {
            if (item2.classes.length) {
              dom.addClass(elm2, item2.classes.join(" "));
            }
            dom.setAttribs(elm2, item2.attrs);
          };
          var createElement = function(sItem) {
            var elm2;
            item = typeof sItem === "string" ? {
              name: sItem,
              classes: [],
              attrs: {}
            } : sItem;
            elm2 = dom.create(item.name);
            decorate(elm2, item);
            return elm2;
          };
          var getRequiredParent = function(elm2, candidate) {
            var name2 = typeof elm2 !== "string" ? elm2.nodeName.toLowerCase() : elm2;
            var elmRule = schema.getElementRule(name2);
            var parentsRequired = elmRule && elmRule.parentsRequired;
            if (parentsRequired && parentsRequired.length) {
              return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
            } else {
              return false;
            }
          };
          var wrapInHtml = function(elm2, ancestry2, siblings) {
            var parent2, parentCandidate, parentRequired;
            var ancestor2 = ancestry2.length > 0 && ancestry2[0];
            var ancestorName = ancestor2 && ancestor2.name;
            parentRequired = getRequiredParent(elm2, ancestorName);
            if (parentRequired) {
              if (ancestorName === parentRequired) {
                parentCandidate = ancestry2[0];
                ancestry2 = ancestry2.slice(1);
              } else {
                parentCandidate = parentRequired;
              }
            } else if (ancestor2) {
              parentCandidate = ancestry2[0];
              ancestry2 = ancestry2.slice(1);
            } else if (!siblings) {
              return elm2;
            }
            if (parentCandidate) {
              parent2 = createElement(parentCandidate);
              parent2.appendChild(elm2);
            }
            if (siblings) {
              if (!parent2) {
                parent2 = dom.create("div");
                parent2.appendChild(elm2);
              }
              Tools.each(siblings, function(sibling2) {
                var siblingElm = createElement(sibling2);
                parent2.insertBefore(siblingElm, elm2);
              });
            }
            return wrapInHtml(parent2, ancestry2, parentCandidate && parentCandidate.siblings);
          };
          if (ancestry && ancestry.length) {
            item = ancestry[0];
            elm = createElement(item);
            fragment = dom.create("div");
            fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
            return fragment;
          } else {
            return "";
          }
        };
        var selectorToHtml = function(selector, editor) {
          return parsedSelectorToHtml(parseSelector(selector), editor);
        };
        var parseSelectorItem = function(item) {
          var tagName;
          var obj = {
            classes: [],
            attrs: {}
          };
          item = obj.selector = Tools.trim(item);
          if (item !== "*") {
            tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function($0, $1, $2, $3, $4) {
              switch ($1) {
                case "#":
                  obj.attrs.id = $2;
                  break;
                case ".":
                  obj.classes.push($2);
                  break;
                case ":":
                  if (Tools.inArray("checked disabled enabled read-only required".split(" "), $2) !== -1) {
                    obj.attrs[$2] = $2;
                  }
                  break;
              }
              if ($3 === "[") {
                var m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                if (m) {
                  obj.attrs[m[1]] = m[2];
                }
              }
              return "";
            });
          }
          obj.name = tagName || "div";
          return obj;
        };
        var parseSelector = function(selector) {
          if (!selector || typeof selector !== "string") {
            return [];
          }
          selector = selector.split(/\s*,\s*/)[0];
          selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
          return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), function(item) {
            var siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
            var obj = siblings.pop();
            if (siblings.length) {
              obj.siblings = siblings;
            }
            return obj;
          }).reverse();
        };
        var getCssText = function(editor, format) {
          var name2, previewFrag, previewElm, items;
          var previewCss = "", parentFontSize, previewStyles;
          previewStyles = editor.settings.preview_styles;
          if (previewStyles === false) {
            return "";
          }
          if (typeof previewStyles !== "string") {
            previewStyles = "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow";
          }
          var removeVars = function(val) {
            return val.replace(/%(\w+)/g, "");
          };
          if (typeof format === "string") {
            format = editor.formatter.get(format);
            if (!format) {
              return;
            }
            format = format[0];
          }
          if ("preview" in format) {
            previewStyles = format.preview;
            if (previewStyles === false) {
              return "";
            }
          }
          name2 = format.block || format.inline || "span";
          items = parseSelector(format.selector);
          if (items.length) {
            if (!items[0].name) {
              items[0].name = name2;
            }
            name2 = format.selector;
            previewFrag = parsedSelectorToHtml(items, editor);
          } else {
            previewFrag = parsedSelectorToHtml([name2], editor);
          }
          previewElm = dom.select(name2, previewFrag)[0] || previewFrag.firstChild;
          each$h(format.styles, function(value2, name3) {
            value2 = removeVars(value2);
            if (value2) {
              dom.setStyle(previewElm, name3, value2);
            }
          });
          each$h(format.attributes, function(value2, name3) {
            value2 = removeVars(value2);
            if (value2) {
              dom.setAttrib(previewElm, name3, value2);
            }
          });
          each$h(format.classes, function(value2) {
            value2 = removeVars(value2);
            if (!dom.hasClass(previewElm, value2)) {
              dom.addClass(previewElm, value2);
            }
          });
          editor.fire("PreviewFormats");
          dom.setStyles(previewFrag, {
            position: "absolute",
            left: -65535
          });
          editor.getBody().appendChild(previewFrag);
          parentFontSize = dom.getStyle(editor.getBody(), "fontSize", true);
          parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
          each$h(previewStyles.split(" "), function(name3) {
            var value2 = dom.getStyle(previewElm, name3, true);
            if (name3 === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value2)) {
              value2 = dom.getStyle(editor.getBody(), name3, true);
              if (dom.toHex(value2).toLowerCase() === "#ffffff") {
                return;
              }
            }
            if (name3 === "color") {
              if (dom.toHex(value2).toLowerCase() === "#000000") {
                return;
              }
            }
            if (name3 === "font-size") {
              if (/em|%$/.test(value2)) {
                if (parentFontSize === 0) {
                  return;
                }
                var numValue = parseFloat(value2) / (/%$/.test(value2) ? 100 : 1);
                value2 = numValue * parentFontSize + "px";
              }
            }
            if (name3 === "border" && value2) {
              previewCss += "padding:0 2px;";
            }
            previewCss += name3 + ":" + value2 + ";";
          });
          editor.fire("AfterPreviewFormats");
          dom.remove(previewFrag);
          return previewCss;
        };
        var Preview = {
          getCssText,
          parseSelector,
          selectorToHtml
        };
        var toggle = function(editor, formats, name2, vars, node2) {
          var fmt = formats.get(name2);
          if (MatchFormat.match(editor, name2, vars, node2) && (!("toggle" in fmt[0]) || fmt[0].toggle)) {
            RemoveFormat.remove(editor, name2, vars, node2);
          } else {
            ApplyFormat.applyFormat(editor, name2, vars, node2);
          }
        };
        var ToggleFormat = { toggle };
        var setup$6 = function(editor) {
          editor.addShortcut("meta+b", "", "Bold");
          editor.addShortcut("meta+i", "", "Italic");
          editor.addShortcut("meta+u", "", "Underline");
          for (var i2 = 1; i2 <= 6; i2++) {
            editor.addShortcut("access+" + i2, "", [
              "FormatBlock",
              false,
              "h" + i2
            ]);
          }
          editor.addShortcut("access+7", "", [
            "FormatBlock",
            false,
            "p"
          ]);
          editor.addShortcut("access+8", "", [
            "FormatBlock",
            false,
            "div"
          ]);
          editor.addShortcut("access+9", "", [
            "FormatBlock",
            false,
            "address"
          ]);
        };
        var FormatShortcuts = { setup: setup$6 };
        function Formatter(editor) {
          var formats = FormatRegistry(editor);
          var formatChangeState = Cell(null);
          FormatShortcuts.setup(editor);
          setup$2(editor);
          return {
            get: formats.get,
            register: formats.register,
            unregister: formats.unregister,
            apply: curry(ApplyFormat.applyFormat, editor),
            remove: curry(RemoveFormat.remove, editor),
            toggle: curry(ToggleFormat.toggle, editor, formats),
            match: curry(MatchFormat.match, editor),
            matchAll: curry(MatchFormat.matchAll, editor),
            matchNode: curry(MatchFormat.matchNode, editor),
            canApply: curry(MatchFormat.canApply, editor),
            formatChanged: curry(FormatChanged.formatChanged, editor, formatChangeState),
            getCssText: curry(Preview.getCssText, editor)
          };
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var shallow$1 = function(old, nu2) {
          return nu2;
        };
        var baseMerge = function(merger) {
          return function() {
            var objects = new Array(arguments.length);
            for (var i2 = 0; i2 < objects.length; i2++) {
              objects[i2] = arguments[i2];
            }
            if (objects.length === 0) {
              throw new Error("Can't merge zero objects");
            }
            var ret = {};
            for (var j = 0; j < objects.length; j++) {
              var curObject = objects[j];
              for (var key in curObject) {
                if (hasOwnProperty$2.call(curObject, key)) {
                  ret[key] = merger(ret[key], curObject[key]);
                }
              }
            }
            return ret;
          };
        };
        var merge = baseMerge(shallow$1);
        var register = function(htmlParser, settings, dom2) {
          htmlParser.addAttributeFilter("data-mce-tabindex", function(nodes, name2) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              node2.attr("tabindex", node2.attributes.map["data-mce-tabindex"]);
              node2.attr(name2, null);
            }
          });
          htmlParser.addAttributeFilter("src,href,style", function(nodes, name2) {
            var i2 = nodes.length, node2, value2;
            var internalName = "data-mce-" + name2;
            var urlConverter = settings.url_converter;
            var urlConverterScope = settings.url_converter_scope;
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.attributes.map[internalName];
              if (value2 !== void 0) {
                node2.attr(name2, value2.length > 0 ? value2 : null);
                node2.attr(internalName, null);
              } else {
                value2 = node2.attributes.map[name2];
                if (name2 === "style") {
                  value2 = dom2.serializeStyle(dom2.parseStyle(value2), node2.name);
                } else if (urlConverter) {
                  value2 = urlConverter.call(urlConverterScope, value2, name2, node2.name);
                }
                node2.attr(name2, value2.length > 0 ? value2 : null);
              }
            }
          });
          htmlParser.addAttributeFilter("class", function(nodes) {
            var i2 = nodes.length, node2, value2;
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.attr("class");
              if (value2) {
                value2 = node2.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
                node2.attr("class", value2.length > 0 ? value2 : null);
              }
            }
          });
          htmlParser.addAttributeFilter("data-mce-type", function(nodes, name2, args) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              if (node2.attributes.map["data-mce-type"] === "bookmark" && !args.cleanup) {
                var hasChildren = Option.from(node2.firstChild).exists(function(firstChild2) {
                  return !Zwsp.isZwsp(firstChild2.value);
                });
                if (hasChildren) {
                  node2.unwrap();
                } else {
                  node2.remove();
                }
              }
            }
          });
          htmlParser.addNodeFilter("noscript", function(nodes) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2].firstChild;
              if (node2) {
                node2.value = Entities.decode(node2.value);
              }
            }
          });
          htmlParser.addNodeFilter("script,style", function(nodes, name2) {
            var i2 = nodes.length, node2, value2, type2;
            var trim2 = function(value3) {
              return value3.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
            };
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.firstChild ? node2.firstChild.value : "";
              if (name2 === "script") {
                type2 = node2.attr("type");
                if (type2) {
                  node2.attr("type", type2 === "mce-no/type" ? null : type2.replace(/^mce\-/, ""));
                }
                if (settings.element_format === "xhtml" && value2.length > 0) {
                  node2.firstChild.value = "// <![CDATA[\n" + trim2(value2) + "\n// ]]>";
                }
              } else {
                if (settings.element_format === "xhtml" && value2.length > 0) {
                  node2.firstChild.value = "<!--\n" + trim2(value2) + "\n-->";
                }
              }
            }
          });
          htmlParser.addNodeFilter("#comment", function(nodes) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              if (node2.value.indexOf("[CDATA[") === 0) {
                node2.name = "#cdata";
                node2.type = 4;
                node2.value = node2.value.replace(/^\[CDATA\[|\]\]$/g, "");
              } else if (node2.value.indexOf("mce:protected ") === 0) {
                node2.name = "#text";
                node2.type = 3;
                node2.raw = true;
                node2.value = unescape(node2.value).substr(14);
              }
            }
          });
          htmlParser.addNodeFilter("xml:namespace,input", function(nodes, name2) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              if (node2.type === 7) {
                node2.remove();
              } else if (node2.type === 1) {
                if (name2 === "input" && !("type" in node2.attributes.map)) {
                  node2.attr("type", "text");
                }
              }
            }
          });
          htmlParser.addAttributeFilter("data-mce-type", function(nodes) {
            each(nodes, function(node2) {
              if (node2.attr("data-mce-type") === "format-caret") {
                if (node2.isEmpty(htmlParser.schema.getNonEmptyElements())) {
                  node2.remove();
                } else {
                  node2.unwrap();
                }
              }
            });
          });
          htmlParser.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize", function(nodes, name2) {
            var i2 = nodes.length;
            while (i2--) {
              nodes[i2].attr(name2, null);
            }
          });
        };
        var trimTrailingBr = function(rootNode) {
          var brNode1, brNode2;
          var isBr2 = function(node2) {
            return node2 && node2.name === "br";
          };
          brNode1 = rootNode.lastChild;
          if (isBr2(brNode1)) {
            brNode2 = brNode1.prev;
            if (isBr2(brNode2)) {
              brNode1.remove();
              brNode2.remove();
            }
          }
        };
        var DomSerializerFilters = {
          register,
          trimTrailingBr
        };
        var preProcess = function(editor, node2, args) {
          var impl, doc2, oldDoc;
          var dom2 = editor.dom;
          node2 = node2.cloneNode(true);
          impl = domGlobals.document.implementation;
          if (impl.createHTMLDocument) {
            doc2 = impl.createHTMLDocument("");
            Tools.each(node2.nodeName === "BODY" ? node2.childNodes : [node2], function(node3) {
              doc2.body.appendChild(doc2.importNode(node3, true));
            });
            if (node2.nodeName !== "BODY") {
              node2 = doc2.body.firstChild;
            } else {
              node2 = doc2.body;
            }
            oldDoc = dom2.doc;
            dom2.doc = doc2;
          }
          Events.firePreProcess(editor, merge(args, { node: node2 }));
          if (oldDoc) {
            dom2.doc = oldDoc;
          }
          return node2;
        };
        var shouldFireEvent = function(editor, args) {
          return editor && editor.hasEventListeners("PreProcess") && !args.no_events;
        };
        var process = function(editor, node2, args) {
          return shouldFireEvent(editor, args) ? preProcess(editor, node2, args) : node2;
        };
        var DomSerializerPreProcess = { process };
        var removeAttrs = function(node2, names) {
          each(names, function(name2) {
            node2.attr(name2, null);
          });
        };
        var addFontToSpansFilter = function(domParser, styles, fontSizes) {
          domParser.addNodeFilter("font", function(nodes) {
            each(nodes, function(node2) {
              var props = styles.parse(node2.attr("style"));
              var color = node2.attr("color");
              var face = node2.attr("face");
              var size = node2.attr("size");
              if (color) {
                props.color = color;
              }
              if (face) {
                props["font-family"] = face;
              }
              if (size) {
                props["font-size"] = fontSizes[parseInt(node2.attr("size"), 10) - 1];
              }
              node2.name = "span";
              node2.attr("style", styles.serialize(props));
              removeAttrs(node2, [
                "color",
                "face",
                "size"
              ]);
            });
          });
        };
        var addStrikeToSpanFilter = function(domParser, styles) {
          domParser.addNodeFilter("strike", function(nodes) {
            each(nodes, function(node2) {
              var props = styles.parse(node2.attr("style"));
              props["text-decoration"] = "line-through";
              node2.name = "span";
              node2.attr("style", styles.serialize(props));
            });
          });
        };
        var addFilters = function(domParser, settings) {
          var styles = Styles();
          if (settings.convert_fonts_to_spans) {
            addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
          }
          addStrikeToSpanFilter(domParser, styles);
        };
        var register$1 = function(domParser, settings) {
          if (settings.inline_styles) {
            addFilters(domParser, settings);
          }
        };
        var LegacyFilter = { register: register$1 };
        var whiteSpaceRegExp$3 = /^[ \t\r\n]*$/;
        var typeLookup = {
          "#text": 3,
          "#comment": 8,
          "#cdata": 4,
          "#pi": 7,
          "#doctype": 10,
          "#document-fragment": 11
        };
        var walk$2 = function(node2, root, prev) {
          var sibling2;
          var parent2;
          var startName = prev ? "lastChild" : "firstChild";
          var siblingName = prev ? "prev" : "next";
          if (node2[startName]) {
            return node2[startName];
          }
          if (node2 !== root) {
            sibling2 = node2[siblingName];
            if (sibling2) {
              return sibling2;
            }
            for (parent2 = node2.parent; parent2 && parent2 !== root; parent2 = parent2.parent) {
              sibling2 = parent2[siblingName];
              if (sibling2) {
                return sibling2;
              }
            }
          }
        };
        var Node$1 = function() {
          function Node2(name2, type2) {
            this.name = name2;
            this.type = type2;
            if (type2 === 1) {
              this.attributes = [];
              this.attributes.map = {};
            }
          }
          Node2.create = function(name2, attrs) {
            var node2, attrName;
            node2 = new Node2(name2, typeLookup[name2] || 1);
            if (attrs) {
              for (attrName in attrs) {
                node2.attr(attrName, attrs[attrName]);
              }
            }
            return node2;
          };
          Node2.prototype.replace = function(node2) {
            var self2 = this;
            if (node2.parent) {
              node2.remove();
            }
            self2.insert(node2, self2);
            self2.remove();
            return self2;
          };
          Node2.prototype.attr = function(name2, value2) {
            var self2 = this;
            var attrs, i2;
            if (typeof name2 !== "string") {
              for (i2 in name2) {
                self2.attr(i2, name2[i2]);
              }
              return self2;
            }
            if (attrs = self2.attributes) {
              if (value2 !== void 0) {
                if (value2 === null) {
                  if (name2 in attrs.map) {
                    delete attrs.map[name2];
                    i2 = attrs.length;
                    while (i2--) {
                      if (attrs[i2].name === name2) {
                        attrs = attrs.splice(i2, 1);
                        return self2;
                      }
                    }
                  }
                  return self2;
                }
                if (name2 in attrs.map) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2].name === name2) {
                      attrs[i2].value = value2;
                      break;
                    }
                  }
                } else {
                  attrs.push({
                    name: name2,
                    value: value2
                  });
                }
                attrs.map[name2] = value2;
                return self2;
              }
              return attrs.map[name2];
            }
          };
          Node2.prototype.clone = function() {
            var self2 = this;
            var clone2 = new Node2(self2.name, self2.type);
            var i2, l, selfAttrs, selfAttr, cloneAttrs;
            if (selfAttrs = self2.attributes) {
              cloneAttrs = [];
              cloneAttrs.map = {};
              for (i2 = 0, l = selfAttrs.length; i2 < l; i2++) {
                selfAttr = selfAttrs[i2];
                if (selfAttr.name !== "id") {
                  cloneAttrs[cloneAttrs.length] = {
                    name: selfAttr.name,
                    value: selfAttr.value
                  };
                  cloneAttrs.map[selfAttr.name] = selfAttr.value;
                }
              }
              clone2.attributes = cloneAttrs;
            }
            clone2.value = self2.value;
            clone2.shortEnded = self2.shortEnded;
            return clone2;
          };
          Node2.prototype.wrap = function(wrapper) {
            var self2 = this;
            self2.parent.insert(wrapper, self2);
            wrapper.append(self2);
            return self2;
          };
          Node2.prototype.unwrap = function() {
            var self2 = this;
            var node2, next;
            for (node2 = self2.firstChild; node2; ) {
              next = node2.next;
              self2.insert(node2, self2, true);
              node2 = next;
            }
            self2.remove();
          };
          Node2.prototype.remove = function() {
            var self2 = this, parent2 = self2.parent, next = self2.next, prev = self2.prev;
            if (parent2) {
              if (parent2.firstChild === self2) {
                parent2.firstChild = next;
                if (next) {
                  next.prev = null;
                }
              } else {
                prev.next = next;
              }
              if (parent2.lastChild === self2) {
                parent2.lastChild = prev;
                if (prev) {
                  prev.next = null;
                }
              } else {
                next.prev = prev;
              }
              self2.parent = self2.next = self2.prev = null;
            }
            return self2;
          };
          Node2.prototype.append = function(node2) {
            var self2 = this;
            var last2;
            if (node2.parent) {
              node2.remove();
            }
            last2 = self2.lastChild;
            if (last2) {
              last2.next = node2;
              node2.prev = last2;
              self2.lastChild = node2;
            } else {
              self2.lastChild = self2.firstChild = node2;
            }
            node2.parent = self2;
            return node2;
          };
          Node2.prototype.insert = function(node2, refNode, before2) {
            var parent2;
            if (node2.parent) {
              node2.remove();
            }
            parent2 = refNode.parent || this;
            if (before2) {
              if (refNode === parent2.firstChild) {
                parent2.firstChild = node2;
              } else {
                refNode.prev.next = node2;
              }
              node2.prev = refNode.prev;
              node2.next = refNode;
              refNode.prev = node2;
            } else {
              if (refNode === parent2.lastChild) {
                parent2.lastChild = node2;
              } else {
                refNode.next.prev = node2;
              }
              node2.next = refNode.next;
              node2.prev = refNode;
              refNode.next = node2;
            }
            node2.parent = parent2;
            return node2;
          };
          Node2.prototype.getAll = function(name2) {
            var self2 = this;
            var node2;
            var collection = [];
            for (node2 = self2.firstChild; node2; node2 = walk$2(node2, self2)) {
              if (node2.name === name2) {
                collection.push(node2);
              }
            }
            return collection;
          };
          Node2.prototype.empty = function() {
            var self2 = this;
            var nodes, i2, node2;
            if (self2.firstChild) {
              nodes = [];
              for (node2 = self2.firstChild; node2; node2 = walk$2(node2, self2)) {
                nodes.push(node2);
              }
              i2 = nodes.length;
              while (i2--) {
                node2 = nodes[i2];
                node2.parent = node2.firstChild = node2.lastChild = node2.next = node2.prev = null;
              }
            }
            self2.firstChild = self2.lastChild = null;
            return self2;
          };
          Node2.prototype.isEmpty = function(elements, whitespace2, predicate) {
            var self2 = this;
            var node2 = self2.firstChild, i2, name2;
            whitespace2 = whitespace2 || {};
            if (node2) {
              do {
                if (node2.type === 1) {
                  if (node2.attributes.map["data-mce-bogus"]) {
                    continue;
                  }
                  if (elements[node2.name]) {
                    return false;
                  }
                  i2 = node2.attributes.length;
                  while (i2--) {
                    name2 = node2.attributes[i2].name;
                    if (name2 === "name" || name2.indexOf("data-mce-bookmark") === 0) {
                      return false;
                    }
                  }
                }
                if (node2.type === 8) {
                  return false;
                }
                if (node2.type === 3 && !whiteSpaceRegExp$3.test(node2.value)) {
                  return false;
                }
                if (node2.type === 3 && node2.parent && whitespace2[node2.parent.name] && whiteSpaceRegExp$3.test(node2.value)) {
                  return false;
                }
                if (predicate && predicate(node2)) {
                  return false;
                }
              } while (node2 = walk$2(node2, self2));
            }
            return true;
          };
          Node2.prototype.walk = function(prev) {
            return walk$2(this, null, prev);
          };
          return Node2;
        }();
        var paddEmptyNode = function(settings, args, blockElements, node2) {
          var brPreferred = settings.padd_empty_with_br || args.insert;
          if (brPreferred && blockElements[node2.name]) {
            node2.empty().append(new Node$1("br", 1)).shortEnded = true;
          } else {
            node2.empty().append(new Node$1("#text", 3)).value = "\xA0";
          }
        };
        var isPaddedWithNbsp = function(node2) {
          return hasOnlyChild(node2, "#text") && node2.firstChild.value === "\xA0";
        };
        var hasOnlyChild = function(node2, name2) {
          return node2 && node2.firstChild && node2.firstChild === node2.lastChild && node2.firstChild.name === name2;
        };
        var isPadded = function(schema, node2) {
          var rule = schema.getElementRule(node2.name);
          return rule && rule.paddEmpty;
        };
        var isEmpty$2 = function(schema, nonEmptyElements, whitespaceElements, node2) {
          return node2.isEmpty(nonEmptyElements, whitespaceElements, function(node3) {
            return isPadded(schema, node3);
          });
        };
        var isLineBreakNode = function(node2, blockElements) {
          return node2 && (blockElements[node2.name] || node2.name === "br");
        };
        var register$2 = function(parser, settings) {
          var schema = parser.schema;
          if (settings.remove_trailing_brs) {
            parser.addNodeFilter("br", function(nodes, _, args) {
              var i2;
              var l = nodes.length;
              var node2;
              var blockElements = Tools.extend({}, schema.getBlockElements());
              var nonEmptyElements = schema.getNonEmptyElements();
              var parent2, lastParent, prev, prevName;
              var whiteSpaceElements = schema.getWhiteSpaceElements();
              var elementRule, textNode;
              blockElements.body = 1;
              for (i2 = 0; i2 < l; i2++) {
                node2 = nodes[i2];
                parent2 = node2.parent;
                if (blockElements[node2.parent.name] && node2 === parent2.lastChild) {
                  prev = node2.prev;
                  while (prev) {
                    prevName = prev.name;
                    if (prevName !== "span" || prev.attr("data-mce-type") !== "bookmark") {
                      if (prevName !== "br") {
                        break;
                      }
                      if (prevName === "br") {
                        node2 = null;
                        break;
                      }
                    }
                    prev = prev.prev;
                  }
                  if (node2) {
                    node2.remove();
                    if (isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, parent2)) {
                      elementRule = schema.getElementRule(parent2.name);
                      if (elementRule) {
                        if (elementRule.removeEmpty) {
                          parent2.remove();
                        } else if (elementRule.paddEmpty) {
                          paddEmptyNode(settings, args, blockElements, parent2);
                        }
                      }
                    }
                  }
                } else {
                  lastParent = node2;
                  while (parent2 && parent2.firstChild === lastParent && parent2.lastChild === lastParent) {
                    lastParent = parent2;
                    if (blockElements[parent2.name]) {
                      break;
                    }
                    parent2 = parent2.parent;
                  }
                  if (lastParent === parent2 && settings.padd_empty_with_br !== true) {
                    textNode = new Node$1("#text", 3);
                    textNode.value = "\xA0";
                    node2.replace(textNode);
                  }
                }
              }
            });
          }
          parser.addAttributeFilter("href", function(nodes) {
            var i2 = nodes.length, node2;
            var appendRel = function(rel) {
              var parts = rel.split(" ").filter(function(p) {
                return p.length > 0;
              });
              return parts.concat(["noopener"]).sort().join(" ");
            };
            var addNoOpener = function(rel) {
              var newRel = rel ? Tools.trim(rel) : "";
              if (!/\b(noopener)\b/g.test(newRel)) {
                return appendRel(newRel);
              } else {
                return newRel;
              }
            };
            if (!settings.allow_unsafe_link_target) {
              while (i2--) {
                node2 = nodes[i2];
                if (node2.name === "a" && node2.attr("target") === "_blank") {
                  node2.attr("rel", addNoOpener(node2.attr("rel")));
                }
              }
            }
          });
          if (!settings.allow_html_in_named_anchor) {
            parser.addAttributeFilter("id,name", function(nodes) {
              var i2 = nodes.length, sibling2, prevSibling2, parent2, node2;
              while (i2--) {
                node2 = nodes[i2];
                if (node2.name === "a" && node2.firstChild && !node2.attr("href")) {
                  parent2 = node2.parent;
                  sibling2 = node2.lastChild;
                  do {
                    prevSibling2 = sibling2.prev;
                    parent2.insert(sibling2, node2);
                    sibling2 = prevSibling2;
                  } while (sibling2);
                }
              }
            });
          }
          if (settings.fix_list_elements) {
            parser.addNodeFilter("ul,ol", function(nodes) {
              var i2 = nodes.length, node2, parentNode;
              while (i2--) {
                node2 = nodes[i2];
                parentNode = node2.parent;
                if (parentNode.name === "ul" || parentNode.name === "ol") {
                  if (node2.prev && node2.prev.name === "li") {
                    node2.prev.append(node2);
                  } else {
                    var li = new Node$1("li", 1);
                    li.attr("style", "list-style-type: none");
                    node2.wrap(li);
                  }
                }
              }
            });
          }
          if (settings.validate && schema.getValidClasses()) {
            parser.addAttributeFilter("class", function(nodes) {
              var i2 = nodes.length, node2, classList, ci, className, classValue;
              var validClasses = schema.getValidClasses();
              var validClassesMap, valid;
              while (i2--) {
                node2 = nodes[i2];
                classList = node2.attr("class").split(" ");
                classValue = "";
                for (ci = 0; ci < classList.length; ci++) {
                  className = classList[ci];
                  valid = false;
                  validClassesMap = validClasses["*"];
                  if (validClassesMap && validClassesMap[className]) {
                    valid = true;
                  }
                  validClassesMap = validClasses[node2.name];
                  if (!valid && validClassesMap && validClassesMap[className]) {
                    valid = true;
                  }
                  if (valid) {
                    if (classValue) {
                      classValue += " ";
                    }
                    classValue += className;
                  }
                }
                if (!classValue.length) {
                  classValue = null;
                }
                node2.attr("class", classValue);
              }
            });
          }
        };
        var makeMap$4 = Tools.makeMap, each$i = Tools.each, explode$3 = Tools.explode, extend$3 = Tools.extend;
        function DomParser(settings, schema) {
          if (schema === void 0) {
            schema = Schema();
          }
          var nodeFilters = {};
          var attributeFilters = [];
          var matchedNodes = {};
          var matchedAttributes = {};
          settings = settings || {};
          settings.validate = "validate" in settings ? settings.validate : true;
          settings.root_name = settings.root_name || "body";
          var fixInvalidChildren = function(nodes) {
            var ni, node2, parent2, parents2, newParent, currentNode, tempNode, childNode, i2;
            var nonEmptyElements, whitespaceElements, nonSplitableElements, textBlockElements, specialElements, sibling2, nextNode;
            nonSplitableElements = makeMap$4("tr,td,th,tbody,thead,tfoot,table");
            nonEmptyElements = schema.getNonEmptyElements();
            whitespaceElements = schema.getWhiteSpaceElements();
            textBlockElements = schema.getTextBlockElements();
            specialElements = schema.getSpecialElements();
            for (ni = 0; ni < nodes.length; ni++) {
              node2 = nodes[ni];
              if (!node2.parent || node2.fixed) {
                continue;
              }
              if (textBlockElements[node2.name] && node2.parent.name === "li") {
                sibling2 = node2.next;
                while (sibling2) {
                  if (textBlockElements[sibling2.name]) {
                    sibling2.name = "li";
                    sibling2.fixed = true;
                    node2.parent.insert(sibling2, node2.parent);
                  } else {
                    break;
                  }
                  sibling2 = sibling2.next;
                }
                node2.unwrap(node2);
                continue;
              }
              parents2 = [node2];
              for (parent2 = node2.parent; parent2 && !schema.isValidChild(parent2.name, node2.name) && !nonSplitableElements[parent2.name]; parent2 = parent2.parent) {
                parents2.push(parent2);
              }
              if (parent2 && parents2.length > 1) {
                parents2.reverse();
                newParent = currentNode = filterNode(parents2[0].clone());
                for (i2 = 0; i2 < parents2.length - 1; i2++) {
                  if (schema.isValidChild(currentNode.name, parents2[i2].name)) {
                    tempNode = filterNode(parents2[i2].clone());
                    currentNode.append(tempNode);
                  } else {
                    tempNode = currentNode;
                  }
                  for (childNode = parents2[i2].firstChild; childNode && childNode !== parents2[i2 + 1]; ) {
                    nextNode = childNode.next;
                    tempNode.append(childNode);
                    childNode = nextNode;
                  }
                  currentNode = tempNode;
                }
                if (!isEmpty$2(schema, nonEmptyElements, whitespaceElements, newParent)) {
                  parent2.insert(newParent, parents2[0], true);
                  parent2.insert(node2, newParent);
                } else {
                  parent2.insert(node2, parents2[0], true);
                }
                parent2 = parents2[0];
                if (isEmpty$2(schema, nonEmptyElements, whitespaceElements, parent2) || hasOnlyChild(parent2, "br")) {
                  parent2.empty().remove();
                }
              } else if (node2.parent) {
                if (node2.name === "li") {
                  sibling2 = node2.prev;
                  if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ul")) {
                    sibling2.append(node2);
                    continue;
                  }
                  sibling2 = node2.next;
                  if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ul")) {
                    sibling2.insert(node2, sibling2.firstChild, true);
                    continue;
                  }
                  node2.wrap(filterNode(new Node$1("ul", 1)));
                  continue;
                }
                if (schema.isValidChild(node2.parent.name, "div") && schema.isValidChild("div", node2.name)) {
                  node2.wrap(filterNode(new Node$1("div", 1)));
                } else {
                  if (specialElements[node2.name]) {
                    node2.empty().remove();
                  } else {
                    node2.unwrap();
                  }
                }
              }
            }
          };
          var filterNode = function(node2) {
            var i2, name2, list;
            name2 = node2.name;
            if (name2 in nodeFilters) {
              list = matchedNodes[name2];
              if (list) {
                list.push(node2);
              } else {
                matchedNodes[name2] = [node2];
              }
            }
            i2 = attributeFilters.length;
            while (i2--) {
              name2 = attributeFilters[i2].name;
              if (name2 in node2.attributes.map) {
                list = matchedAttributes[name2];
                if (list) {
                  list.push(node2);
                } else {
                  matchedAttributes[name2] = [node2];
                }
              }
            }
            return node2;
          };
          var addNodeFilter = function(name2, callback) {
            each$i(explode$3(name2), function(name3) {
              var list = nodeFilters[name3];
              if (!list) {
                nodeFilters[name3] = list = [];
              }
              list.push(callback);
            });
          };
          var getNodeFilters = function() {
            var out = [];
            for (var name2 in nodeFilters) {
              if (nodeFilters.hasOwnProperty(name2)) {
                out.push({
                  name: name2,
                  callbacks: nodeFilters[name2]
                });
              }
            }
            return out;
          };
          var addAttributeFilter = function(name2, callback) {
            each$i(explode$3(name2), function(name3) {
              var i2;
              for (i2 = 0; i2 < attributeFilters.length; i2++) {
                if (attributeFilters[i2].name === name3) {
                  attributeFilters[i2].callbacks.push(callback);
                  return;
                }
              }
              attributeFilters.push({
                name: name3,
                callbacks: [callback]
              });
            });
          };
          var getAttributeFilters = function() {
            return [].concat(attributeFilters);
          };
          var parse = function(html, args) {
            var parser, nodes, i2, l, fi, fl, list, name2;
            var blockElements;
            var invalidChildren = [];
            var isInWhiteSpacePreservedElement;
            var node2;
            args = args || {};
            matchedNodes = {};
            matchedAttributes = {};
            blockElements = extend$3(makeMap$4("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
            var nonEmptyElements = schema.getNonEmptyElements();
            var children2 = schema.children;
            var validate2 = settings.validate;
            var rootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;
            var whiteSpaceElements = schema.getWhiteSpaceElements();
            var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
            var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
            var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
            var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
            isInWhiteSpacePreservedElement = whiteSpaceElements.hasOwnProperty(args.context) || whiteSpaceElements.hasOwnProperty(settings.root_name);
            var addRootBlocks2 = function() {
              var node3 = rootNode.firstChild, next, rootBlockNode;
              var trim2 = function(rootBlockNode2) {
                if (rootBlockNode2) {
                  node3 = rootBlockNode2.firstChild;
                  if (node3 && node3.type === 3) {
                    node3.value = node3.value.replace(startWhiteSpaceRegExp, "");
                  }
                  node3 = rootBlockNode2.lastChild;
                  if (node3 && node3.type === 3) {
                    node3.value = node3.value.replace(endWhiteSpaceRegExp, "");
                  }
                }
              };
              if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
                return;
              }
              while (node3) {
                next = node3.next;
                if (node3.type === 3 || node3.type === 1 && node3.name !== "p" && !blockElements[node3.name] && !node3.attr("data-mce-type")) {
                  if (!rootBlockNode) {
                    rootBlockNode = createNode(rootBlockName, 1);
                    rootBlockNode.attr(settings.forced_root_block_attrs);
                    rootNode.insert(rootBlockNode, node3);
                    rootBlockNode.append(node3);
                  } else {
                    rootBlockNode.append(node3);
                  }
                } else {
                  trim2(rootBlockNode);
                  rootBlockNode = null;
                }
                node3 = next;
              }
              trim2(rootBlockNode);
            };
            var createNode = function(name3, type2) {
              var node3 = new Node$1(name3, type2);
              var list2;
              if (name3 in nodeFilters) {
                list2 = matchedNodes[name3];
                if (list2) {
                  list2.push(node3);
                } else {
                  matchedNodes[name3] = [node3];
                }
              }
              return node3;
            };
            var removeWhitespaceBefore = function(node3) {
              var textNode, textNodeNext, textVal, sibling2;
              var blockElements2 = schema.getBlockElements();
              for (textNode = node3.prev; textNode && textNode.type === 3; ) {
                textVal = textNode.value.replace(endWhiteSpaceRegExp, "");
                if (textVal.length > 0) {
                  textNode.value = textVal;
                  return;
                }
                textNodeNext = textNode.next;
                if (textNodeNext) {
                  if (textNodeNext.type === 3 && textNodeNext.value.length) {
                    textNode = textNode.prev;
                    continue;
                  }
                  if (!blockElements2[textNodeNext.name] && textNodeNext.name !== "script" && textNodeNext.name !== "style") {
                    textNode = textNode.prev;
                    continue;
                  }
                }
                sibling2 = textNode.prev;
                textNode.remove();
                textNode = sibling2;
              }
            };
            var cloneAndExcludeBlocks = function(input) {
              var name3;
              var output = {};
              for (name3 in input) {
                if (name3 !== "li" && name3 !== "p") {
                  output[name3] = input[name3];
                }
              }
              return output;
            };
            parser = SaxParser$1({
              validate: validate2,
              allow_script_urls: settings.allow_script_urls,
              allow_conditional_comments: settings.allow_conditional_comments,
              self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
              cdata: function(text) {
                node2.append(createNode("#cdata", 4)).value = text;
              },
              text: function(text, raw) {
                var textNode;
                if (!isInWhiteSpacePreservedElement) {
                  text = text.replace(allWhiteSpaceRegExp, " ");
                  if (isLineBreakNode(node2.lastChild, blockElements)) {
                    text = text.replace(startWhiteSpaceRegExp, "");
                  }
                }
                if (text.length !== 0) {
                  textNode = createNode("#text", 3);
                  textNode.raw = !!raw;
                  node2.append(textNode).value = text;
                }
              },
              comment: function(text) {
                node2.append(createNode("#comment", 8)).value = text;
              },
              pi: function(name3, text) {
                node2.append(createNode(name3, 7)).value = text;
                removeWhitespaceBefore(node2);
              },
              doctype: function(text) {
                var newNode;
                newNode = node2.append(createNode("#doctype", 10));
                newNode.value = text;
                removeWhitespaceBefore(node2);
              },
              start: function(name3, attrs, empty2) {
                var newNode, attrFiltersLen, elementRule, attrName, parent2;
                elementRule = validate2 ? schema.getElementRule(name3) : {};
                if (elementRule) {
                  newNode = createNode(elementRule.outputName || name3, 1);
                  newNode.attributes = attrs;
                  newNode.shortEnded = empty2;
                  node2.append(newNode);
                  parent2 = children2[node2.name];
                  if (parent2 && children2[newNode.name] && !parent2[newNode.name]) {
                    invalidChildren.push(newNode);
                  }
                  attrFiltersLen = attributeFilters.length;
                  while (attrFiltersLen--) {
                    attrName = attributeFilters[attrFiltersLen].name;
                    if (attrName in attrs.map) {
                      list = matchedAttributes[attrName];
                      if (list) {
                        list.push(newNode);
                      } else {
                        matchedAttributes[attrName] = [newNode];
                      }
                    }
                  }
                  if (blockElements[name3]) {
                    removeWhitespaceBefore(newNode);
                  }
                  if (!empty2) {
                    node2 = newNode;
                  }
                  if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
                    isInWhiteSpacePreservedElement = true;
                  }
                }
              },
              end: function(name3) {
                var textNode, elementRule, text, sibling2, tempNode;
                elementRule = validate2 ? schema.getElementRule(name3) : {};
                if (elementRule) {
                  if (blockElements[name3]) {
                    if (!isInWhiteSpacePreservedElement) {
                      textNode = node2.firstChild;
                      if (textNode && textNode.type === 3) {
                        text = textNode.value.replace(startWhiteSpaceRegExp, "");
                        if (text.length > 0) {
                          textNode.value = text;
                          textNode = textNode.next;
                        } else {
                          sibling2 = textNode.next;
                          textNode.remove();
                          textNode = sibling2;
                          while (textNode && textNode.type === 3) {
                            text = textNode.value;
                            sibling2 = textNode.next;
                            if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                              textNode.remove();
                              textNode = sibling2;
                            }
                            textNode = sibling2;
                          }
                        }
                      }
                      textNode = node2.lastChild;
                      if (textNode && textNode.type === 3) {
                        text = textNode.value.replace(endWhiteSpaceRegExp, "");
                        if (text.length > 0) {
                          textNode.value = text;
                          textNode = textNode.prev;
                        } else {
                          sibling2 = textNode.prev;
                          textNode.remove();
                          textNode = sibling2;
                          while (textNode && textNode.type === 3) {
                            text = textNode.value;
                            sibling2 = textNode.prev;
                            if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                              textNode.remove();
                              textNode = sibling2;
                            }
                            textNode = sibling2;
                          }
                        }
                      }
                    }
                  }
                  if (isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
                    isInWhiteSpacePreservedElement = false;
                  }
                  if (elementRule.removeEmpty && isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node2)) {
                    if (!node2.attributes.map.name && !node2.attr("id")) {
                      tempNode = node2.parent;
                      if (blockElements[node2.name]) {
                        node2.empty().remove();
                      } else {
                        node2.unwrap();
                      }
                      node2 = tempNode;
                      return;
                    }
                  }
                  if (elementRule.paddEmpty && (isPaddedWithNbsp(node2) || isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node2))) {
                    paddEmptyNode(settings, args, blockElements, node2);
                  }
                  node2 = node2.parent;
                }
              }
            }, schema);
            var rootNode = node2 = new Node$1(args.context || settings.root_name, 11);
            parser.parse(html);
            if (validate2 && invalidChildren.length) {
              if (!args.context) {
                fixInvalidChildren(invalidChildren);
              } else {
                args.invalid = true;
              }
            }
            if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) {
              addRootBlocks2();
            }
            if (!args.invalid) {
              for (name2 in matchedNodes) {
                list = nodeFilters[name2];
                nodes = matchedNodes[name2];
                fi = nodes.length;
                while (fi--) {
                  if (!nodes[fi].parent) {
                    nodes.splice(fi, 1);
                  }
                }
                for (i2 = 0, l = list.length; i2 < l; i2++) {
                  list[i2](nodes, name2, args);
                }
              }
              for (i2 = 0, l = attributeFilters.length; i2 < l; i2++) {
                list = attributeFilters[i2];
                if (list.name in matchedAttributes) {
                  nodes = matchedAttributes[list.name];
                  fi = nodes.length;
                  while (fi--) {
                    if (!nodes[fi].parent) {
                      nodes.splice(fi, 1);
                    }
                  }
                  for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
                    list.callbacks[fi](nodes, list.name, args);
                  }
                }
              }
            }
            return rootNode;
          };
          var exports2 = {
            schema,
            addAttributeFilter,
            getAttributeFilters,
            addNodeFilter,
            getNodeFilters,
            filterNode,
            parse
          };
          register$2(exports2, settings);
          LegacyFilter.register(exports2, settings);
          return exports2;
        }
        var addTempAttr = function(htmlParser, tempAttrs, name2) {
          if (Tools.inArray(tempAttrs, name2) === -1) {
            htmlParser.addAttributeFilter(name2, function(nodes, name3) {
              var i2 = nodes.length;
              while (i2--) {
                nodes[i2].attr(name3, null);
              }
            });
            tempAttrs.push(name2);
          }
        };
        var postProcess$1 = function(editor, args, content) {
          if (!args.no_events && editor) {
            var outArgs = Events.firePostProcess(editor, merge(args, { content }));
            return outArgs.content;
          } else {
            return content;
          }
        };
        var getHtmlFromNode = function(dom2, node2, args) {
          var html = Zwsp.trim(args.getInner ? node2.innerHTML : dom2.getOuterHTML(node2));
          return args.selection || isWsPreserveElement(Element.fromDom(node2)) ? html : Tools.trim(html);
        };
        var parseHtml = function(htmlParser, html, args) {
          var parserArgs = args.selection ? merge({ forced_root_block: false }, args) : args;
          var rootNode = htmlParser.parse(html, parserArgs);
          DomSerializerFilters.trimTrailingBr(rootNode);
          return rootNode;
        };
        var serializeNode = function(settings, schema, node2) {
          var htmlSerializer = HtmlSerializer(settings, schema);
          return htmlSerializer.serialize(node2);
        };
        var toHtml = function(editor, settings, schema, rootNode, args) {
          var content = serializeNode(settings, schema, rootNode);
          return postProcess$1(editor, args, content);
        };
        function DomSerializer(settings, editor) {
          var dom2, schema, htmlParser;
          var tempAttrs = ["data-mce-selected"];
          dom2 = editor && editor.dom ? editor.dom : DOMUtils$1.DOM;
          schema = editor && editor.schema ? editor.schema : Schema(settings);
          settings.entity_encoding = settings.entity_encoding || "named";
          settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
          htmlParser = DomParser(settings, schema);
          DomSerializerFilters.register(htmlParser, settings, dom2);
          var serialize2 = function(node2, parserArgs) {
            var args = merge({ format: "html" }, parserArgs ? parserArgs : {});
            var targetNode = DomSerializerPreProcess.process(editor, node2, args);
            var html = getHtmlFromNode(dom2, targetNode, args);
            var rootNode = parseHtml(htmlParser, html, args);
            return args.format === "tree" ? rootNode : toHtml(editor, settings, schema, rootNode, args);
          };
          return {
            schema,
            addNodeFilter: htmlParser.addNodeFilter,
            addAttributeFilter: htmlParser.addAttributeFilter,
            serialize: serialize2,
            addRules: function(rules) {
              schema.addValidElements(rules);
            },
            setRules: function(rules) {
              schema.setValidElements(rules);
            },
            addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
            getTempAttrs: function() {
              return tempAttrs;
            }
          };
        }
        function DomSerializer$1(settings, editor) {
          var domSerializer = DomSerializer(settings, editor);
          return {
            schema: domSerializer.schema,
            addNodeFilter: domSerializer.addNodeFilter,
            addAttributeFilter: domSerializer.addAttributeFilter,
            serialize: domSerializer.serialize,
            addRules: domSerializer.addRules,
            setRules: domSerializer.setRules,
            addTempAttr: domSerializer.addTempAttr,
            getTempAttrs: domSerializer.getTempAttrs
          };
        }
        function BookmarkManager(selection) {
          return {
            getBookmark: curry(Bookmarks.getBookmark, selection),
            moveToBookmark: curry(Bookmarks.moveToBookmark, selection)
          };
        }
        (function(BookmarkManager2) {
          BookmarkManager2.isBookmarkNode = Bookmarks.isBookmarkNode;
        })(BookmarkManager || (BookmarkManager = {}));
        var BookmarkManager$1 = BookmarkManager;
        var isContentEditableFalse$a = NodeType.isContentEditableFalse;
        var isContentEditableTrue$5 = NodeType.isContentEditableTrue;
        var getContentEditableRoot$2 = function(root, node2) {
          while (node2 && node2 !== root) {
            if (isContentEditableTrue$5(node2) || isContentEditableFalse$a(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var ControlSelection = function(selection, editor) {
          var dom2 = editor.dom, each2 = Tools.each;
          var selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle;
          var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
          var width, height;
          var editableDoc = editor.getDoc(), rootDocument = domGlobals.document;
          var abs = Math.abs, round2 = Math.round, rootElement = editor.getBody();
          var startScrollWidth, startScrollHeight;
          resizeHandles = {
            nw: [
              0,
              0,
              -1,
              -1
            ],
            ne: [
              1,
              0,
              1,
              -1
            ],
            se: [
              1,
              1,
              1,
              1
            ],
            sw: [
              0,
              1,
              -1,
              1
            ]
          };
          var rootClass = ".mce-content-body";
          editor.contentStyles.push(rootClass + " div.mce-resizehandle {position: absolute;border: 1px solid black;box-sizing: content-box;background: #FFF;width: 7px;height: 7px;z-index: 10000}" + rootClass + " .mce-resizehandle:hover {background: #000}" + rootClass + " img[data-mce-selected]," + rootClass + " hr[data-mce-selected] {outline: 1px solid black;resize: none}" + rootClass + " .mce-clonedresizable {position: absolute;" + (Env.gecko ? "" : "outline: 1px dashed black;") + "opacity: .5;filter: alpha(opacity=50);z-index: 10000}" + rootClass + " .mce-resize-helper {background: #555;background: rgba(0,0,0,0.75);border-radius: 3px;border: 1px;color: white;display: none;font-family: sans-serif;font-size: 12px;white-space: nowrap;line-height: 14px;margin: 5px 10px;padding: 5px;position: absolute;z-index: 10001}");
          var isImage = function(elm) {
            return elm && (elm.nodeName === "IMG" || editor.dom.is(elm, "figure.image"));
          };
          var isEventOnImageOutsideRange = function(evt, range2) {
            return isImage(evt.target) && !RangePoint.isXYWithinRange(evt.clientX, evt.clientY, range2);
          };
          var contextMenuSelectImage = function(evt) {
            var target = evt.target;
            if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
              editor.selection.select(target);
            }
          };
          var getResizeTarget = function(elm) {
            return editor.dom.is(elm, "figure.image") ? elm.querySelector("img") : elm;
          };
          var isResizable = function(elm) {
            var selector = editor.settings.object_resizing;
            if (selector === false || Env.iOS) {
              return false;
            }
            if (typeof selector !== "string") {
              selector = "table,img,figure.image,div";
            }
            if (elm.getAttribute("data-mce-resize") === "false") {
              return false;
            }
            if (elm === editor.getBody()) {
              return false;
            }
            return is$1(Element.fromDom(elm), selector);
          };
          var resizeGhostElement = function(e) {
            var deltaX, deltaY, proportional;
            var resizeHelperX, resizeHelperY;
            deltaX = e.screenX - startX;
            deltaY = e.screenY - startY;
            width = deltaX * selectedHandle[2] + startW;
            height = deltaY * selectedHandle[3] + startH;
            width = width < 5 ? 5 : width;
            height = height < 5 ? 5 : height;
            if (isImage(selectedElm) && editor.settings.resize_img_proportional !== false) {
              proportional = !VK.modifierPressed(e);
            } else {
              proportional = VK.modifierPressed(e) || isImage(selectedElm) && selectedHandle[2] * selectedHandle[3] !== 0;
            }
            if (proportional) {
              if (abs(deltaX) > abs(deltaY)) {
                height = round2(width * ratio);
                width = round2(height / ratio);
              } else {
                width = round2(height / ratio);
                height = round2(width * ratio);
              }
            }
            dom2.setStyles(getResizeTarget(selectedElmGhost), {
              width,
              height
            });
            resizeHelperX = selectedHandle.startPos.x + deltaX;
            resizeHelperY = selectedHandle.startPos.y + deltaY;
            resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
            resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
            dom2.setStyles(resizeHelper, {
              left: resizeHelperX,
              top: resizeHelperY,
              display: "block"
            });
            resizeHelper.innerHTML = width + " &times; " + height;
            if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
              dom2.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width));
            }
            if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
              dom2.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height));
            }
            deltaX = rootElement.scrollWidth - startScrollWidth;
            deltaY = rootElement.scrollHeight - startScrollHeight;
            if (deltaX + deltaY !== 0) {
              dom2.setStyles(resizeHelper, {
                left: resizeHelperX - deltaX,
                top: resizeHelperY - deltaY
              });
            }
            if (!resizeStarted) {
              Events.fireObjectResizeStart(editor, selectedElm, startW, startH);
              resizeStarted = true;
            }
          };
          var endGhostResize = function() {
            resizeStarted = false;
            var setSizeProp = function(name2, value2) {
              if (value2) {
                if (selectedElm.style[name2] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name2)) {
                  dom2.setStyle(getResizeTarget(selectedElm), name2, value2);
                } else {
                  dom2.setAttrib(getResizeTarget(selectedElm), name2, value2);
                }
              }
            };
            setSizeProp("width", width);
            setSizeProp("height", height);
            dom2.unbind(editableDoc, "mousemove", resizeGhostElement);
            dom2.unbind(editableDoc, "mouseup", endGhostResize);
            if (rootDocument !== editableDoc) {
              dom2.unbind(rootDocument, "mousemove", resizeGhostElement);
              dom2.unbind(rootDocument, "mouseup", endGhostResize);
            }
            dom2.remove(selectedElmGhost);
            dom2.remove(resizeHelper);
            showResizeRect(selectedElm);
            Events.fireObjectResized(editor, selectedElm, width, height);
            dom2.setAttrib(selectedElm, "style", dom2.getAttrib(selectedElm, "style"));
            editor.nodeChanged();
          };
          var showResizeRect = function(targetElm) {
            var position, targetWidth, targetHeight, e, rect;
            hideResizeRect();
            unbindResizeHandleEvents();
            position = dom2.getPos(targetElm, rootElement);
            selectedElmX = position.x;
            selectedElmY = position.y;
            rect = targetElm.getBoundingClientRect();
            targetWidth = rect.width || rect.right - rect.left;
            targetHeight = rect.height || rect.bottom - rect.top;
            if (selectedElm !== targetElm) {
              selectedElm = targetElm;
              width = height = 0;
            }
            e = editor.fire("ObjectSelected", { target: targetElm });
            if (isResizable(targetElm) && !e.isDefaultPrevented()) {
              each2(resizeHandles, function(handle2, name2) {
                var handleElm;
                var startDrag = function(e2) {
                  startX = e2.screenX;
                  startY = e2.screenY;
                  startW = getResizeTarget(selectedElm).clientWidth;
                  startH = getResizeTarget(selectedElm).clientHeight;
                  ratio = startH / startW;
                  selectedHandle = handle2;
                  handle2.startPos = {
                    x: targetWidth * handle2[0] + selectedElmX,
                    y: targetHeight * handle2[1] + selectedElmY
                  };
                  startScrollWidth = rootElement.scrollWidth;
                  startScrollHeight = rootElement.scrollHeight;
                  selectedElmGhost = selectedElm.cloneNode(true);
                  dom2.addClass(selectedElmGhost, "mce-clonedresizable");
                  dom2.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
                  selectedElmGhost.contentEditable = false;
                  selectedElmGhost.unSelectabe = true;
                  dom2.setStyles(selectedElmGhost, {
                    left: selectedElmX,
                    top: selectedElmY,
                    margin: 0
                  });
                  selectedElmGhost.removeAttribute("data-mce-selected");
                  rootElement.appendChild(selectedElmGhost);
                  dom2.bind(editableDoc, "mousemove", resizeGhostElement);
                  dom2.bind(editableDoc, "mouseup", endGhostResize);
                  if (rootDocument !== editableDoc) {
                    dom2.bind(rootDocument, "mousemove", resizeGhostElement);
                    dom2.bind(rootDocument, "mouseup", endGhostResize);
                  }
                  resizeHelper = dom2.add(rootElement, "div", {
                    "class": "mce-resize-helper",
                    "data-mce-bogus": "all"
                  }, startW + " &times; " + startH);
                };
                handleElm = dom2.get("mceResizeHandle" + name2);
                if (handleElm) {
                  dom2.remove(handleElm);
                }
                handleElm = dom2.add(rootElement, "div", {
                  "id": "mceResizeHandle" + name2,
                  "data-mce-bogus": "all",
                  "class": "mce-resizehandle",
                  "unselectable": true,
                  "style": "cursor:" + name2 + "-resize; margin:0; padding:0"
                });
                if (Env.ie === 11) {
                  handleElm.contentEditable = false;
                }
                dom2.bind(handleElm, "mousedown", function(e2) {
                  e2.stopImmediatePropagation();
                  e2.preventDefault();
                  startDrag(e2);
                });
                handle2.elm = handleElm;
                dom2.setStyles(handleElm, {
                  left: targetWidth * handle2[0] + selectedElmX - handleElm.offsetWidth / 2,
                  top: targetHeight * handle2[1] + selectedElmY - handleElm.offsetHeight / 2
                });
              });
            } else {
              hideResizeRect();
            }
            selectedElm.setAttribute("data-mce-selected", "1");
          };
          var hideResizeRect = function() {
            var name2, handleElm;
            unbindResizeHandleEvents();
            if (selectedElm) {
              selectedElm.removeAttribute("data-mce-selected");
            }
            for (name2 in resizeHandles) {
              handleElm = dom2.get("mceResizeHandle" + name2);
              if (handleElm) {
                dom2.unbind(handleElm);
                dom2.remove(handleElm);
              }
            }
          };
          var updateResizeRect = function(e) {
            var startElm, controlElm;
            var isChildOrEqual = function(node2, parent2) {
              if (node2) {
                do {
                  if (node2 === parent2) {
                    return true;
                  }
                } while (node2 = node2.parentNode);
              }
            };
            if (resizeStarted || editor.removed) {
              return;
            }
            each2(dom2.select("img[data-mce-selected],hr[data-mce-selected]"), function(img) {
              img.removeAttribute("data-mce-selected");
            });
            controlElm = e.type === "mousedown" ? e.target : selection.getNode();
            controlElm = dom2.$(controlElm).closest("table,img,figure.image,hr")[0];
            if (isChildOrEqual(controlElm, rootElement)) {
              disableGeckoResize();
              startElm = selection.getStart(true);
              if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
                showResizeRect(controlElm);
                return;
              }
            }
            hideResizeRect();
          };
          var isWithinContentEditableFalse = function(elm) {
            return isContentEditableFalse$a(getContentEditableRoot$2(editor.getBody(), elm));
          };
          var unbindResizeHandleEvents = function() {
            for (var name2 in resizeHandles) {
              var handle2 = resizeHandles[name2];
              if (handle2.elm) {
                dom2.unbind(handle2.elm);
                delete handle2.elm;
              }
            }
          };
          var disableGeckoResize = function() {
            try {
              editor.getDoc().execCommand("enableObjectResizing", false, false);
            } catch (ex) {
            }
          };
          editor.on("init", function() {
            disableGeckoResize();
            if (Env.ie && Env.ie >= 11) {
              editor.on("mousedown click", function(e) {
                var target = e.target, nodeName = target.nodeName;
                if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {
                  if (e.button !== 2) {
                    editor.selection.select(target, nodeName === "TABLE");
                  }
                  if (e.type === "mousedown") {
                    editor.nodeChanged();
                  }
                }
              });
              editor.dom.bind(rootElement, "mscontrolselect", function(e) {
                var delayedSelect = function(node2) {
                  Delay.setEditorTimeout(editor, function() {
                    editor.selection.select(node2);
                  });
                };
                if (isWithinContentEditableFalse(e.target)) {
                  e.preventDefault();
                  delayedSelect(e.target);
                  return;
                }
                if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
                  e.preventDefault();
                  if (e.target.tagName === "IMG") {
                    delayedSelect(e.target);
                  }
                }
              });
            }
            var throttledUpdateResizeRect = Delay.throttle(function(e) {
              if (!editor.composing) {
                updateResizeRect(e);
              }
            });
            editor.on("nodechange ResizeEditor ResizeWindow drop FullscreenStateChanged", throttledUpdateResizeRect);
            editor.on("keyup compositionend", function(e) {
              if (selectedElm && selectedElm.nodeName === "TABLE") {
                throttledUpdateResizeRect(e);
              }
            });
            editor.on("hide blur", hideResizeRect);
            editor.on("contextmenu", contextMenuSelectImage);
          });
          editor.on("remove", unbindResizeHandleEvents);
          var destroy2 = function() {
            selectedElm = selectedElmGhost = null;
          };
          return {
            isResizable,
            showResizeRect,
            hideResizeRect,
            updateResizeRect,
            destroy: destroy2
          };
        };
        var hasCeProperty = function(node2) {
          return NodeType.isContentEditableTrue(node2) || NodeType.isContentEditableFalse(node2);
        };
        var findParent$1 = function(node2, rootNode, predicate) {
          while (node2 && node2 !== rootNode) {
            if (predicate(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var findClosestIeRange = function(clientX, clientY, doc2) {
          var element, rng, rects;
          element = doc2.elementFromPoint(clientX, clientY);
          rng = doc2.body.createTextRange();
          if (!element || element.tagName === "HTML") {
            element = doc2.body;
          }
          rng.moveToElementText(element);
          rects = Tools.toArray(rng.getClientRects());
          rects = rects.sort(function(a, b) {
            a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
            b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
            return a - b;
          });
          if (rects.length > 0) {
            clientY = (rects[0].bottom + rects[0].top) / 2;
            try {
              rng.moveToPoint(clientX, clientY);
              rng.collapse(true);
              return rng;
            } catch (ex) {
            }
          }
          return null;
        };
        var moveOutOfContentEditableFalse = function(rng, rootNode) {
          var parentElement = rng && rng.parentElement ? rng.parentElement() : null;
          return NodeType.isContentEditableFalse(findParent$1(parentElement, rootNode, hasCeProperty)) ? null : rng;
        };
        var fromPoint$1 = function(clientX, clientY, doc2) {
          var rng, point;
          var pointDoc = doc2;
          if (pointDoc.caretPositionFromPoint) {
            point = pointDoc.caretPositionFromPoint(clientX, clientY);
            if (point) {
              rng = doc2.createRange();
              rng.setStart(point.offsetNode, point.offset);
              rng.collapse(true);
            }
          } else if (doc2.caretRangeFromPoint) {
            rng = doc2.caretRangeFromPoint(clientX, clientY);
          } else if (pointDoc.body.createTextRange) {
            rng = pointDoc.body.createTextRange();
            try {
              rng.moveToPoint(clientX, clientY);
              rng.collapse(true);
            } catch (ex) {
              rng = findClosestIeRange(clientX, clientY, doc2);
            }
            return moveOutOfContentEditableFalse(rng, doc2.body);
          }
          return rng;
        };
        var CaretRangeFromPoint = { fromPoint: fromPoint$1 };
        var processRanges = function(editor, ranges) {
          return map(ranges, function(range2) {
            var evt = editor.fire("GetSelectionRange", { range: range2 });
            return evt.range !== range2 ? evt.range : range2;
          });
        };
        var EventProcessRanges = { processRanges };
        var fromElements = function(elements, scope) {
          var doc2 = scope || domGlobals.document;
          var fragment = doc2.createDocumentFragment();
          each(elements, function(element) {
            fragment.appendChild(element.dom());
          });
          return Element.fromDom(fragment);
        };
        var tableModel = Immutable("element", "width", "rows");
        var tableRow = Immutable("element", "cells");
        var cellPosition = Immutable("x", "y");
        var getSpan = function(td, key) {
          var value2 = parseInt(get(td, key), 10);
          return isNaN(value2) ? 1 : value2;
        };
        var fillout = function(table, x, y, tr, td) {
          var rowspan = getSpan(td, "rowspan");
          var colspan = getSpan(td, "colspan");
          var rows = table.rows();
          for (var y2 = y; y2 < y + rowspan; y2++) {
            if (!rows[y2]) {
              rows[y2] = tableRow(deep(tr), []);
            }
            for (var x2 = x; x2 < x + colspan; x2++) {
              var cells = rows[y2].cells();
              cells[x2] = y2 === y && x2 === x ? td : shallow(td);
            }
          }
        };
        var cellExists = function(table, x, y) {
          var rows = table.rows();
          var cells = rows[y] ? rows[y].cells() : [];
          return !!cells[x];
        };
        var skipCellsX = function(table, x, y) {
          while (cellExists(table, x, y)) {
            x++;
          }
          return x;
        };
        var getWidth = function(rows) {
          return foldl(rows, function(acc, row) {
            return row.cells().length > acc ? row.cells().length : acc;
          }, 0);
        };
        var findElementPos = function(table, element) {
          var rows = table.rows();
          for (var y = 0; y < rows.length; y++) {
            var cells = rows[y].cells();
            for (var x = 0; x < cells.length; x++) {
              if (eq(cells[x], element)) {
                return Option.some(cellPosition(x, y));
              }
            }
          }
          return Option.none();
        };
        var extractRows = function(table, sx, sy, ex, ey) {
          var newRows = [];
          var rows = table.rows();
          for (var y = sy; y <= ey; y++) {
            var cells = rows[y].cells();
            var slice2 = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
            newRows.push(tableRow(rows[y].element(), slice2));
          }
          return newRows;
        };
        var subTable = function(table, startPos, endPos) {
          var sx = startPos.x(), sy = startPos.y();
          var ex = endPos.x(), ey = endPos.y();
          var newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
          return tableModel(table.element(), getWidth(newRows), newRows);
        };
        var createDomTable = function(table, rows) {
          var tableElement = shallow(table.element());
          var tableBody = Element.fromTag("tbody");
          append$1(tableBody, rows);
          append(tableElement, tableBody);
          return tableElement;
        };
        var modelRowsToDomRows = function(table) {
          return map(table.rows(), function(row) {
            var cells = map(row.cells(), function(cell) {
              var td = deep(cell);
              remove(td, "colspan");
              remove(td, "rowspan");
              return td;
            });
            var tr = shallow(row.element());
            append$1(tr, cells);
            return tr;
          });
        };
        var fromDom$1 = function(tableElm) {
          var table = tableModel(shallow(tableElm), 0, []);
          each(descendants$1(tableElm, "tr"), function(tr, y) {
            each(descendants$1(tr, "td,th"), function(td, x) {
              fillout(table, skipCellsX(table, x, y), y, tr, td);
            });
          });
          return tableModel(table.element(), getWidth(table.rows()), table.rows());
        };
        var toDom = function(table) {
          return createDomTable(table, modelRowsToDomRows(table));
        };
        var subsection = function(table, startElement, endElement) {
          return findElementPos(table, startElement).bind(function(startPos) {
            return findElementPos(table, endElement).map(function(endPos) {
              return subTable(table, startPos, endPos);
            });
          });
        };
        var SimpleTableModel = {
          fromDom: fromDom$1,
          toDom,
          subsection
        };
        var findParentListContainer = function(parents2) {
          return find(parents2, function(elm) {
            return name(elm) === "ul" || name(elm) === "ol";
          });
        };
        var getFullySelectedListWrappers = function(parents2, rng) {
          return find(parents2, function(elm) {
            return name(elm) === "li" && hasAllContentsSelected(elm, rng);
          }).fold(constant([]), function(li) {
            return findParentListContainer(parents2).map(function(listCont) {
              return [
                Element.fromTag("li"),
                Element.fromTag(name(listCont))
              ];
            }).getOr([]);
          });
        };
        var wrap$3 = function(innerElm, elms) {
          var wrapped = foldl(elms, function(acc, elm) {
            append(elm, acc);
            return elm;
          }, innerElm);
          return elms.length > 0 ? fromElements([wrapped]) : wrapped;
        };
        var directListWrappers = function(commonAnchorContainer) {
          if (isListItem(commonAnchorContainer)) {
            return parent(commonAnchorContainer).filter(isList).fold(constant([]), function(listElm) {
              return [
                commonAnchorContainer,
                listElm
              ];
            });
          } else {
            return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
          }
        };
        var getWrapElements = function(rootNode, rng) {
          var commonAnchorContainer = Element.fromDom(rng.commonAncestorContainer);
          var parents2 = Parents.parentsAndSelf(commonAnchorContainer, rootNode);
          var wrapElements = filter(parents2, function(elm) {
            return isInline(elm) || isHeading(elm);
          });
          var listWrappers = getFullySelectedListWrappers(parents2, rng);
          var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
          return map(allWrappers, shallow);
        };
        var emptyFragment = function() {
          return fromElements([]);
        };
        var getFragmentFromRange = function(rootNode, rng) {
          return wrap$3(Element.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
        };
        var getParentTable = function(rootElm, cell) {
          return ancestor$1(cell, "table", curry(eq, rootElm));
        };
        var getTableFragment = function(rootNode, selectedTableCells) {
          return getParentTable(rootNode, selectedTableCells[0]).bind(function(tableElm) {
            var firstCell = selectedTableCells[0];
            var lastCell = selectedTableCells[selectedTableCells.length - 1];
            var fullTableModel = SimpleTableModel.fromDom(tableElm);
            return SimpleTableModel.subsection(fullTableModel, firstCell, lastCell).map(function(sectionedTableModel) {
              return fromElements([SimpleTableModel.toDom(sectionedTableModel)]);
            });
          }).getOrThunk(emptyFragment);
        };
        var getSelectionFragment = function(rootNode, ranges) {
          return ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
        };
        var read$4 = function(rootNode, ranges) {
          var selectedCells = TableCellSelection.getCellsFromElementOrRanges(ranges, rootNode);
          return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
        };
        var FragmentReader = { read: read$4 };
        var getTextContent = function(editor) {
          return Option.from(editor.selection.getRng()).map(function(rng) {
            var bin = editor.dom.add(editor.getBody(), "div", {
              "data-mce-bogus": "all",
              "style": "overflow: hidden; opacity: 0;"
            }, rng.cloneContents());
            var text = Zwsp.trim(bin.innerText);
            editor.dom.remove(bin);
            return text;
          }).getOr("");
        };
        var getHtmlContent = function(editor, args) {
          var rng = editor.selection.getRng(), tmpElm = editor.dom.create("body");
          var sel = editor.selection.getSel();
          var fragment;
          var ranges = EventProcessRanges.processRanges(editor, MultiRange.getRanges(sel));
          fragment = args.contextual ? FragmentReader.read(Element.fromDom(editor.getBody()), ranges).dom() : rng.cloneContents();
          if (fragment) {
            tmpElm.appendChild(fragment);
          }
          return editor.selection.serializer.serialize(tmpElm, args);
        };
        var getContent = function(editor, args) {
          if (args === void 0) {
            args = {};
          }
          args.get = true;
          args.format = args.format || "html";
          args.selection = true;
          args = editor.fire("BeforeGetContent", args);
          if (args.isDefaultPrevented()) {
            editor.fire("GetContent", args);
            return args.content;
          }
          if (args.format === "text") {
            return getTextContent(editor);
          } else {
            args.getInner = true;
            var content = getHtmlContent(editor, args);
            if (args.format === "tree") {
              return content;
            } else {
              args.content = editor.selection.isCollapsed() ? "" : content;
              editor.fire("GetContent", args);
              return args.content;
            }
          }
        };
        var GetSelectionContent = { getContent };
        var setupArgs = function(args, content) {
          return __assign(__assign({ format: "html" }, args), {
            set: true,
            selection: true,
            content
          });
        };
        var cleanContent = function(editor, args) {
          if (args.format !== "raw") {
            var node2 = editor.parser.parse(args.content, __assign({
              isRootContent: true,
              forced_root_block: false
            }, args));
            return HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(node2);
          } else {
            return args.content;
          }
        };
        var setContent = function(editor, content, args) {
          var contentArgs = setupArgs(args, content);
          var rng = editor.selection.getRng(), caretNode;
          var doc2 = editor.getDoc();
          var frag, temp;
          if (!contentArgs.no_events) {
            contentArgs = editor.fire("BeforeSetContent", contentArgs);
            if (contentArgs.isDefaultPrevented()) {
              editor.fire("SetContent", contentArgs);
              return;
            }
          }
          content = cleanContent(editor, contentArgs);
          if (rng.insertNode) {
            content += '<span id="__caret">_</span>';
            if (rng.startContainer === doc2 && rng.endContainer === doc2) {
              doc2.body.innerHTML = content;
            } else {
              rng.deleteContents();
              if (doc2.body.childNodes.length === 0) {
                doc2.body.innerHTML = content;
              } else {
                if (rng.createContextualFragment) {
                  rng.insertNode(rng.createContextualFragment(content));
                } else {
                  frag = doc2.createDocumentFragment();
                  temp = doc2.createElement("div");
                  frag.appendChild(temp);
                  temp.outerHTML = content;
                  rng.insertNode(frag);
                }
              }
            }
            caretNode = editor.dom.get("__caret");
            rng = doc2.createRange();
            rng.setStartBefore(caretNode);
            rng.setEndBefore(caretNode);
            editor.selection.setRng(rng);
            editor.dom.remove("__caret");
            try {
              editor.selection.setRng(rng);
            } catch (ex) {
            }
          } else {
            var anyRng = rng;
            if (anyRng.item) {
              doc2.execCommand("Delete", false, null);
              anyRng = editor.selection.getRng();
            }
            if (/^\s+/.test(content)) {
              anyRng.pasteHTML('<span id="__mce_tmp">_</span>' + content);
              editor.dom.remove("__mce_tmp");
            } else {
              anyRng.pasteHTML(content);
            }
          }
          if (!contentArgs.no_events) {
            editor.fire("SetContent", contentArgs);
          }
        };
        var SetSelectionContent = { setContent };
        var getEndpointElement = function(root, rng, start2, real, resolve2) {
          var container = start2 ? rng.startContainer : rng.endContainer;
          var offset = start2 ? rng.startOffset : rng.endOffset;
          return Option.from(container).map(Element.fromDom).map(function(elm) {
            return !real || !rng.collapsed ? child(elm, resolve2(elm, offset)).getOr(elm) : elm;
          }).bind(function(elm) {
            return isElement(elm) ? Option.some(elm) : parent(elm);
          }).map(function(elm) {
            return elm.dom();
          }).getOr(root);
        };
        var getStart$2 = function(root, rng, real) {
          return getEndpointElement(root, rng, true, real, function(elm, offset) {
            return Math.min(childNodesCount(elm), offset);
          });
        };
        var getEnd = function(root, rng, real) {
          return getEndpointElement(root, rng, false, real, function(elm, offset) {
            return offset > 0 ? offset - 1 : offset;
          });
        };
        var skipEmptyTextNodes = function(node2, forwards) {
          var orig = node2;
          while (node2 && NodeType.isText(node2) && node2.length === 0) {
            node2 = forwards ? node2.nextSibling : node2.previousSibling;
          }
          return node2 || orig;
        };
        var getNode$1 = function(root, rng) {
          var elm, startContainer, endContainer, startOffset, endOffset;
          if (!rng) {
            return root;
          }
          startContainer = rng.startContainer;
          endContainer = rng.endContainer;
          startOffset = rng.startOffset;
          endOffset = rng.endOffset;
          elm = rng.commonAncestorContainer;
          if (!rng.collapsed) {
            if (startContainer === endContainer) {
              if (endOffset - startOffset < 2) {
                if (startContainer.hasChildNodes()) {
                  elm = startContainer.childNodes[startOffset];
                }
              }
            }
            if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
              if (startContainer.length === startOffset) {
                startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
              } else {
                startContainer = startContainer.parentNode;
              }
              if (endOffset === 0) {
                endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
              } else {
                endContainer = endContainer.parentNode;
              }
              if (startContainer && startContainer === endContainer) {
                return startContainer;
              }
            }
          }
          if (elm && elm.nodeType === 3) {
            return elm.parentNode;
          }
          return elm;
        };
        var getSelectedBlocks = function(dom2, rng, startElm, endElm) {
          var node2, root;
          var selectedBlocks = [];
          root = dom2.getRoot();
          startElm = dom2.getParent(startElm || getStart$2(root, rng, rng.collapsed), dom2.isBlock);
          endElm = dom2.getParent(endElm || getEnd(root, rng, rng.collapsed), dom2.isBlock);
          if (startElm && startElm !== root) {
            selectedBlocks.push(startElm);
          }
          if (startElm && endElm && startElm !== endElm) {
            node2 = startElm;
            var walker = new TreeWalker(startElm, root);
            while ((node2 = walker.next()) && node2 !== endElm) {
              if (dom2.isBlock(node2)) {
                selectedBlocks.push(node2);
              }
            }
          }
          if (endElm && startElm !== endElm && endElm !== root) {
            selectedBlocks.push(endElm);
          }
          return selectedBlocks;
        };
        var select$1 = function(dom2, node2, content) {
          return Option.from(node2).map(function(node3) {
            var idx = dom2.nodeIndex(node3);
            var rng = dom2.createRng();
            rng.setStart(node3.parentNode, idx);
            rng.setEnd(node3.parentNode, idx + 1);
            if (content) {
              moveEndPoint$1(dom2, rng, node3, true);
              moveEndPoint$1(dom2, rng, node3, false);
            }
            return rng;
          });
        };
        var each$j = Tools.each;
        var isNativeIeSelection = function(rng) {
          return !!rng.select;
        };
        var isAttachedToDom = function(node2) {
          return !!(node2 && node2.ownerDocument) && contains$3(Element.fromDom(node2.ownerDocument), Element.fromDom(node2));
        };
        var isValidRange = function(rng) {
          if (!rng) {
            return false;
          } else if (isNativeIeSelection(rng)) {
            return true;
          } else {
            return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
          }
        };
        var Selection$1 = function(dom2, win, serializer, editor) {
          var bookmarkManager, controlSelection;
          var selectedRange, explicitRange, selectorChangedData;
          var setCursorLocation = function(node2, offset) {
            var rng = dom2.createRng();
            if (!node2) {
              moveEndPoint$1(dom2, rng, editor.getBody(), true);
              setRng(rng);
            } else {
              rng.setStart(node2, offset);
              rng.setEnd(node2, offset);
              setRng(rng);
              collapse2(false);
            }
          };
          var getContent2 = function(args) {
            return GetSelectionContent.getContent(editor, args);
          };
          var setContent2 = function(content, args) {
            return SetSelectionContent.setContent(editor, content, args);
          };
          var getStart2 = function(real) {
            return getStart$2(editor.getBody(), getRng2(), real);
          };
          var getEnd$1 = function(real) {
            return getEnd(editor.getBody(), getRng2(), real);
          };
          var getBookmark2 = function(type2, normalized) {
            return bookmarkManager.getBookmark(type2, normalized);
          };
          var moveToBookmark2 = function(bookmark) {
            return bookmarkManager.moveToBookmark(bookmark);
          };
          var select2 = function(node2, content) {
            select$1(dom2, node2, content).each(setRng);
            return node2;
          };
          var isCollapsed = function() {
            var rng = getRng2(), sel = getSel();
            if (!rng || rng.item) {
              return false;
            }
            if (rng.compareEndPoints) {
              return rng.compareEndPoints("StartToEnd", rng) === 0;
            }
            return !sel || rng.collapsed;
          };
          var collapse2 = function(toStart) {
            var rng = getRng2();
            rng.collapse(!!toStart);
            setRng(rng);
          };
          var getSel = function() {
            return win.getSelection ? win.getSelection() : win.document.selection;
          };
          var getRng2 = function() {
            var selection, rng, elm, doc2;
            var tryCompareBoundaryPoints = function(how, sourceRange, destinationRange) {
              try {
                return sourceRange.compareBoundaryPoints(how, destinationRange);
              } catch (ex) {
                return -1;
              }
            };
            if (!win) {
              return null;
            }
            doc2 = win.document;
            if (typeof doc2 === "undefined" || doc2 === null) {
              return null;
            }
            if (editor.bookmark !== void 0 && EditorFocus.hasFocus(editor) === false) {
              var bookmark = SelectionBookmark.getRng(editor);
              if (bookmark.isSome()) {
                return bookmark.map(function(r) {
                  return EventProcessRanges.processRanges(editor, [r])[0];
                }).getOr(doc2.createRange());
              }
            }
            try {
              if ((selection = getSel()) && !NodeType.isRestrictedNode(selection.anchorNode)) {
                if (selection.rangeCount > 0) {
                  rng = selection.getRangeAt(0);
                } else {
                  rng = selection.createRange ? selection.createRange() : doc2.createRange();
                }
              }
            } catch (ex) {
            }
            rng = EventProcessRanges.processRanges(editor, [rng])[0];
            if (!rng) {
              rng = doc2.createRange ? doc2.createRange() : doc2.body.createTextRange();
            }
            if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
              elm = dom2.getRoot();
              rng.setStart(elm, 0);
              rng.setEnd(elm, 0);
            }
            if (selectedRange && explicitRange) {
              if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
                rng = explicitRange;
              } else {
                selectedRange = null;
                explicitRange = null;
              }
            }
            return rng;
          };
          var setRng = function(rng, forward) {
            var sel, node2, evt;
            if (!isValidRange(rng)) {
              return;
            }
            var ieRange = isNativeIeSelection(rng) ? rng : null;
            if (ieRange) {
              explicitRange = null;
              try {
                ieRange.select();
              } catch (ex) {
              }
              return;
            }
            sel = getSel();
            evt = editor.fire("SetSelectionRange", {
              range: rng,
              forward
            });
            rng = evt.range;
            if (sel) {
              explicitRange = rng;
              try {
                sel.removeAllRanges();
                sel.addRange(rng);
              } catch (ex) {
              }
              if (forward === false && sel.extend) {
                sel.collapse(rng.endContainer, rng.endOffset);
                sel.extend(rng.startContainer, rng.startOffset);
              }
              selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
            }
            if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
              if (rng.endOffset - rng.startOffset < 2) {
                if (rng.startContainer.hasChildNodes()) {
                  node2 = rng.startContainer.childNodes[rng.startOffset];
                  if (node2 && node2.tagName === "IMG") {
                    sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                    if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                      sel.setBaseAndExtent(node2, 0, node2, 1);
                    }
                  }
                }
              }
            }
            editor.fire("AfterSetSelectionRange", {
              range: rng,
              forward
            });
          };
          var setNode = function(elm) {
            setContent2(dom2.getOuterHTML(elm));
            return elm;
          };
          var getNode2 = function() {
            return getNode$1(editor.getBody(), getRng2());
          };
          var getSelectedBlocks$1 = function(startElm, endElm) {
            return getSelectedBlocks(dom2, getRng2(), startElm, endElm);
          };
          var isForward = function() {
            var sel = getSel();
            var anchorRange, focusRange;
            if (!sel || !sel.anchorNode || !sel.focusNode) {
              return true;
            }
            anchorRange = dom2.createRng();
            anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
            anchorRange.collapse(true);
            focusRange = dom2.createRng();
            focusRange.setStart(sel.focusNode, sel.focusOffset);
            focusRange.collapse(true);
            return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
          };
          var normalize2 = function() {
            var rng = getRng2();
            var sel = getSel();
            if (!MultiRange.hasMultipleRanges(sel) && hasAnyRanges(editor)) {
              var normRng = NormalizeRange.normalize(dom2, rng);
              normRng.each(function(normRng2) {
                setRng(normRng2, isForward());
              });
              return normRng.getOr(rng);
            }
            return rng;
          };
          var selectorChanged = function(selector, callback) {
            var currentSelectors;
            if (!selectorChangedData) {
              selectorChangedData = {};
              currentSelectors = {};
              editor.on("NodeChange", function(e) {
                var node2 = e.element, parents2 = dom2.getParents(node2, null, dom2.getRoot()), matchedSelectors = {};
                each$j(selectorChangedData, function(callbacks, selector2) {
                  each$j(parents2, function(node3) {
                    if (dom2.is(node3, selector2)) {
                      if (!currentSelectors[selector2]) {
                        each$j(callbacks, function(callback2) {
                          callback2(true, {
                            node: node3,
                            selector: selector2,
                            parents: parents2
                          });
                        });
                        currentSelectors[selector2] = callbacks;
                      }
                      matchedSelectors[selector2] = callbacks;
                      return false;
                    }
                  });
                });
                each$j(currentSelectors, function(callbacks, selector2) {
                  if (!matchedSelectors[selector2]) {
                    delete currentSelectors[selector2];
                    each$j(callbacks, function(callback2) {
                      callback2(false, {
                        node: node2,
                        selector: selector2,
                        parents: parents2
                      });
                    });
                  }
                });
              });
            }
            if (!selectorChangedData[selector]) {
              selectorChangedData[selector] = [];
            }
            selectorChangedData[selector].push(callback);
            return exports2;
          };
          var getScrollContainer = function() {
            var scrollContainer;
            var node2 = dom2.getRoot();
            while (node2 && node2.nodeName !== "BODY") {
              if (node2.scrollHeight > node2.clientHeight) {
                scrollContainer = node2;
                break;
              }
              node2 = node2.parentNode;
            }
            return scrollContainer;
          };
          var scrollIntoView = function(elm, alignToTop) {
            return ScrollIntoView.scrollElementIntoView(editor, elm, alignToTop);
          };
          var placeCaretAt = function(clientX, clientY) {
            return setRng(CaretRangeFromPoint.fromPoint(clientX, clientY, editor.getDoc()));
          };
          var getBoundingClientRect2 = function() {
            var rng = getRng2();
            return rng.collapsed ? CaretPosition$1.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
          };
          var destroy2 = function() {
            win = selectedRange = explicitRange = null;
            controlSelection.destroy();
          };
          var exports2 = {
            bookmarkManager: null,
            controlSelection: null,
            dom: dom2,
            win,
            serializer,
            editor,
            collapse: collapse2,
            setCursorLocation,
            getContent: getContent2,
            setContent: setContent2,
            getBookmark: getBookmark2,
            moveToBookmark: moveToBookmark2,
            select: select2,
            isCollapsed,
            isForward,
            setNode,
            getNode: getNode2,
            getSel,
            setRng,
            getRng: getRng2,
            getStart: getStart2,
            getEnd: getEnd$1,
            getSelectedBlocks: getSelectedBlocks$1,
            normalize: normalize2,
            selectorChanged,
            getScrollContainer,
            scrollIntoView,
            placeCaretAt,
            getBoundingClientRect: getBoundingClientRect2,
            destroy: destroy2
          };
          bookmarkManager = BookmarkManager$1(exports2);
          controlSelection = ControlSelection(exports2, editor);
          exports2.bookmarkManager = bookmarkManager;
          exports2.controlSelection = controlSelection;
          return exports2;
        };
        var BreakType;
        (function(BreakType2) {
          BreakType2[BreakType2["Br"] = 0] = "Br";
          BreakType2[BreakType2["Block"] = 1] = "Block";
          BreakType2[BreakType2["Wrap"] = 2] = "Wrap";
          BreakType2[BreakType2["Eol"] = 3] = "Eol";
        })(BreakType || (BreakType = {}));
        var flip = function(direction, positions) {
          return direction === HDirection.Backwards ? positions.reverse() : positions;
        };
        var walk$3 = function(direction, caretWalker, pos) {
          return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
        };
        var getBreakType = function(scope, direction, currentPos, nextPos) {
          if (NodeType.isBr(nextPos.getNode(direction === HDirection.Forwards))) {
            return BreakType.Br;
          } else if (isInSameBlock(currentPos, nextPos) === false) {
            return BreakType.Block;
          } else {
            return BreakType.Wrap;
          }
        };
        var getPositionsUntil = function(predicate, direction, scope, start2) {
          var caretWalker = CaretWalker(scope);
          var currentPos = start2, nextPos;
          var positions = [];
          while (currentPos) {
            nextPos = walk$3(direction, caretWalker, currentPos);
            if (!nextPos) {
              break;
            }
            if (NodeType.isBr(nextPos.getNode(false))) {
              if (direction === HDirection.Forwards) {
                return {
                  positions: flip(direction, positions).concat([nextPos]),
                  breakType: BreakType.Br,
                  breakAt: Option.some(nextPos)
                };
              } else {
                return {
                  positions: flip(direction, positions),
                  breakType: BreakType.Br,
                  breakAt: Option.some(nextPos)
                };
              }
            }
            if (!nextPos.isVisible()) {
              currentPos = nextPos;
              continue;
            }
            if (predicate(currentPos, nextPos)) {
              var breakType = getBreakType(scope, direction, currentPos, nextPos);
              return {
                positions: flip(direction, positions),
                breakType,
                breakAt: Option.some(nextPos)
              };
            }
            positions.push(nextPos);
            currentPos = nextPos;
          }
          return {
            positions: flip(direction, positions),
            breakType: BreakType.Eol,
            breakAt: Option.none()
          };
        };
        var getAdjacentLinePositions = function(direction, getPositionsUntilBreak, scope, start2) {
          return getPositionsUntilBreak(scope, start2).breakAt.map(function(pos) {
            var positions = getPositionsUntilBreak(scope, pos).positions;
            return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
          }).getOr([]);
        };
        var findClosestHorizontalPositionFromPoint = function(positions, x) {
          return foldl(positions, function(acc, newPos) {
            return acc.fold(function() {
              return Option.some(newPos);
            }, function(lastPos) {
              return lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), function(lastRect, newRect) {
                var lastDist = Math.abs(x - lastRect.left);
                var newDist = Math.abs(x - newRect.left);
                return newDist <= lastDist ? newPos : lastPos;
              }).or(acc);
            });
          }, Option.none());
        };
        var findClosestHorizontalPosition = function(positions, pos) {
          return head(pos.getClientRects()).bind(function(targetRect) {
            return findClosestHorizontalPositionFromPoint(positions, targetRect.left);
          });
        };
        var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
        var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
        var isAtFirstLine = function(scope, pos) {
          return getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
        };
        var isAtLastLine = function(scope, pos) {
          return getPositionsUntilNextLine(scope, pos).breakAt.isNone();
        };
        var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
        var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
        var getFirstLinePositions = function(scope) {
          return CaretFinder.firstPositionIn(scope).map(function(pos) {
            return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);
          }).getOr([]);
        };
        var getLastLinePositions = function(scope) {
          return CaretFinder.lastPositionIn(scope).map(function(pos) {
            return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);
          }).getOr([]);
        };
        var isContentEditableFalse$b = NodeType.isContentEditableFalse;
        var getSelectedNode$1 = getSelectedNode;
        var moveToCeFalseHorizontally = function(direction, editor, getNextPosFn, range2) {
          var forwards = direction === HDirection.Forwards;
          var isBeforeContentEditableFalseFn = forwards ? isBeforeContentEditableFalse : isAfterContentEditableFalse;
          if (!range2.collapsed) {
            var node2 = getSelectedNode$1(range2);
            if (isContentEditableFalse$b(node2)) {
              return showCaret(direction, editor, node2, direction === HDirection.Backwards, true);
            }
          }
          var rangeIsInContainerBlock = isRangeInCaretContainerBlock(range2);
          var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
          if (isBeforeContentEditableFalseFn(caretPosition)) {
            return selectNode(editor, caretPosition.getNode(!forwards));
          }
          var nextCaretPosition = InlineUtils.normalizePosition(forwards, getNextPosFn(caretPosition));
          if (!nextCaretPosition) {
            if (rangeIsInContainerBlock) {
              return range2;
            }
            return null;
          }
          if (isBeforeContentEditableFalseFn(nextCaretPosition)) {
            return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, true);
          }
          var peekCaretPosition = getNextPosFn(nextCaretPosition);
          if (peekCaretPosition && isBeforeContentEditableFalseFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
              return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, true);
            }
          }
          if (rangeIsInContainerBlock) {
            return renderRangeCaret(editor, nextCaretPosition.toRange(), true);
          }
          return null;
        };
        var moveToCeFalseVertically = function(direction, editor, walkerFn, range2) {
          var caretPosition, linePositions, nextLinePositions;
          var closestNextLineRect, caretClientRect, clientX;
          var dist1, dist2, contentEditableFalseNode;
          contentEditableFalseNode = getSelectedNode$1(range2);
          caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
          linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);
          nextLinePositions = filter(linePositions, isLine(1));
          caretClientRect = ArrUtils.last(caretPosition.getClientRects());
          if (isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition)) {
            contentEditableFalseNode = caretPosition.getNode();
          }
          if (isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition)) {
            contentEditableFalseNode = caretPosition.getNode(true);
          }
          if (!caretClientRect) {
            return null;
          }
          clientX = caretClientRect.left;
          closestNextLineRect = findClosestClientRect(nextLinePositions, clientX);
          if (closestNextLineRect) {
            if (isContentEditableFalse$b(closestNextLineRect.node)) {
              dist1 = Math.abs(clientX - closestNextLineRect.left);
              dist2 = Math.abs(clientX - closestNextLineRect.right);
              return showCaret(direction, editor, closestNextLineRect.node, dist1 < dist2, true);
            }
          }
          if (contentEditableFalseNode) {
            var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), contentEditableFalseNode);
            closestNextLineRect = findClosestClientRect(filter(caretPositions, isLine(1)), clientX);
            if (closestNextLineRect) {
              return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
            }
            closestNextLineRect = ArrUtils.last(filter(caretPositions, isLine(0)));
            if (closestNextLineRect) {
              return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
            }
          }
        };
        var createTextBlock = function(editor) {
          var textBlock = editor.dom.create(Settings.getForcedRootBlock(editor));
          if (!Env.ie || Env.ie >= 11) {
            textBlock.innerHTML = '<br data-mce-bogus="1">';
          }
          return textBlock;
        };
        var exitPreBlock = function(editor, direction, range2) {
          var pre, caretPos, newBlock;
          var caretWalker = CaretWalker(editor.getBody());
          var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
          var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
          if (range2.collapsed && editor.settings.forced_root_block) {
            pre = editor.dom.getParent(range2.startContainer, "PRE");
            if (!pre) {
              return;
            }
            if (direction === 1) {
              caretPos = getNextVisualCaretPosition(CaretPosition$1.fromRangeStart(range2));
            } else {
              caretPos = getPrevVisualCaretPosition(CaretPosition$1.fromRangeStart(range2));
            }
            if (!caretPos) {
              newBlock = createTextBlock(editor);
              if (direction === 1) {
                editor.$(pre).after(newBlock);
              } else {
                editor.$(pre).before(newBlock);
              }
              editor.selection.select(newBlock, true);
              editor.selection.collapse();
            }
          }
        };
        var getHorizontalRange = function(editor, forward) {
          var caretWalker = CaretWalker(editor.getBody());
          var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
          var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
          var newRange;
          var direction = forward ? HDirection.Forwards : HDirection.Backwards;
          var getNextPosFn = forward ? getNextVisualCaretPosition : getPrevVisualCaretPosition;
          var range2 = editor.selection.getRng();
          newRange = moveToCeFalseHorizontally(direction, editor, getNextPosFn, range2);
          if (newRange) {
            return newRange;
          }
          newRange = exitPreBlock(editor, direction, range2);
          if (newRange) {
            return newRange;
          }
          return null;
        };
        var getVerticalRange = function(editor, down) {
          var newRange;
          var direction = down ? 1 : -1;
          var walkerFn = down ? downUntil : upUntil;
          var range2 = editor.selection.getRng();
          newRange = moveToCeFalseVertically(direction, editor, walkerFn, range2);
          if (newRange) {
            return newRange;
          }
          newRange = exitPreBlock(editor, direction, range2);
          if (newRange) {
            return newRange;
          }
          return null;
        };
        var moveH = function(editor, forward) {
          return function() {
            var newRng = getHorizontalRange(editor, forward);
            if (newRng) {
              moveToRange(editor, newRng);
              return true;
            } else {
              return false;
            }
          };
        };
        var moveV = function(editor, down) {
          return function() {
            var newRng = getVerticalRange(editor, down);
            if (newRng) {
              moveToRange(editor, newRng);
              return true;
            } else {
              return false;
            }
          };
        };
        var isCefPosition = function(forward) {
          return function(pos) {
            return forward ? isAfterContentEditableFalse(pos) : isBeforeContentEditableFalse(pos);
          };
        };
        var moveToLineEndPoint = function(editor, forward) {
          return function() {
            var from2 = forward ? CaretPosition$1.fromRangeEnd(editor.selection.getRng()) : CaretPosition$1.fromRangeStart(editor.selection.getRng());
            var result = forward ? getPositionsUntilNextLine(editor.getBody(), from2) : getPositionsUntilPreviousLine(editor.getBody(), from2);
            var to = forward ? last(result.positions) : head(result.positions);
            return to.filter(isCefPosition(forward)).fold(constant(false), function(pos) {
              editor.selection.setRng(pos.toRange());
              return true;
            });
          };
        };
        var deflate = function(rect, delta) {
          return {
            left: rect.left - delta,
            top: rect.top - delta,
            right: rect.right + delta * 2,
            bottom: rect.bottom + delta * 2,
            width: rect.width + delta,
            height: rect.height + delta
          };
        };
        var getCorners = function(getYAxisValue, tds) {
          return bind(tds, function(td) {
            var rect = deflate(clone$1(td.getBoundingClientRect()), -1);
            return [
              {
                x: rect.left,
                y: getYAxisValue(rect),
                cell: td
              },
              {
                x: rect.right,
                y: getYAxisValue(rect),
                cell: td
              }
            ];
          });
        };
        var findClosestCorner = function(corners, x, y) {
          return foldl(corners, function(acc, newCorner) {
            return acc.fold(function() {
              return Option.some(newCorner);
            }, function(oldCorner) {
              var oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
              var newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
              return Option.some(newDist < oldDist ? newCorner : oldCorner);
            });
          }, Option.none());
        };
        var getClosestCell$1 = function(getYAxisValue, isTargetCorner, table, x, y) {
          var cells = descendants$1(Element.fromDom(table), "td,th,caption").map(function(e) {
            return e.dom();
          });
          var corners = filter(getCorners(getYAxisValue, cells), function(corner) {
            return isTargetCorner(corner, y);
          });
          return findClosestCorner(corners, x, y).map(function(corner) {
            return corner.cell;
          });
        };
        var getBottomValue = function(rect) {
          return rect.bottom;
        };
        var getTopValue = function(rect) {
          return rect.top;
        };
        var isAbove$1 = function(corner, y) {
          return corner.y < y;
        };
        var isBelow$1 = function(corner, y) {
          return corner.y > y;
        };
        var getClosestCellAbove = curry(getClosestCell$1, getBottomValue, isAbove$1);
        var getClosestCellBelow = curry(getClosestCell$1, getTopValue, isBelow$1);
        var findClosestPositionInAboveCell = function(table, pos) {
          return head(pos.getClientRects()).bind(function(rect) {
            return getClosestCellAbove(table, rect.left, rect.top);
          }).bind(function(cell) {
            return findClosestHorizontalPosition(getLastLinePositions(cell), pos);
          });
        };
        var findClosestPositionInBelowCell = function(table, pos) {
          return last(pos.getClientRects()).bind(function(rect) {
            return getClosestCellBelow(table, rect.left, rect.top);
          }).bind(function(cell) {
            return findClosestHorizontalPosition(getFirstLinePositions(cell), pos);
          });
        };
        var hasNextBreak = function(getPositionsUntil2, scope, lineInfo) {
          return lineInfo.breakAt.map(function(breakPos) {
            return getPositionsUntil2(scope, breakPos).breakAt.isSome();
          }).getOr(false);
        };
        var startsWithWrapBreak = function(lineInfo) {
          return lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
        };
        var startsWithBrBreak = function(lineInfo) {
          return lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
        };
        var isAtTableCellLine = function(getPositionsUntil2, scope, pos) {
          var lineInfo = getPositionsUntil2(scope, pos);
          if (startsWithWrapBreak(lineInfo) || !NodeType.isBr(pos.getNode()) && startsWithBrBreak(lineInfo)) {
            return !hasNextBreak(getPositionsUntil2, scope, lineInfo);
          } else {
            return lineInfo.breakAt.isNone();
          }
        };
        var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
        var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
        var isCaretAtStartOrEndOfTable = function(forward, rng, table) {
          var caretPos = CaretPosition$1.fromRangeStart(rng);
          return CaretFinder.positionIn(!forward, table).map(function(pos) {
            return pos.isEqual(caretPos);
          }).getOr(false);
        };
        var navigateHorizontally = function(editor, forward, table, td) {
          var rng = editor.selection.getRng();
          var direction = forward ? 1 : -1;
          if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
            var newRng = showCaret(direction, editor, table, !forward, true);
            moveToRange(editor, newRng);
            return true;
          }
          return false;
        };
        var getClosestAbovePosition = function(root, table, start2) {
          return findClosestPositionInAboveCell(table, start2).orThunk(function() {
            return head(start2.getClientRects()).bind(function(rect) {
              return findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition$1.before(table)), rect.left);
            });
          }).getOr(CaretPosition$1.before(table));
        };
        var getClosestBelowPosition = function(root, table, start2) {
          return findClosestPositionInBelowCell(table, start2).orThunk(function() {
            return head(start2.getClientRects()).bind(function(rect) {
              return findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition$1.after(table)), rect.left);
            });
          }).getOr(CaretPosition$1.after(table));
        };
        var getTable = function(previous, pos) {
          var node2 = pos.getNode(previous);
          return NodeType.isElement(node2) && node2.nodeName === "TABLE" ? Option.some(node2) : Option.none();
        };
        var renderBlock = function(down, editor, table, pos) {
          var forcedRootBlock = Settings.getForcedRootBlock(editor);
          if (forcedRootBlock) {
            editor.undoManager.transact(function() {
              var element = Element.fromTag(forcedRootBlock);
              setAll(element, Settings.getForcedRootBlockAttrs(editor));
              append(element, Element.fromTag("br"));
              if (down) {
                after(Element.fromDom(table), element);
              } else {
                before(Element.fromDom(table), element);
              }
              var rng = editor.dom.createRng();
              rng.setStart(element.dom(), 0);
              rng.setEnd(element.dom(), 0);
              moveToRange(editor, rng);
            });
          } else {
            moveToRange(editor, pos.toRange());
          }
        };
        var moveCaret = function(editor, down, pos) {
          var table = down ? getTable(true, pos) : getTable(false, pos);
          var last2 = down === false;
          table.fold(function() {
            return moveToRange(editor, pos.toRange());
          }, function(table2) {
            return CaretFinder.positionIn(last2, editor.getBody()).filter(function(lastPos) {
              return lastPos.isEqual(pos);
            }).fold(function() {
              return moveToRange(editor, pos.toRange());
            }, function(_) {
              return renderBlock(down, editor, table2, pos);
            });
          });
        };
        var navigateVertically = function(editor, down, table, td) {
          var rng = editor.selection.getRng();
          var pos = CaretPosition$1.fromRangeStart(rng);
          var root = editor.getBody();
          if (!down && isAtFirstTableCellLine(td, pos)) {
            var newPos = getClosestAbovePosition(root, table, pos);
            moveCaret(editor, down, newPos);
            return true;
          } else if (down && isAtLastTableCellLine(td, pos)) {
            var newPos = getClosestBelowPosition(root, table, pos);
            moveCaret(editor, down, newPos);
            return true;
          } else {
            return false;
          }
        };
        var moveH$1 = function(editor, forward) {
          return function() {
            return Option.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind(function(td) {
              return Option.from(editor.dom.getParent(td, "table")).map(function(table) {
                return navigateHorizontally(editor, forward, table);
              });
            }).getOr(false);
          };
        };
        var moveV$1 = function(editor, forward) {
          return function() {
            return Option.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind(function(td) {
              return Option.from(editor.dom.getParent(td, "table")).map(function(table) {
                return navigateVertically(editor, forward, table, td);
              });
            }).getOr(false);
          };
        };
        var isTarget = function(node2) {
          return contains(["figcaption"], name(node2));
        };
        var rangeBefore = function(target) {
          var rng = domGlobals.document.createRange();
          rng.setStartBefore(target.dom());
          rng.setEndBefore(target.dom());
          return rng;
        };
        var insertElement = function(root, elm, forward) {
          if (forward) {
            append(root, elm);
          } else {
            prepend(root, elm);
          }
        };
        var insertBr = function(root, forward) {
          var br = Element.fromTag("br");
          insertElement(root, br, forward);
          return rangeBefore(br);
        };
        var insertBlock$1 = function(root, forward, blockName, attrs) {
          var block = Element.fromTag(blockName);
          var br = Element.fromTag("br");
          setAll(block, attrs);
          append(block, br);
          insertElement(root, block, forward);
          return rangeBefore(br);
        };
        var insertEmptyLine = function(root, rootBlockName, attrs, forward) {
          if (rootBlockName === "") {
            return insertBr(root, forward);
          } else {
            return insertBlock$1(root, forward, rootBlockName, attrs);
          }
        };
        var getClosestTargetBlock = function(pos, root) {
          var isRoot = curry(eq, root);
          return closest(Element.fromDom(pos.container()), isBlock, isRoot).filter(isTarget);
        };
        var isAtFirstOrLastLine = function(root, forward, pos) {
          return forward ? isAtLastLine(root.dom(), pos) : isAtFirstLine(root.dom(), pos);
        };
        var moveCaretToNewEmptyLine = function(editor, forward) {
          var root = Element.fromDom(editor.getBody());
          var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          var rootBlock = Settings.getForcedRootBlock(editor);
          var rootBlockAttrs = Settings.getForcedRootBlockAttrs(editor);
          return getClosestTargetBlock(pos, root).exists(function() {
            if (isAtFirstOrLastLine(root, forward, pos)) {
              var rng = insertEmptyLine(root, rootBlock, rootBlockAttrs, forward);
              editor.selection.setRng(rng);
              return true;
            } else {
              return false;
            }
          });
        };
        var moveV$2 = function(editor, forward) {
          return function() {
            if (editor.selection.isCollapsed()) {
              return moveCaretToNewEmptyLine(editor, forward);
            } else {
              return false;
            }
          };
        };
        var defaultPatterns = function(patterns) {
          return map(patterns, function(pattern) {
            return merge({
              shiftKey: false,
              altKey: false,
              ctrlKey: false,
              metaKey: false,
              keyCode: 0,
              action: noop
            }, pattern);
          });
        };
        var matchesEvent = function(pattern, evt) {
          return evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
        };
        var match$1 = function(patterns, evt) {
          return bind(defaultPatterns(patterns), function(pattern) {
            return matchesEvent(pattern, evt) ? [pattern] : [];
          });
        };
        var action = function(f) {
          var x = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            x[_i - 1] = arguments[_i];
          }
          var args = Array.prototype.slice.call(arguments, 1);
          return function() {
            return f.apply(null, args);
          };
        };
        var execute = function(patterns, evt) {
          return find(match$1(patterns, evt), function(pattern) {
            return pattern.action();
          });
        };
        var MatchKeys = {
          match: match$1,
          action,
          execute
        };
        var executeKeydownOverride = function(editor, caret, evt) {
          var os = PlatformDetection$1.detect().os;
          MatchKeys.execute([
            {
              keyCode: VK.RIGHT,
              action: moveH(editor, true)
            },
            {
              keyCode: VK.LEFT,
              action: moveH(editor, false)
            },
            {
              keyCode: VK.UP,
              action: moveV(editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: moveV(editor, true)
            },
            {
              keyCode: VK.RIGHT,
              action: moveH$1(editor, true)
            },
            {
              keyCode: VK.LEFT,
              action: moveH$1(editor, false)
            },
            {
              keyCode: VK.UP,
              action: moveV$1(editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: moveV$1(editor, true)
            },
            {
              keyCode: VK.RIGHT,
              action: BoundarySelection.move(editor, caret, true)
            },
            {
              keyCode: VK.LEFT,
              action: BoundarySelection.move(editor, caret, false)
            },
            {
              keyCode: VK.RIGHT,
              ctrlKey: !os.isOSX(),
              altKey: os.isOSX(),
              action: BoundarySelection.moveNextWord(editor, caret)
            },
            {
              keyCode: VK.LEFT,
              ctrlKey: !os.isOSX(),
              altKey: os.isOSX(),
              action: BoundarySelection.movePrevWord(editor, caret)
            },
            {
              keyCode: VK.UP,
              action: moveV$2(editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: moveV$2(editor, true)
            }
          ], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var setup$7 = function(editor, caret) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride(editor, caret, evt);
            }
          });
        };
        var ArrowKeys = { setup: setup$7 };
        var executeKeydownOverride$1 = function(editor, caret, evt) {
          MatchKeys.execute([
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(CefDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(CefDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(CefBoundaryDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(CefBoundaryDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(TableDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(TableDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, true)
            }
          ], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var executeKeyupOverride = function(editor, evt) {
          MatchKeys.execute([
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
            }
          ], evt);
        };
        var setup$8 = function(editor, caret) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride$1(editor, caret, evt);
            }
          });
          editor.on("keyup", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeyupOverride(editor, evt);
            }
          });
        };
        var DeleteBackspaceKeys = { setup: setup$8 };
        var firstNonWhiteSpaceNodeSibling = function(node2) {
          while (node2) {
            if (node2.nodeType === 1 || node2.nodeType === 3 && node2.data && /[\r\n\s]/.test(node2.data)) {
              return node2;
            }
            node2 = node2.nextSibling;
          }
        };
        var moveToCaretPosition = function(editor, root) {
          var walker, node2, rng, lastNode = root, tempElm;
          var dom2 = editor.dom;
          var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
          if (!root) {
            return;
          }
          if (/^(LI|DT|DD)$/.test(root.nodeName)) {
            var firstChild2 = firstNonWhiteSpaceNodeSibling(root.firstChild);
            if (firstChild2 && /^(UL|OL|DL)$/.test(firstChild2.nodeName)) {
              root.insertBefore(dom2.doc.createTextNode("\xA0"), root.firstChild);
            }
          }
          rng = dom2.createRng();
          root.normalize();
          if (root.hasChildNodes()) {
            walker = new TreeWalker(root, root);
            while (node2 = walker.current()) {
              if (NodeType.isText(node2)) {
                rng.setStart(node2, 0);
                rng.setEnd(node2, 0);
                break;
              }
              if (moveCaretBeforeOnEnterElementsMap[node2.nodeName.toLowerCase()]) {
                rng.setStartBefore(node2);
                rng.setEndBefore(node2);
                break;
              }
              lastNode = node2;
              node2 = walker.next();
            }
            if (!node2) {
              rng.setStart(lastNode, 0);
              rng.setEnd(lastNode, 0);
            }
          } else {
            if (NodeType.isBr(root)) {
              if (root.nextSibling && dom2.isBlock(root.nextSibling)) {
                rng.setStartBefore(root);
                rng.setEndBefore(root);
              } else {
                rng.setStartAfter(root);
                rng.setEndAfter(root);
              }
            } else {
              rng.setStart(root, 0);
              rng.setEnd(root, 0);
            }
          }
          editor.selection.setRng(rng);
          dom2.remove(tempElm);
          editor.selection.scrollIntoView(root);
        };
        var getEditableRoot = function(dom2, node2) {
          var root = dom2.getRoot();
          var parent2, editableRoot;
          parent2 = node2;
          while (parent2 !== root && dom2.getContentEditable(parent2) !== "false") {
            if (dom2.getContentEditable(parent2) === "true") {
              editableRoot = parent2;
            }
            parent2 = parent2.parentNode;
          }
          return parent2 !== root ? editableRoot : root;
        };
        var getParentBlock$2 = function(editor) {
          return Option.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
        };
        var getParentBlockName = function(editor) {
          return getParentBlock$2(editor).fold(constant(""), function(parentBlock) {
            return parentBlock.nodeName.toUpperCase();
          });
        };
        var isListItemParentBlock = function(editor) {
          return getParentBlock$2(editor).filter(function(elm) {
            return isListItem(Element.fromDom(elm));
          }).isSome();
        };
        var NewLineUtils = {
          moveToCaretPosition,
          getEditableRoot,
          getParentBlock: getParentBlock$2,
          getParentBlockName,
          isListItemParentBlock
        };
        var hasFirstChild = function(elm, name2) {
          return elm.firstChild && elm.firstChild.nodeName === name2;
        };
        var hasParent$1 = function(elm, parentName) {
          return elm && elm.parentNode && elm.parentNode.nodeName === parentName;
        };
        var isListBlock = function(elm) {
          return elm && /^(OL|UL|LI)$/.test(elm.nodeName);
        };
        var isNestedList = function(elm) {
          return isListBlock(elm) && isListBlock(elm.parentNode);
        };
        var getContainerBlock = function(containerBlock) {
          var containerBlockParent = containerBlock.parentNode;
          if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
            return containerBlockParent;
          }
          return containerBlock;
        };
        var isFirstOrLastLi = function(containerBlock, parentBlock, first2) {
          var node2 = containerBlock[first2 ? "firstChild" : "lastChild"];
          while (node2) {
            if (NodeType.isElement(node2)) {
              break;
            }
            node2 = node2[first2 ? "nextSibling" : "previousSibling"];
          }
          return node2 === parentBlock;
        };
        var insert$1 = function(editor, createNewBlock, containerBlock, parentBlock, newBlockName) {
          var dom2 = editor.dom;
          var rng = editor.selection.getRng();
          if (containerBlock === editor.getBody()) {
            return;
          }
          if (isNestedList(containerBlock)) {
            newBlockName = "LI";
          }
          var newBlock = newBlockName ? createNewBlock(newBlockName) : dom2.create("BR");
          if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
            if (hasParent$1(containerBlock, "LI")) {
              dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
            } else {
              dom2.replace(newBlock, containerBlock);
            }
          } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
            if (hasParent$1(containerBlock, "LI")) {
              dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
              newBlock.appendChild(dom2.doc.createTextNode(" "));
              newBlock.appendChild(containerBlock);
            } else {
              containerBlock.parentNode.insertBefore(newBlock, containerBlock);
            }
          } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
            dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
          } else {
            containerBlock = getContainerBlock(containerBlock);
            var tmpRng = rng.cloneRange();
            tmpRng.setStartAfter(parentBlock);
            tmpRng.setEndAfter(containerBlock);
            var fragment = tmpRng.extractContents();
            if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
              newBlock = fragment.firstChild;
              dom2.insertAfter(fragment, containerBlock);
            } else {
              dom2.insertAfter(fragment, containerBlock);
              dom2.insertAfter(newBlock, containerBlock);
            }
          }
          dom2.remove(parentBlock);
          NewLineUtils.moveToCaretPosition(editor, newBlock);
        };
        var InsertLi = { insert: insert$1 };
        var trimZwsp = function(fragment) {
          each(descendants(Element.fromDom(fragment), isText), function(text) {
            var rawNode = text.dom();
            rawNode.nodeValue = Zwsp.trim(rawNode.nodeValue);
          });
        };
        var isEmptyAnchor = function(dom2, elm) {
          return elm && elm.nodeName === "A" && dom2.isEmpty(elm);
        };
        var isTableCell$5 = function(node2) {
          return node2 && /^(TD|TH|CAPTION)$/.test(node2.nodeName);
        };
        var emptyBlock = function(elm) {
          elm.innerHTML = '<br data-mce-bogus="1">';
        };
        var containerAndSiblingName = function(container, nodeName) {
          return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
        };
        var canSplitBlock = function(dom2, node2) {
          return node2 && dom2.isBlock(node2) && !/^(TD|TH|CAPTION|FORM)$/.test(node2.nodeName) && !/^(fixed|absolute)/i.test(node2.style.position) && dom2.getContentEditable(node2) !== "true";
        };
        var trimInlineElementsOnLeftSideOfBlock = function(dom2, nonEmptyElementsMap, block) {
          var node2 = block;
          var firstChilds = [];
          var i2;
          if (!node2) {
            return;
          }
          while (node2 = node2.firstChild) {
            if (dom2.isBlock(node2)) {
              return;
            }
            if (NodeType.isElement(node2) && !nonEmptyElementsMap[node2.nodeName.toLowerCase()]) {
              firstChilds.push(node2);
            }
          }
          i2 = firstChilds.length;
          while (i2--) {
            node2 = firstChilds[i2];
            if (!node2.hasChildNodes() || node2.firstChild === node2.lastChild && node2.firstChild.nodeValue === "") {
              dom2.remove(node2);
            } else {
              if (isEmptyAnchor(dom2, node2)) {
                dom2.remove(node2);
              }
            }
          }
        };
        var normalizeZwspOffset = function(start2, container, offset) {
          if (NodeType.isText(container) === false) {
            return offset;
          } else if (start2) {
            return offset === 1 && container.data.charAt(offset - 1) === Zwsp.ZWSP ? 0 : offset;
          } else {
            return offset === container.data.length - 1 && container.data.charAt(offset) === Zwsp.ZWSP ? container.data.length : offset;
          }
        };
        var includeZwspInRange = function(rng) {
          var newRng = rng.cloneRange();
          newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
          newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
          return newRng;
        };
        var trimLeadingLineBreaks = function(node2) {
          do {
            if (NodeType.isText(node2)) {
              node2.nodeValue = node2.nodeValue.replace(/^[\r\n]+/, "");
            }
            node2 = node2.firstChild;
          } while (node2);
        };
        var getEditableRoot$1 = function(dom2, node2) {
          var root = dom2.getRoot();
          var parent2, editableRoot;
          parent2 = node2;
          while (parent2 !== root && dom2.getContentEditable(parent2) !== "false") {
            if (dom2.getContentEditable(parent2) === "true") {
              editableRoot = parent2;
            }
            parent2 = parent2.parentNode;
          }
          return parent2 !== root ? editableRoot : root;
        };
        var applyAttributes = function(editor, node2, forcedRootBlockAttrs) {
          Option.from(forcedRootBlockAttrs.style).map(editor.dom.parseStyle).each(function(attrStyles) {
            var currentStyles = getAllRaw(Element.fromDom(node2));
            var newStyles = __assign(__assign({}, currentStyles), attrStyles);
            editor.dom.setStyles(node2, newStyles);
          });
          var attrClassesOpt = Option.from(forcedRootBlockAttrs.class).map(function(attrClasses) {
            return attrClasses.split(/\s+/);
          });
          var currentClassesOpt = Option.from(node2.className).map(function(currentClasses) {
            return filter(currentClasses.split(/\s+/), function(clazz) {
              return clazz !== "";
            });
          });
          lift2(attrClassesOpt, currentClassesOpt, function(attrClasses, currentClasses) {
            var filteredClasses = filter(currentClasses, function(clazz) {
              return !contains(attrClasses, clazz);
            });
            var newClasses = __spreadArrays(attrClasses, filteredClasses);
            editor.dom.setAttrib(node2, "class", newClasses.join(" "));
          });
          var appliedAttrs = [
            "style",
            "class"
          ];
          var remainingAttrs = bifilter(forcedRootBlockAttrs, function(_, attrs) {
            return !contains(appliedAttrs, attrs);
          }).t;
          editor.dom.setAttribs(node2, remainingAttrs);
        };
        var setForcedBlockAttrs = function(editor, node2) {
          var forcedRootBlockName = Settings.getForcedRootBlock(editor);
          if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node2.tagName.toLowerCase()) {
            var forcedRootBlockAttrs = Settings.getForcedRootBlockAttrs(editor);
            applyAttributes(editor, node2, forcedRootBlockAttrs);
          }
        };
        var wrapSelfAndSiblingsInDefaultBlock = function(editor, newBlockName, rng, container, offset) {
          var newBlock, parentBlock, startNode, node2, next, rootBlockName;
          var blockName = newBlockName || "P";
          var dom2 = editor.dom, editableRoot = getEditableRoot$1(dom2, container);
          parentBlock = dom2.getParent(container, dom2.isBlock);
          if (!parentBlock || !canSplitBlock(dom2, parentBlock)) {
            parentBlock = parentBlock || editableRoot;
            if (parentBlock === editor.getBody() || isTableCell$5(parentBlock)) {
              rootBlockName = parentBlock.nodeName.toLowerCase();
            } else {
              rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
            }
            if (!parentBlock.hasChildNodes()) {
              newBlock = dom2.create(blockName);
              setForcedBlockAttrs(editor, newBlock);
              parentBlock.appendChild(newBlock);
              rng.setStart(newBlock, 0);
              rng.setEnd(newBlock, 0);
              return newBlock;
            }
            node2 = container;
            while (node2.parentNode !== parentBlock) {
              node2 = node2.parentNode;
            }
            while (node2 && !dom2.isBlock(node2)) {
              startNode = node2;
              node2 = node2.previousSibling;
            }
            if (startNode && editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
              newBlock = dom2.create(blockName);
              setForcedBlockAttrs(editor, newBlock);
              startNode.parentNode.insertBefore(newBlock, startNode);
              node2 = startNode;
              while (node2 && !dom2.isBlock(node2)) {
                next = node2.nextSibling;
                newBlock.appendChild(node2);
                node2 = next;
              }
              rng.setStart(container, offset);
              rng.setEnd(container, offset);
            }
          }
          return container;
        };
        var addBrToBlockIfNeeded = function(dom2, block) {
          var lastChild2;
          block.normalize();
          lastChild2 = block.lastChild;
          if (!lastChild2 || /^(left|right)$/gi.test(dom2.getStyle(lastChild2, "float", true))) {
            dom2.add(block, "br");
          }
        };
        var insert$2 = function(editor, evt) {
          var tmpRng, editableRoot, container, offset, parentBlock, shiftKey;
          var newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;
          var dom2 = editor.dom;
          var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
          var rng = editor.selection.getRng();
          var createNewBlock = function(name2) {
            var node2 = container, block, clonedNode, caretNode;
            var textInlineElements = schema.getTextInlineElements();
            if (name2 || parentBlockName === "TABLE" || parentBlockName === "HR") {
              block = dom2.create(name2 || newBlockName);
            } else {
              block = parentBlock.cloneNode(false);
            }
            caretNode = block;
            if (Settings.shouldKeepStyles(editor) === false) {
              dom2.setAttrib(block, "style", null);
              dom2.setAttrib(block, "class", null);
            } else {
              do {
                if (textInlineElements[node2.nodeName]) {
                  if (isCaretNode(node2) || Bookmarks.isBookmarkNode(node2)) {
                    continue;
                  }
                  clonedNode = node2.cloneNode(false);
                  dom2.setAttrib(clonedNode, "id", "");
                  if (block.hasChildNodes()) {
                    clonedNode.appendChild(block.firstChild);
                    block.appendChild(clonedNode);
                  } else {
                    caretNode = clonedNode;
                    block.appendChild(clonedNode);
                  }
                }
              } while ((node2 = node2.parentNode) && node2 !== editableRoot);
            }
            setForcedBlockAttrs(editor, block);
            emptyBlock(caretNode);
            return block;
          };
          var isCaretAtStartOrEndOfBlock = function(start2) {
            var walker, node2, name2, normalizedOffset;
            normalizedOffset = normalizeZwspOffset(start2, container, offset);
            if (NodeType.isText(container) && (start2 ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {
              return false;
            }
            if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start2) {
              return true;
            }
            if (start2 && NodeType.isElement(container) && container === parentBlock.firstChild) {
              return true;
            }
            if (containerAndSiblingName(container, "TABLE") || containerAndSiblingName(container, "HR")) {
              return isAfterLastNodeInContainer && !start2 || !isAfterLastNodeInContainer && start2;
            }
            walker = new TreeWalker(container, parentBlock);
            if (NodeType.isText(container)) {
              if (start2 && normalizedOffset === 0) {
                walker.prev();
              } else if (!start2 && normalizedOffset === container.nodeValue.length) {
                walker.next();
              }
            }
            while (node2 = walker.current()) {
              if (NodeType.isElement(node2)) {
                if (!node2.getAttribute("data-mce-bogus")) {
                  name2 = node2.nodeName.toLowerCase();
                  if (nonEmptyElementsMap[name2] && name2 !== "br") {
                    return false;
                  }
                }
              } else if (NodeType.isText(node2) && !/^[ \t\r\n]*$/.test(node2.nodeValue)) {
                return false;
              }
              if (start2) {
                walker.prev();
              } else {
                walker.next();
              }
            }
            return true;
          };
          var insertNewBlockAfter = function() {
            if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== "HGROUP") {
              newBlock = createNewBlock(newBlockName);
            } else {
              newBlock = createNewBlock();
            }
            if (Settings.shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom2, containerBlock) && dom2.isEmpty(parentBlock)) {
              newBlock = dom2.split(containerBlock, parentBlock);
            } else {
              dom2.insertAfter(newBlock, parentBlock);
            }
            NewLineUtils.moveToCaretPosition(editor, newBlock);
          };
          NormalizeRange.normalize(dom2, rng).each(function(normRng) {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
          });
          container = rng.startContainer;
          offset = rng.startOffset;
          newBlockName = Settings.getForcedRootBlock(editor);
          shiftKey = evt.shiftKey;
          if (NodeType.isElement(container) && container.hasChildNodes()) {
            isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && NodeType.isText(container)) {
              offset = container.nodeValue.length;
            } else {
              offset = 0;
            }
          }
          editableRoot = getEditableRoot$1(dom2, container);
          if (!editableRoot) {
            return;
          }
          if (newBlockName && !shiftKey || !newBlockName && shiftKey) {
            container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
          }
          parentBlock = dom2.getParent(container, dom2.isBlock);
          containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
          parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
          containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
          if (containerBlockName === "LI" && !evt.ctrlKey) {
            parentBlock = containerBlock;
            containerBlock = containerBlock.parentNode;
            parentBlockName = containerBlockName;
          }
          if (/^(LI|DT|DD)$/.test(parentBlockName)) {
            if (dom2.isEmpty(parentBlock)) {
              InsertLi.insert(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
              return;
            }
          }
          if (newBlockName && parentBlock === editor.getBody()) {
            return;
          }
          newBlockName = newBlockName || "P";
          if (isCaretContainerBlock(parentBlock)) {
            newBlock = showCaretContainerBlock(parentBlock);
            if (dom2.isEmpty(parentBlock)) {
              emptyBlock(parentBlock);
            }
            setForcedBlockAttrs(editor, newBlock);
            NewLineUtils.moveToCaretPosition(editor, newBlock);
          } else if (isCaretAtStartOrEndOfBlock()) {
            insertNewBlockAfter();
          } else if (isCaretAtStartOrEndOfBlock(true)) {
            newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
            NewLineUtils.moveToCaretPosition(editor, containerAndSiblingName(parentBlock, "HR") ? newBlock : parentBlock);
          } else {
            tmpRng = includeZwspInRange(rng).cloneRange();
            tmpRng.setEndAfter(parentBlock);
            fragment = tmpRng.extractContents();
            trimZwsp(fragment);
            trimLeadingLineBreaks(fragment);
            newBlock = fragment.firstChild;
            dom2.insertAfter(fragment, parentBlock);
            trimInlineElementsOnLeftSideOfBlock(dom2, nonEmptyElementsMap, newBlock);
            addBrToBlockIfNeeded(dom2, parentBlock);
            if (dom2.isEmpty(parentBlock)) {
              emptyBlock(parentBlock);
            }
            newBlock.normalize();
            if (dom2.isEmpty(newBlock)) {
              dom2.remove(newBlock);
              insertNewBlockAfter();
            } else {
              setForcedBlockAttrs(editor, newBlock);
              NewLineUtils.moveToCaretPosition(editor, newBlock);
            }
          }
          dom2.setAttrib(newBlock, "id", "");
          editor.fire("NewBlock", { newBlock });
        };
        var InsertBlock = { insert: insert$2 };
        var matchesSelector = function(editor, selector) {
          return NewLineUtils.getParentBlock(editor).filter(function(parentBlock) {
            return selector.length > 0 && is$1(Element.fromDom(parentBlock), selector);
          }).isSome();
        };
        var shouldInsertBr = function(editor) {
          return matchesSelector(editor, Settings.getBrNewLineSelector(editor));
        };
        var shouldBlockNewLine = function(editor) {
          return matchesSelector(editor, Settings.getNoNewLineSelector(editor));
        };
        var ContextSelectors = {
          shouldInsertBr,
          shouldBlockNewLine
        };
        var newLineAction = Adt.generate([
          { br: [] },
          { block: [] },
          { none: [] }
        ]);
        var shouldBlockNewLine$1 = function(editor, shiftKey) {
          return ContextSelectors.shouldBlockNewLine(editor);
        };
        var isBrMode = function(requiredState) {
          return function(editor, shiftKey) {
            var brMode = Settings.getForcedRootBlock(editor) === "";
            return brMode === requiredState;
          };
        };
        var inListBlock = function(requiredState) {
          return function(editor, shiftKey) {
            return NewLineUtils.isListItemParentBlock(editor) === requiredState;
          };
        };
        var inBlock = function(blockName, requiredState) {
          return function(editor, shiftKey) {
            var state = NewLineUtils.getParentBlockName(editor) === blockName.toUpperCase();
            return state === requiredState;
          };
        };
        var inPreBlock = function(requiredState) {
          return inBlock("pre", requiredState);
        };
        var inSummaryBlock = function() {
          return inBlock("summary", true);
        };
        var shouldPutBrInPre$1 = function(requiredState) {
          return function(editor, shiftKey) {
            return Settings.shouldPutBrInPre(editor) === requiredState;
          };
        };
        var inBrContext = function(editor, shiftKey) {
          return ContextSelectors.shouldInsertBr(editor);
        };
        var hasShiftKey = function(editor, shiftKey) {
          return shiftKey;
        };
        var canInsertIntoEditableRoot = function(editor) {
          var forcedRootBlock = Settings.getForcedRootBlock(editor);
          var rootEditable = NewLineUtils.getEditableRoot(editor.dom, editor.selection.getStart());
          return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : "P");
        };
        var match$2 = function(predicates, action2) {
          return function(editor, shiftKey) {
            var isMatch = foldl(predicates, function(res, p) {
              return res && p(editor, shiftKey);
            }, true);
            return isMatch ? Option.some(action2) : Option.none();
          };
        };
        var getAction$1 = function(editor, evt) {
          return LazyEvaluator.evaluateUntil([
            match$2([shouldBlockNewLine$1], newLineAction.none()),
            match$2([inSummaryBlock()], newLineAction.br()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(false),
              hasShiftKey
            ], newLineAction.br()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(false)
            ], newLineAction.block()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(true),
              hasShiftKey
            ], newLineAction.block()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(true)
            ], newLineAction.br()),
            match$2([
              inListBlock(true),
              hasShiftKey
            ], newLineAction.br()),
            match$2([inListBlock(true)], newLineAction.block()),
            match$2([
              isBrMode(true),
              hasShiftKey,
              canInsertIntoEditableRoot
            ], newLineAction.block()),
            match$2([isBrMode(true)], newLineAction.br()),
            match$2([inBrContext], newLineAction.br()),
            match$2([
              isBrMode(false),
              hasShiftKey
            ], newLineAction.br()),
            match$2([canInsertIntoEditableRoot], newLineAction.block())
          ], [
            editor,
            evt.shiftKey
          ]).getOr(newLineAction.none());
        };
        var NewLineAction = { getAction: getAction$1 };
        var insert$3 = function(editor, evt) {
          NewLineAction.getAction(editor, evt).fold(function() {
            InsertBr.insert(editor, evt);
          }, function() {
            InsertBlock.insert(editor, evt);
          }, noop);
        };
        var InsertNewLine = { insert: insert$3 };
        var endTypingLevel = function(undoManager) {
          if (undoManager.typing) {
            undoManager.typing = false;
            undoManager.add();
          }
        };
        var handleEnterKeyEvent = function(editor, event) {
          if (event.isDefaultPrevented()) {
            return;
          }
          event.preventDefault();
          endTypingLevel(editor.undoManager);
          editor.undoManager.transact(function() {
            if (editor.selection.isCollapsed() === false) {
              editor.execCommand("Delete");
            }
            InsertNewLine.insert(editor, event);
          });
        };
        var setup$9 = function(editor) {
          editor.on("keydown", function(event) {
            if (event.keyCode === VK.ENTER) {
              handleEnterKeyEvent(editor, event);
            }
          });
        };
        var EnterKey = { setup: setup$9 };
        var insertTextAtPosition = function(text, pos) {
          var container = pos.container();
          var offset = pos.offset();
          if (NodeType.isText(container)) {
            container.insertData(offset, text);
            return Option.some(CaretPosition(container, offset + text.length));
          } else {
            return getElementFromPosition(pos).map(function(elm) {
              var textNode = Element.fromText(text);
              if (pos.isAtEnd()) {
                after(elm, textNode);
              } else {
                before(elm, textNode);
              }
              return CaretPosition(textNode.dom(), text.length);
            });
          }
        };
        var insertNbspAtPosition = curry(insertTextAtPosition, "\xA0");
        var insertSpaceAtPosition = curry(insertTextAtPosition, " ");
        var navigateIgnoreEmptyTextNodes = function(forward, root, from2) {
          return CaretFinder.navigateIgnore(forward, root, from2, isEmptyText);
        };
        var getClosestBlock = function(root, pos) {
          return find(Parents.parentsAndSelf(Element.fromDom(pos.container()), root), isBlock);
        };
        var isAtBeforeAfterBlockBoundary = function(forward, root, pos) {
          return navigateIgnoreEmptyTextNodes(forward, root.dom(), pos).forall(function(newPos) {
            return getClosestBlock(root, pos).fold(function() {
              return isInSameBlock(newPos, pos, root.dom()) === false;
            }, function(fromBlock) {
              return isInSameBlock(newPos, pos, root.dom()) === false && contains$3(fromBlock, Element.fromDom(newPos.container()));
            });
          });
        };
        var isAtBlockBoundary = function(forward, root, pos) {
          return getClosestBlock(root, pos).fold(function() {
            return navigateIgnoreEmptyTextNodes(forward, root.dom(), pos).forall(function(newPos) {
              return isInSameBlock(newPos, pos, root.dom()) === false;
            });
          }, function(parent2) {
            return navigateIgnoreEmptyTextNodes(forward, parent2.dom(), pos).isNone();
          });
        };
        var isAtStartOfBlock = curry(isAtBlockBoundary, false);
        var isAtEndOfBlock = curry(isAtBlockBoundary, true);
        var isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
        var isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
        var nbsp = "\xA0";
        var isInMiddleOfText = function(pos) {
          return CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
        };
        var getClosestBlock$1 = function(root, pos) {
          var parentBlocks = filter(Parents.parentsAndSelf(Element.fromDom(pos.container()), root), isBlock);
          return head(parentBlocks).getOr(root);
        };
        var hasSpaceBefore = function(root, pos) {
          if (isInMiddleOfText(pos)) {
            return isAfterSpace(pos);
          } else {
            return isAfterSpace(pos) || CaretFinder.prevPosition(getClosestBlock$1(root, pos).dom(), pos).exists(isAfterSpace);
          }
        };
        var hasSpaceAfter = function(root, pos) {
          if (isInMiddleOfText(pos)) {
            return isBeforeSpace(pos);
          } else {
            return isBeforeSpace(pos) || CaretFinder.nextPosition(getClosestBlock$1(root, pos).dom(), pos).exists(isBeforeSpace);
          }
        };
        var isPreValue = function(value2) {
          return contains([
            "pre",
            "pre-wrap"
          ], value2);
        };
        var isInPre = function(pos) {
          return getElementFromPosition(pos).bind(function(elm) {
            return closest(elm, isElement);
          }).exists(function(elm) {
            return isPreValue(get$1(elm, "white-space"));
          });
        };
        var isAtBeginningOfBody = function(root, pos) {
          return CaretFinder.prevPosition(root.dom(), pos).isNone();
        };
        var isAtEndOfBody = function(root, pos) {
          return CaretFinder.nextPosition(root.dom(), pos).isNone();
        };
        var isAtLineBoundary = function(root, pos) {
          return isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr(root, pos);
        };
        var needsToHaveNbsp = function(root, pos) {
          if (isInPre(pos)) {
            return false;
          } else {
            return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
          }
        };
        var needsToBeNbspLeft = function(root, pos) {
          if (isInPre(pos)) {
            return false;
          } else {
            return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);
          }
        };
        var leanRight = function(pos) {
          var container = pos.container();
          var offset = pos.offset();
          if (NodeType.isText(container) && offset < container.data.length) {
            return CaretPosition(container, offset + 1);
          } else {
            return pos;
          }
        };
        var needsToBeNbspRight = function(root, pos) {
          var afterPos = leanRight(pos);
          if (isInPre(afterPos)) {
            return false;
          } else {
            return isAtEndOfBlock(root, afterPos) || isAfterBlock(root, afterPos) || isBeforeBr(root, afterPos) || hasSpaceAfter(root, afterPos);
          }
        };
        var needsToBeNbsp = function(root, pos) {
          return needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, pos);
        };
        var isNbspAt = function(text, offset) {
          return isNbsp(text.charAt(offset));
        };
        var hasNbsp = function(pos) {
          var container = pos.container();
          return NodeType.isText(container) && contains$2(container.data, nbsp);
        };
        var normalizeNbspMiddle = function(text) {
          var chars = text.split("");
          return map(chars, function(chr, i2) {
            if (isNbsp(chr) && i2 > 0 && i2 < chars.length - 1 && isContent$1(chars[i2 - 1]) && isContent$1(chars[i2 + 1])) {
              return " ";
            } else {
              return chr;
            }
          }).join("");
        };
        var normalizeNbspAtStart = function(root, node2) {
          var text = node2.data;
          var firstPos = CaretPosition(node2, 0);
          if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {
            node2.data = " " + text.slice(1);
            return true;
          } else {
            return false;
          }
        };
        var normalizeNbspInMiddleOfTextNode = function(node2) {
          var text = node2.data;
          var newText = normalizeNbspMiddle(text);
          if (newText !== text) {
            node2.data = newText;
            return true;
          } else {
            return false;
          }
        };
        var normalizeNbspAtEnd = function(root, node2) {
          var text = node2.data;
          var lastPos = CaretPosition(node2, text.length - 1);
          if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {
            node2.data = text.slice(0, -1) + " ";
            return true;
          } else {
            return false;
          }
        };
        var normalizeNbsps = function(root, pos) {
          return Option.some(pos).filter(hasNbsp).bind(function(pos2) {
            var container = pos2.container();
            var normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);
            return normalized ? Option.some(pos2) : Option.none();
          });
        };
        var normalizeNbspsInEditor = function(editor) {
          var root = Element.fromDom(editor.getBody());
          if (editor.selection.isCollapsed()) {
            normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function(pos) {
              editor.selection.setRng(pos.toRange());
            });
          }
        };
        var locationToCaretPosition = function(root) {
          return function(location) {
            return location.fold(function(element) {
              return CaretFinder.prevPosition(root.dom(), CaretPosition$1.before(element));
            }, function(element) {
              return CaretFinder.firstPositionIn(element);
            }, function(element) {
              return CaretFinder.lastPositionIn(element);
            }, function(element) {
              return CaretFinder.nextPosition(root.dom(), CaretPosition$1.after(element));
            });
          };
        };
        var insertInlineBoundarySpaceOrNbsp = function(root, pos) {
          return function(checkPos) {
            return needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
          };
        };
        var setSelection$1 = function(editor) {
          return function(pos) {
            editor.selection.setRng(pos.toRange());
            editor.nodeChanged();
            return true;
          };
        };
        var insertSpaceOrNbspAtSelection = function(editor) {
          var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          var root = Element.fromDom(editor.getBody());
          if (editor.selection.isCollapsed()) {
            var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
            var caretPosition = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            return BoundaryLocation.readLocation(isInlineTarget2, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).bind(insertInlineBoundarySpaceOrNbsp(root, pos)).exists(setSelection$1(editor));
          } else {
            return false;
          }
        };
        var executeKeydownOverride$2 = function(editor, evt) {
          MatchKeys.execute([{
            keyCode: VK.SPACEBAR,
            action: MatchKeys.action(insertSpaceOrNbspAtSelection, editor)
          }], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var setup$a = function(editor) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride$2(editor, evt);
            }
          });
        };
        var SpaceKey = { setup: setup$a };
        var findBlockCaretContainer = function(editor) {
          return descendant(Element.fromDom(editor.getBody()), "*[data-mce-caret]").fold(constant(null), function(elm) {
            return elm.dom();
          });
        };
        var removeIeControlRect = function(editor) {
          editor.selection.setRng(editor.selection.getRng());
        };
        var showBlockCaretContainer = function(editor, blockCaretContainer) {
          if (blockCaretContainer.hasAttribute("data-mce-caret")) {
            showCaretContainerBlock(blockCaretContainer);
            removeIeControlRect(editor);
            editor.selection.scrollIntoView(blockCaretContainer);
          }
        };
        var handleBlockContainer = function(editor, e) {
          var blockCaretContainer = findBlockCaretContainer(editor);
          if (!blockCaretContainer) {
            return;
          }
          if (e.type === "compositionstart") {
            e.preventDefault();
            e.stopPropagation();
            showBlockCaretContainer(editor, blockCaretContainer);
            return;
          }
          if (hasContent(blockCaretContainer)) {
            showBlockCaretContainer(editor, blockCaretContainer);
            editor.undoManager.add();
          }
        };
        var setup$b = function(editor) {
          editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
        };
        var CaretContainerInput = { setup: setup$b };
        var browser$4 = PlatformDetection$1.detect().browser;
        var setupIeInput = function(editor) {
          var keypressThrotter = first(function() {
            if (!editor.composing) {
              normalizeNbspsInEditor(editor);
            }
          }, 0);
          if (browser$4.isIE()) {
            editor.on("keypress", function(e) {
              keypressThrotter.throttle();
            });
            editor.on("remove", function(e) {
              keypressThrotter.cancel();
            });
          }
        };
        var setup$c = function(editor) {
          setupIeInput(editor);
          editor.on("input", function(e) {
            if (e.isComposing === false) {
              normalizeNbspsInEditor(editor);
            }
          });
        };
        var executeKeydownOverride$3 = function(editor, evt) {
          MatchKeys.execute([
            {
              keyCode: VK.END,
              action: moveToLineEndPoint(editor, true)
            },
            {
              keyCode: VK.HOME,
              action: moveToLineEndPoint(editor, false)
            }
          ], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var setup$d = function(editor) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride$3(editor, evt);
            }
          });
        };
        var HomeEndKeys = { setup: setup$d };
        var setup$e = function(editor) {
          var caret = BoundarySelection.setupSelectedState(editor);
          CaretContainerInput.setup(editor);
          ArrowKeys.setup(editor, caret);
          DeleteBackspaceKeys.setup(editor, caret);
          EnterKey.setup(editor);
          SpaceKey.setup(editor);
          setup$c(editor);
          HomeEndKeys.setup(editor);
        };
        var KeyboardOverrides = { setup: setup$e };
        function Quirks(editor) {
          var each2 = Tools.each;
          var BACKSPACE = VK.BACKSPACE, DELETE2 = VK.DELETE, dom2 = editor.dom, selection = editor.selection, settings = editor.settings, parser = editor.parser;
          var isGecko = Env.gecko, isIE2 = Env.ie, isWebKit = Env.webkit;
          var mceInternalUrlPrefix = "data:text/mce-internal,";
          var mceInternalDataType = isIE2 ? "Text" : "URL";
          var setEditorCommandState2 = function(cmd, state) {
            try {
              editor.getDoc().execCommand(cmd, false, state);
            } catch (ex) {
            }
          };
          var isDefaultPrevented = function(e) {
            return e.isDefaultPrevented();
          };
          var setMceInternalContent = function(e) {
            var selectionHtml, internalContent;
            if (e.dataTransfer) {
              if (editor.selection.isCollapsed() && e.target.tagName === "IMG") {
                selection.select(e.target);
              }
              selectionHtml = editor.selection.getContent();
              if (selectionHtml.length > 0) {
                internalContent = mceInternalUrlPrefix + escape(editor.id) + "," + escape(selectionHtml);
                e.dataTransfer.setData(mceInternalDataType, internalContent);
              }
            }
          };
          var getMceInternalContent = function(e) {
            var internalContent;
            if (e.dataTransfer) {
              internalContent = e.dataTransfer.getData(mceInternalDataType);
              if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
                internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(",");
                return {
                  id: unescape(internalContent[0]),
                  html: unescape(internalContent[1])
                };
              }
            }
            return null;
          };
          var insertClipboardContents = function(content, internal) {
            if (editor.queryCommandSupported("mceInsertClipboardContent")) {
              editor.execCommand("mceInsertClipboardContent", false, {
                content,
                internal
              });
            } else {
              editor.execCommand("mceInsertContent", false, content);
            }
          };
          var emptyEditorWhenDeleting = function() {
            var serializeRng = function(rng) {
              var body = dom2.create("body");
              var contents = rng.cloneContents();
              body.appendChild(contents);
              return selection.serializer.serialize(body, { format: "html" });
            };
            var allContentsSelected = function(rng) {
              var selection2 = serializeRng(rng);
              var allRng = dom2.createRng();
              allRng.selectNode(editor.getBody());
              var allSelection = serializeRng(allRng);
              return selection2 === allSelection;
            };
            editor.on("keydown", function(e) {
              var keyCode = e.keyCode;
              var isCollapsed, body;
              if (!isDefaultPrevented(e) && (keyCode === DELETE2 || keyCode === BACKSPACE)) {
                isCollapsed = editor.selection.isCollapsed();
                body = editor.getBody();
                if (isCollapsed && !dom2.isEmpty(body)) {
                  return;
                }
                if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
                  return;
                }
                e.preventDefault();
                editor.setContent("");
                if (body.firstChild && dom2.isBlock(body.firstChild)) {
                  editor.selection.setCursorLocation(body.firstChild, 0);
                } else {
                  editor.selection.setCursorLocation(body, 0);
                }
                editor.nodeChanged();
              }
            });
          };
          var selectAll = function() {
            editor.shortcuts.add("meta+a", null, "SelectAll");
          };
          var inputMethodFocus = function() {
            if (!editor.settings.content_editable) {
              dom2.bind(editor.getDoc(), "mousedown mouseup", function(e) {
                var rng;
                if (e.target === editor.getDoc().documentElement) {
                  rng = selection.getRng();
                  editor.getBody().focus();
                  if (e.type === "mousedown") {
                    if (isCaretContainer(rng.startContainer)) {
                      return;
                    }
                    selection.placeCaretAt(e.clientX, e.clientY);
                  } else {
                    selection.setRng(rng);
                  }
                }
              });
            }
          };
          var removeHrOnBackspace = function() {
            editor.on("keydown", function(e) {
              if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                if (!editor.getBody().getElementsByTagName("hr").length) {
                  return;
                }
                if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                  var node2 = selection.getNode();
                  var previousSibling = node2.previousSibling;
                  if (node2.nodeName === "HR") {
                    dom2.remove(node2);
                    e.preventDefault();
                    return;
                  }
                  if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
                    dom2.remove(previousSibling);
                    e.preventDefault();
                  }
                }
              }
            });
          };
          var focusBody2 = function() {
            if (!domGlobals.Range.prototype.getClientRects) {
              editor.on("mousedown", function(e) {
                if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
                  var body_1 = editor.getBody();
                  body_1.blur();
                  Delay.setEditorTimeout(editor, function() {
                    body_1.focus();
                  });
                }
              });
            }
          };
          var selectControlElements = function() {
            editor.on("click", function(e) {
              var target = e.target;
              if (/^(IMG|HR)$/.test(target.nodeName) && dom2.getContentEditableParent(target) !== "false") {
                e.preventDefault();
                editor.selection.select(target);
                editor.nodeChanged();
              }
              if (target.nodeName === "A" && dom2.hasClass(target, "mce-item-anchor")) {
                e.preventDefault();
                selection.select(target);
              }
            });
          };
          var removeStylesWhenDeletingAcrossBlockElements = function() {
            var getAttributeApplyFunction = function() {
              var template = dom2.getAttribs(selection.getStart().cloneNode(false));
              return function() {
                var target = selection.getStart();
                if (target !== editor.getBody()) {
                  dom2.setAttrib(target, "style", null);
                  each2(template, function(attr) {
                    target.setAttributeNode(attr.cloneNode(true));
                  });
                }
              };
            };
            var isSelectionAcrossElements = function() {
              return !selection.isCollapsed() && dom2.getParent(selection.getStart(), dom2.isBlock) !== dom2.getParent(selection.getEnd(), dom2.isBlock);
            };
            editor.on("keypress", function(e) {
              var applyAttributes2;
              if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
                applyAttributes2 = getAttributeApplyFunction();
                editor.getDoc().execCommand("delete", false, null);
                applyAttributes2();
                e.preventDefault();
                return false;
              }
            });
            dom2.bind(editor.getDoc(), "cut", function(e) {
              var applyAttributes2;
              if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
                applyAttributes2 = getAttributeApplyFunction();
                Delay.setEditorTimeout(editor, function() {
                  applyAttributes2();
                });
              }
            });
          };
          var disableBackspaceIntoATable = function() {
            editor.on("keydown", function(e) {
              if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                  var previousSibling = selection.getNode().previousSibling;
                  if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
                    e.preventDefault();
                    return false;
                  }
                }
              }
            });
          };
          var removeBlockQuoteOnBackSpace = function() {
            editor.on("keydown", function(e) {
              var rng, container, offset, root, parent2;
              if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
                return;
              }
              rng = selection.getRng();
              container = rng.startContainer;
              offset = rng.startOffset;
              root = dom2.getRoot();
              parent2 = container;
              if (!rng.collapsed || offset !== 0) {
                return;
              }
              while (parent2 && parent2.parentNode && parent2.parentNode.firstChild === parent2 && parent2.parentNode !== root) {
                parent2 = parent2.parentNode;
              }
              if (parent2.tagName === "BLOCKQUOTE") {
                editor.formatter.toggle("blockquote", null, parent2);
                rng = dom2.createRng();
                rng.setStart(container, 0);
                rng.setEnd(container, 0);
                selection.setRng(rng);
              }
            });
          };
          var setGeckoEditingOptions = function() {
            var setOpts = function() {
              setEditorCommandState2("StyleWithCSS", false);
              setEditorCommandState2("enableInlineTableEditing", false);
              if (!settings.object_resizing) {
                setEditorCommandState2("enableObjectResizing", false);
              }
            };
            if (!settings.readonly) {
              editor.on("BeforeExecCommand MouseDown", setOpts);
            }
          };
          var addBrAfterLastLinks = function() {
            var fixLinks = function() {
              each2(dom2.select("a"), function(node2) {
                var parentNode = node2.parentNode;
                var root = dom2.getRoot();
                if (parentNode.lastChild === node2) {
                  while (parentNode && !dom2.isBlock(parentNode)) {
                    if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
                      return;
                    }
                    parentNode = parentNode.parentNode;
                  }
                  dom2.add(parentNode, "br", { "data-mce-bogus": 1 });
                }
              });
            };
            editor.on("SetContent ExecCommand", function(e) {
              if (e.type === "setcontent" || e.command === "mceInsertLink") {
                fixLinks();
              }
            });
          };
          var setDefaultBlockType = function() {
            if (settings.forced_root_block) {
              editor.on("init", function() {
                setEditorCommandState2("DefaultParagraphSeparator", settings.forced_root_block);
              });
            }
          };
          var normalizeSelection2 = function() {
            editor.on("keyup focusin mouseup", function(e) {
              if (!VK.modifierPressed(e)) {
                selection.normalize();
              }
            }, true);
          };
          var showBrokenImageIcon = function() {
            editor.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
          };
          var restoreFocusOnKeyDown = function() {
            if (!editor.inline) {
              editor.on("keydown", function() {
                if (domGlobals.document.activeElement === domGlobals.document.body) {
                  editor.getWin().focus();
                }
              });
            }
          };
          var bodyHeight = function() {
            if (!editor.inline) {
              editor.contentStyles.push("body {min-height: 150px}");
              editor.on("click", function(e) {
                var rng;
                if (e.target.nodeName === "HTML") {
                  if (Env.ie > 11) {
                    editor.getBody().focus();
                    return;
                  }
                  rng = editor.selection.getRng();
                  editor.getBody().focus();
                  editor.selection.setRng(rng);
                  editor.selection.normalize();
                  editor.nodeChanged();
                }
              });
            }
          };
          var blockCmdArrowNavigation = function() {
            if (Env.mac) {
              editor.on("keydown", function(e) {
                if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
                  e.preventDefault();
                  editor.selection.getSel().modify("move", e.keyCode === 37 ? "backward" : "forward", "lineboundary");
                }
              });
            }
          };
          var disableAutoUrlDetect = function() {
            setEditorCommandState2("AutoUrlDetect", false);
          };
          var tapLinksAndImages = function() {
            editor.on("click", function(e) {
              var elm = e.target;
              do {
                if (elm.tagName === "A") {
                  e.preventDefault();
                  return;
                }
              } while (elm = elm.parentNode);
            });
            editor.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
          };
          var blockFormSubmitInsideEditor = function() {
            editor.on("init", function() {
              editor.dom.bind(editor.getBody(), "submit", function(e) {
                e.preventDefault();
              });
            });
          };
          var removeAppleInterchangeBrs = function() {
            parser.addNodeFilter("br", function(nodes) {
              var i2 = nodes.length;
              while (i2--) {
                if (nodes[i2].attr("class") === "Apple-interchange-newline") {
                  nodes[i2].remove();
                }
              }
            });
          };
          var ieInternalDragAndDrop = function() {
            editor.on("dragstart", function(e) {
              setMceInternalContent(e);
            });
            editor.on("drop", function(e) {
              if (!isDefaultPrevented(e)) {
                var internalContent = getMceInternalContent(e);
                if (internalContent && internalContent.id !== editor.id) {
                  e.preventDefault();
                  var rng = CaretRangeFromPoint.fromPoint(e.x, e.y, editor.getDoc());
                  selection.setRng(rng);
                  insertClipboardContents(internalContent.html, true);
                }
              }
            });
          };
          var refreshContentEditable = function() {
          };
          var isHidden = function() {
            var sel;
            if (!isGecko || editor.removed) {
              return 0;
            }
            sel = editor.selection.getSel();
            return !sel || !sel.rangeCount || sel.rangeCount === 0;
          };
          removeBlockQuoteOnBackSpace();
          emptyEditorWhenDeleting();
          if (!Env.windowsPhone) {
            normalizeSelection2();
          }
          if (isWebKit) {
            inputMethodFocus();
            selectControlElements();
            setDefaultBlockType();
            blockFormSubmitInsideEditor();
            disableBackspaceIntoATable();
            removeAppleInterchangeBrs();
            if (Env.iOS) {
              restoreFocusOnKeyDown();
              bodyHeight();
              tapLinksAndImages();
            } else {
              selectAll();
            }
          }
          if (Env.ie >= 11) {
            bodyHeight();
            disableBackspaceIntoATable();
          }
          if (Env.ie) {
            selectAll();
            disableAutoUrlDetect();
            ieInternalDragAndDrop();
          }
          if (isGecko) {
            removeHrOnBackspace();
            focusBody2();
            removeStylesWhenDeletingAcrossBlockElements();
            setGeckoEditingOptions();
            addBrAfterLastLinks();
            showBrokenImageIcon();
            blockCmdArrowNavigation();
            disableBackspaceIntoATable();
          }
          return {
            refreshContentEditable,
            isHidden
          };
        }
        var isTextBlockNode = function(node2) {
          return NodeType.isElement(node2) && isTextBlock(Element.fromDom(node2));
        };
        var normalizeSelection$1 = function(editor) {
          var rng = editor.selection.getRng();
          var startPos = CaretPosition.fromRangeStart(rng);
          var endPos = CaretPosition.fromRangeEnd(rng);
          if (CaretPosition.isElementPosition(startPos)) {
            var container = startPos.container();
            if (isTextBlockNode(container)) {
              CaretFinder.firstPositionIn(container).each(function(pos) {
                return rng.setStart(pos.container(), pos.offset());
              });
            }
          }
          if (CaretPosition.isElementPosition(endPos)) {
            var container = startPos.container();
            if (isTextBlockNode(container)) {
              CaretFinder.lastPositionIn(container).each(function(pos) {
                return rng.setEnd(pos.container(), pos.offset());
              });
            }
          }
          editor.selection.setRng(RangeNormalizer.normalize(rng));
        };
        var setup$f = function(editor) {
          editor.on("click", function(e) {
            if (e.detail >= 3) {
              normalizeSelection$1(editor);
            }
          });
        };
        var preventSummaryToggle = function(editor) {
          editor.on("click", function(e) {
            if (editor.dom.getParent(e.target, "details")) {
              e.preventDefault();
            }
          });
        };
        var filterDetails = function(editor) {
          editor.parser.addNodeFilter("details", function(elms) {
            each(elms, function(details) {
              details.attr("data-mce-open", details.attr("open"));
              details.attr("open", "open");
            });
          });
          editor.serializer.addNodeFilter("details", function(elms) {
            each(elms, function(details) {
              var open = details.attr("data-mce-open");
              details.attr("open", isString(open) ? open : null);
              details.attr("data-mce-open", null);
            });
          });
        };
        var setup$g = function(editor) {
          preventSummaryToggle(editor);
          filterDetails(editor);
        };
        var DOM$2 = DOMUtils$1.DOM;
        var appendStyle = function(editor, text) {
          var head2 = Element.fromDom(editor.getDoc().head);
          var tag = Element.fromTag("style");
          set(tag, "type", "text/css");
          append(tag, Element.fromText(text));
          append(head2, tag);
        };
        var createParser = function(editor) {
          var parser = DomParser(editor.settings, editor.schema);
          parser.addAttributeFilter("src,href,style,tabindex", function(nodes, name2) {
            var i2 = nodes.length, node2;
            var dom2 = editor.dom;
            var value2, internalName;
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.attr(name2);
              internalName = "data-mce-" + name2;
              if (!node2.attributes.map[internalName]) {
                if (value2.indexOf("data:") === 0 || value2.indexOf("blob:") === 0) {
                  continue;
                }
                if (name2 === "style") {
                  value2 = dom2.serializeStyle(dom2.parseStyle(value2), node2.name);
                  if (!value2.length) {
                    value2 = null;
                  }
                  node2.attr(internalName, value2);
                  node2.attr(name2, value2);
                } else if (name2 === "tabindex") {
                  node2.attr(internalName, value2);
                  node2.attr(name2, null);
                } else {
                  node2.attr(internalName, editor.convertURL(value2, name2, node2.name));
                }
              }
            }
          });
          parser.addNodeFilter("script", function(nodes) {
            var i2 = nodes.length, node2, type2;
            while (i2--) {
              node2 = nodes[i2];
              type2 = node2.attr("type") || "no/type";
              if (type2.indexOf("mce-") !== 0) {
                node2.attr("type", "mce-" + type2);
              }
            }
          });
          parser.addNodeFilter("#cdata", function(nodes) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              node2.type = 8;
              node2.name = "#comment";
              node2.value = "[CDATA[" + node2.value + "]]";
            }
          });
          parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", function(nodes) {
            var i2 = nodes.length, node2;
            var nonEmptyElements = editor.schema.getNonEmptyElements();
            while (i2--) {
              node2 = nodes[i2];
              if (node2.isEmpty(nonEmptyElements) && node2.getAll("br").length === 0) {
                node2.append(new Node$1("br", 1)).shortEnded = true;
              }
            }
          });
          return parser;
        };
        var autoFocus = function(editor) {
          if (editor.settings.auto_focus) {
            Delay.setEditorTimeout(editor, function() {
              var focusEditor2;
              if (editor.settings.auto_focus === true) {
                focusEditor2 = editor;
              } else {
                focusEditor2 = editor.editorManager.get(editor.settings.auto_focus);
              }
              if (!focusEditor2.destroyed) {
                focusEditor2.focus();
              }
            }, 100);
          }
        };
        var initEditor = function(editor) {
          editor.bindPendingEventDelegates();
          editor.initialized = true;
          editor.fire("init");
          editor.focus(true);
          editor.nodeChanged({ initial: true });
          editor.execCallback("init_instance_callback", editor);
          autoFocus(editor);
        };
        var getStyleSheetLoader = function(editor) {
          return editor.inline ? DOM$2.styleSheetLoader : editor.dom.styleSheetLoader;
        };
        var initContentBody = function(editor, skipWrite) {
          var settings = editor.settings;
          var targetElm = editor.getElement();
          var doc2 = editor.getDoc(), body, contentCssText;
          if (!settings.inline) {
            editor.getElement().style.visibility = editor.orgVisibility;
          }
          if (!skipWrite && !settings.content_editable) {
            doc2.open();
            doc2.write(editor.iframeHTML);
            doc2.close();
          }
          if (settings.content_editable) {
            editor.on("remove", function() {
              var bodyEl = this.getBody();
              DOM$2.removeClass(bodyEl, "mce-content-body");
              DOM$2.removeClass(bodyEl, "mce-edit-focus");
              DOM$2.setAttrib(bodyEl, "contentEditable", null);
            });
            DOM$2.addClass(targetElm, "mce-content-body");
            editor.contentDocument = doc2 = settings.content_document || domGlobals.document;
            editor.contentWindow = settings.content_window || domGlobals.window;
            editor.bodyElement = targetElm;
            settings.content_document = settings.content_window = null;
            settings.root_name = targetElm.nodeName.toLowerCase();
          }
          body = editor.getBody();
          body.disabled = true;
          editor.readonly = settings.readonly;
          if (!editor.readonly) {
            if (editor.inline && DOM$2.getStyle(body, "position", true) === "static") {
              body.style.position = "relative";
            }
            body.contentEditable = editor.getParam("content_editable_state", true);
          }
          body.disabled = false;
          editor.editorUpload = EditorUpload(editor);
          editor.schema = Schema(settings);
          editor.dom = DOMUtils$1(doc2, {
            keep_values: true,
            url_converter: editor.convertURL,
            url_converter_scope: editor,
            hex_colors: settings.force_hex_style_colors,
            class_filter: settings.class_filter,
            update_styles: true,
            root_element: editor.inline ? editor.getBody() : null,
            collect: settings.content_editable,
            schema: editor.schema,
            contentCssCors: Settings.shouldUseContentCssCors(editor),
            onSetAttrib: function(e) {
              editor.fire("SetAttrib", e);
            }
          });
          editor.parser = createParser(editor);
          editor.serializer = DomSerializer$1(settings, editor);
          editor.selection = Selection$1(editor.dom, editor.getWin(), editor.serializer, editor);
          editor.annotator = Annotator(editor);
          editor.formatter = Formatter(editor);
          editor.undoManager = UndoManager(editor);
          editor._nodeChangeDispatcher = new NodeChange(editor);
          editor._selectionOverrides = SelectionOverrides(editor);
          setup$g(editor);
          setup$f(editor);
          KeyboardOverrides.setup(editor);
          ForceBlocks.setup(editor);
          editor.fire("PreInit");
          if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
            doc2.body.spellcheck = false;
            DOM$2.setAttrib(body, "spellcheck", "false");
          }
          editor.quirks = Quirks(editor);
          editor.fire("PostRender");
          if (settings.directionality) {
            body.dir = settings.directionality;
          }
          if (settings.nowrap) {
            body.style.whiteSpace = "nowrap";
          }
          if (settings.protect) {
            editor.on("BeforeSetContent", function(e) {
              Tools.each(settings.protect, function(pattern) {
                e.content = e.content.replace(pattern, function(str) {
                  return "<!--mce:protected " + escape(str) + "-->";
                });
              });
            });
          }
          editor.on("SetContent", function() {
            editor.addVisual(editor.getBody());
          });
          editor.load({
            initial: true,
            format: "html"
          });
          editor.startContent = editor.getContent({ format: "raw" });
          editor.on("compositionstart compositionend", function(e) {
            editor.composing = e.type === "compositionstart";
          });
          if (editor.contentStyles.length > 0) {
            contentCssText = "";
            Tools.each(editor.contentStyles, function(style) {
              contentCssText += style + "\r\n";
            });
            editor.dom.addStyle(contentCssText);
          }
          getStyleSheetLoader(editor).loadAll(editor.contentCSS, function(_) {
            initEditor(editor);
          }, function(urls) {
            initEditor(editor);
          });
          if (settings.content_style) {
            appendStyle(editor, settings.content_style);
          }
        };
        var InitContentBody = { initContentBody };
        var DOM$3 = DOMUtils$1.DOM;
        var relaxDomain = function(editor, ifr) {
          if (domGlobals.document.domain !== domGlobals.window.location.hostname && Env.ie && Env.ie < 12) {
            var bodyUuid = Uuid.uuid("mce");
            editor[bodyUuid] = function() {
              InitContentBody.initContentBody(editor);
            };
            var domainRelaxUrl = 'javascript:(function(){document.open();document.domain="' + domGlobals.document.domain + '";var ed = window.parent.tinymce.get("' + editor.id + '");document.write(ed.iframeHTML);document.close();ed.' + bodyUuid + "(true);})()";
            DOM$3.setAttrib(ifr, "src", domainRelaxUrl);
            return true;
          }
          return false;
        };
        var normalizeHeight = function(height) {
          var normalizedHeight = typeof height === "number" ? height + "px" : height;
          return normalizedHeight ? normalizedHeight : "";
        };
        var createIframeElement = function(id, title, height, customAttrs) {
          var iframe = Element.fromTag("iframe");
          setAll(iframe, customAttrs);
          setAll(iframe, {
            id: id + "_ifr",
            frameBorder: "0",
            allowTransparency: "true",
            title
          });
          setAll$1(iframe, {
            width: "100%",
            height: normalizeHeight(height),
            display: "block"
          });
          return iframe;
        };
        var getIframeHtml = function(editor) {
          var bodyId, bodyClass, iframeHTML;
          iframeHTML = Settings.getDocType(editor) + "<html><head>";
          if (Settings.getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
            iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
          }
          iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
          bodyId = Settings.getBodyId(editor);
          bodyClass = Settings.getBodyClass(editor);
          if (Settings.getContentSecurityPolicy(editor)) {
            iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + Settings.getContentSecurityPolicy(editor) + '" />';
          }
          iframeHTML += '</head><body id="' + bodyId + '" class="mce-content-body ' + bodyClass + '" data-id="' + editor.id + '"><br></body></html>';
          return iframeHTML;
        };
        var createIframe = function(editor, o) {
          var title = editor.editorManager.translate("Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help");
          var ifr = createIframeElement(editor.id, title, o.height, Settings.getIframeAttrs(editor)).dom();
          ifr.onload = function() {
            ifr.onload = null;
            editor.fire("load");
          };
          var isDomainRelaxed = relaxDomain(editor, ifr);
          editor.contentAreaContainer = o.iframeContainer;
          editor.iframeElement = ifr;
          editor.iframeHTML = getIframeHtml(editor);
          DOM$3.add(o.iframeContainer, ifr);
          return isDomainRelaxed;
        };
        var init$1 = function(editor, boxInfo) {
          var isDomainRelaxed = createIframe(editor, boxInfo);
          if (boxInfo.editorContainer) {
            DOM$3.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
            editor.hidden = DOM$3.isHidden(boxInfo.editorContainer);
          }
          editor.getElement().style.display = "none";
          DOM$3.setAttrib(editor.id, "aria-hidden", "true");
          if (!isDomainRelaxed) {
            InitContentBody.initContentBody(editor);
          }
        };
        var InitIframe = { init: init$1 };
        var DOM$4 = DOMUtils$1.DOM;
        var initPlugin = function(editor, initializedPlugins, plugin) {
          var Plugin = PluginManager$1.get(plugin);
          var pluginUrl = PluginManager$1.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, "");
          plugin = Tools.trim(plugin);
          if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
            Tools.each(PluginManager$1.dependencies(plugin), function(dep) {
              initPlugin(editor, initializedPlugins, dep);
            });
            if (editor.plugins[plugin]) {
              return;
            }
            try {
              var pluginInstance = new Plugin(editor, pluginUrl, editor.$);
              editor.plugins[plugin] = pluginInstance;
              if (pluginInstance.init) {
                pluginInstance.init(editor, pluginUrl);
                initializedPlugins.push(plugin);
              }
            } catch (e) {
              ErrorReporter.pluginInitError(editor, plugin, e);
            }
          }
        };
        var trimLegacyPrefix = function(name2) {
          return name2.replace(/^\-/, "");
        };
        var initPlugins = function(editor) {
          var initializedPlugins = [];
          Tools.each(editor.settings.plugins.split(/[ ,]/), function(name2) {
            initPlugin(editor, initializedPlugins, trimLegacyPrefix(name2));
          });
        };
        var initTheme = function(editor) {
          var Theme;
          var theme = editor.settings.theme;
          if (isString(theme)) {
            editor.settings.theme = trimLegacyPrefix(theme);
            Theme = ThemeManager.get(theme);
            editor.theme = new Theme(editor, ThemeManager.urls[theme]);
            if (editor.theme.init) {
              editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ""), editor.$);
            }
          } else {
            editor.theme = {};
          }
        };
        var renderFromLoadedTheme = function(editor) {
          var w, h, minHeight, re, info;
          var settings = editor.settings;
          var elm = editor.getElement();
          w = settings.width || DOM$4.getStyle(elm, "width") || "100%";
          h = settings.height || DOM$4.getStyle(elm, "height") || elm.offsetHeight;
          minHeight = settings.min_height || 100;
          re = /^[0-9\.]+(|px)$/i;
          if (re.test("" + w)) {
            w = Math.max(parseInt(w, 10), 100);
          }
          if (re.test("" + h)) {
            h = Math.max(parseInt(h, 10), minHeight);
          }
          info = editor.theme.renderUI({
            targetNode: elm,
            width: w,
            height: h,
            deltaWidth: settings.delta_width,
            deltaHeight: settings.delta_height
          });
          if (!settings.content_editable) {
            h = (info.iframeHeight || h) + (typeof h === "number" ? info.deltaHeight || 0 : "");
            if (h < minHeight) {
              h = minHeight;
            }
          }
          info.height = h;
          return info;
        };
        var renderFromThemeFunc = function(editor) {
          var info;
          var elm = editor.getElement();
          info = editor.settings.theme(editor, elm);
          if (info.editorContainer.nodeType) {
            info.editorContainer.id = info.editorContainer.id || editor.id + "_parent";
          }
          if (info.iframeContainer && info.iframeContainer.nodeType) {
            info.iframeContainer.id = info.iframeContainer.id || editor.id + "_iframecontainer";
          }
          info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
          return info;
        };
        var createThemeFalseResult = function(element) {
          return {
            editorContainer: element,
            iframeContainer: element
          };
        };
        var renderThemeFalseIframe = function(targetElement) {
          var iframeContainer = DOM$4.create("div");
          DOM$4.insertAfter(iframeContainer, targetElement);
          return createThemeFalseResult(iframeContainer);
        };
        var renderThemeFalse = function(editor) {
          var targetElement = editor.getElement();
          return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
        };
        var renderThemeUi = function(editor) {
          var settings = editor.settings, elm = editor.getElement();
          editor.orgDisplay = elm.style.display;
          if (isString(settings.theme)) {
            return renderFromLoadedTheme(editor);
          } else if (isFunction(settings.theme)) {
            return renderFromThemeFunc(editor);
          } else {
            return renderThemeFalse(editor);
          }
        };
        var init$2 = function(editor) {
          var settings = editor.settings;
          var elm = editor.getElement();
          var boxInfo;
          editor.rtl = settings.rtl_ui || editor.editorManager.i18n.rtl;
          editor.editorManager.i18n.setCode(settings.language);
          settings.aria_label = settings.aria_label || DOM$4.getAttrib(elm, "aria-label", editor.getLang("aria.rich_text_area"));
          editor.fire("ScriptsLoaded");
          initTheme(editor);
          initPlugins(editor);
          boxInfo = renderThemeUi(editor);
          editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;
          if (settings.content_css) {
            Tools.each(Tools.explode(settings.content_css), function(u) {
              editor.contentCSS.push(editor.documentBaseURI.toAbsolute(u));
            });
          }
          if (settings.content_editable) {
            return InitContentBody.initContentBody(editor);
          } else {
            return InitIframe.init(editor, boxInfo);
          }
        };
        var Init = { init: init$2 };
        var DOM$5 = DOMUtils$1.DOM;
        var hasSkipLoadPrefix = function(name2) {
          return name2.charAt(0) === "-";
        };
        var loadLanguage = function(scriptLoader, editor) {
          var settings = editor.settings;
          if (settings.language && settings.language !== "en" && !settings.language_url) {
            settings.language_url = editor.editorManager.baseURL + "/langs/" + settings.language + ".js";
          }
          if (settings.language_url && !editor.editorManager.i18n.data[settings.language]) {
            scriptLoader.add(settings.language_url);
          }
        };
        var loadTheme = function(scriptLoader, editor, suffix, callback) {
          var settings = editor.settings, theme = settings.theme;
          if (isString(theme)) {
            if (!hasSkipLoadPrefix(theme) && !ThemeManager.urls.hasOwnProperty(theme)) {
              var themeUrl = settings.theme_url;
              if (themeUrl) {
                ThemeManager.load(theme, editor.documentBaseURI.toAbsolute(themeUrl));
              } else {
                ThemeManager.load(theme, "themes/" + theme + "/theme" + suffix + ".js");
              }
            }
            scriptLoader.loadQueue(function() {
              ThemeManager.waitFor(theme, callback);
            });
          } else {
            callback();
          }
        };
        var loadPlugins = function(settings, suffix) {
          if (Tools.isArray(settings.plugins)) {
            settings.plugins = settings.plugins.join(" ");
          }
          Tools.each(settings.external_plugins, function(url2, name2) {
            PluginManager$1.load(name2, url2);
            settings.plugins += " " + name2;
          });
          Tools.each(settings.plugins.split(/[ ,]/), function(plugin) {
            plugin = Tools.trim(plugin);
            if (plugin && !PluginManager$1.urls[plugin]) {
              if (hasSkipLoadPrefix(plugin)) {
                plugin = plugin.substr(1, plugin.length);
                var dependencies = PluginManager$1.dependencies(plugin);
                Tools.each(dependencies, function(dep) {
                  var defaultSettings = {
                    prefix: "plugins/",
                    resource: dep,
                    suffix: "/plugin" + suffix + ".js"
                  };
                  dep = PluginManager$1.createUrl(defaultSettings, dep);
                  PluginManager$1.load(dep.resource, dep);
                });
              } else {
                PluginManager$1.load(plugin, {
                  prefix: "plugins/",
                  resource: plugin,
                  suffix: "/plugin" + suffix + ".js"
                });
              }
            }
          });
        };
        var loadScripts = function(editor, suffix) {
          var scriptLoader = ScriptLoader.ScriptLoader;
          loadTheme(scriptLoader, editor, suffix, function() {
            loadLanguage(scriptLoader, editor);
            loadPlugins(editor.settings, suffix);
            scriptLoader.loadQueue(function() {
              if (!editor.removed) {
                Init.init(editor);
              }
            }, editor, function(urls) {
              ErrorReporter.pluginLoadError(editor, urls[0]);
              if (!editor.removed) {
                Init.init(editor);
              }
            });
          });
        };
        var render = function(editor) {
          var settings = editor.settings, id = editor.id;
          var readyHandler = function() {
            DOM$5.unbind(domGlobals.window, "ready", readyHandler);
            editor.render();
          };
          if (!EventUtils.Event.domLoaded) {
            DOM$5.bind(domGlobals.window, "ready", readyHandler);
            return;
          }
          if (!editor.getElement()) {
            return;
          }
          if (!Env.contentEditable) {
            return;
          }
          if (!settings.inline) {
            editor.orgVisibility = editor.getElement().style.visibility;
            editor.getElement().style.visibility = "hidden";
          } else {
            editor.inline = true;
          }
          var form = editor.getElement().form || DOM$5.getParent(id, "form");
          if (form) {
            editor.formElement = form;
            if (settings.hidden_input && !/TEXTAREA|INPUT/i.test(editor.getElement().nodeName)) {
              DOM$5.insertAfter(DOM$5.create("input", {
                type: "hidden",
                name: id
              }), id);
              editor.hasHiddenInput = true;
            }
            editor.formEventDelegate = function(e) {
              editor.fire(e.type, e);
            };
            DOM$5.bind(form, "submit reset", editor.formEventDelegate);
            editor.on("reset", function() {
              editor.setContent(editor.startContent, { format: "raw" });
            });
            if (settings.submit_patch && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
              form._mceOldSubmit = form.submit;
              form.submit = function() {
                editor.editorManager.triggerSave();
                editor.setDirty(false);
                return form._mceOldSubmit(form);
              };
            }
          }
          editor.windowManager = WindowManager(editor);
          editor.notificationManager = NotificationManager(editor);
          if (settings.encoding === "xml") {
            editor.on("GetContent", function(e) {
              if (e.save) {
                e.content = DOM$5.encode(e.content);
              }
            });
          }
          if (settings.add_form_submit_trigger) {
            editor.on("submit", function() {
              if (editor.initialized) {
                editor.save();
              }
            });
          }
          if (settings.add_unload_trigger) {
            editor._beforeUnload = function() {
              if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
                editor.save({
                  format: "raw",
                  no_events: true,
                  set_dirty: false
                });
              }
            };
            editor.editorManager.on("BeforeUnload", editor._beforeUnload);
          }
          editor.editorManager.add(editor);
          loadScripts(editor, editor.suffix);
        };
        var Render = { render };
        var add$4 = function(editor, name2, settings) {
          var sidebars = editor.sidebars ? editor.sidebars : [];
          sidebars.push({
            name: name2,
            settings
          });
          editor.sidebars = sidebars;
        };
        var Sidebar = { add: add$4 };
        var each$k = Tools.each, trim$4 = Tools.trim;
        var queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
        var DEFAULT_PORTS = {
          ftp: 21,
          http: 80,
          https: 443,
          mailto: 25
        };
        var URI = function(url2, settings) {
          var self2 = this;
          var baseUri, baseUrl;
          url2 = trim$4(url2);
          settings = self2.settings = settings || {};
          baseUri = settings.base_uri;
          if (/^([\w\-]+):([^\/]{2})/i.test(url2) || /^\s*#/.test(url2)) {
            self2.source = url2;
            return;
          }
          var isProtocolRelative = url2.indexOf("//") === 0;
          if (url2.indexOf("/") === 0 && !isProtocolRelative) {
            url2 = (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url2;
          }
          if (!/^[\w\-]*:?\/\//.test(url2)) {
            baseUrl = settings.base_uri ? settings.base_uri.path : new URI(domGlobals.document.location.href).directory;
            if (settings.base_uri.protocol == "") {
              url2 = "//mce_host" + self2.toAbsPath(baseUrl, url2);
            } else {
              url2 = /([^#?]*)([#?]?.*)/.exec(url2);
              url2 = (baseUri && baseUri.protocol || "http") + "://mce_host" + self2.toAbsPath(baseUrl, url2[1]) + url2[2];
            }
          }
          url2 = url2.replace(/@@/g, "(mce_at)");
          url2 = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url2);
          each$k(queryParts, function(v, i2) {
            var part = url2[i2];
            if (part) {
              part = part.replace(/\(mce_at\)/g, "@@");
            }
            self2[v] = part;
          });
          if (baseUri) {
            if (!self2.protocol) {
              self2.protocol = baseUri.protocol;
            }
            if (!self2.userInfo) {
              self2.userInfo = baseUri.userInfo;
            }
            if (!self2.port && self2.host === "mce_host") {
              self2.port = baseUri.port;
            }
            if (!self2.host || self2.host === "mce_host") {
              self2.host = baseUri.host;
            }
            self2.source = "";
          }
          if (isProtocolRelative) {
            self2.protocol = "";
          }
        };
        URI.prototype = {
          setPath: function(path2) {
            var self2 = this;
            path2 = /^(.*?)\/?(\w+)?$/.exec(path2);
            self2.path = path2[0];
            self2.directory = path2[1];
            self2.file = path2[2];
            self2.source = "";
            self2.getURI();
          },
          toRelative: function(uri) {
            var self2 = this;
            var output;
            if (uri === "./") {
              return uri;
            }
            uri = new URI(uri, { base_uri: self2 });
            if (uri.host !== "mce_host" && self2.host !== uri.host && uri.host || self2.port !== uri.port || self2.protocol !== uri.protocol && uri.protocol !== "") {
              return uri.getURI();
            }
            var tu = self2.getURI(), uu = uri.getURI();
            if (tu === uu || tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu) {
              return tu;
            }
            output = self2.toRelPath(self2.path, uri.path);
            if (uri.query) {
              output += "?" + uri.query;
            }
            if (uri.anchor) {
              output += "#" + uri.anchor;
            }
            return output;
          },
          toAbsolute: function(uri, noHost) {
            uri = new URI(uri, { base_uri: this });
            return uri.getURI(noHost && this.isSameOrigin(uri));
          },
          isSameOrigin: function(uri) {
            if (this.host == uri.host && this.protocol == uri.protocol) {
              if (this.port == uri.port) {
                return true;
              }
              var defaultPort = DEFAULT_PORTS[this.protocol];
              if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
                return true;
              }
            }
            return false;
          },
          toRelPath: function(base, path2) {
            var items, breakPoint = 0, out = "", i2, l;
            base = base.substring(0, base.lastIndexOf("/"));
            base = base.split("/");
            items = path2.split("/");
            if (base.length >= items.length) {
              for (i2 = 0, l = base.length; i2 < l; i2++) {
                if (i2 >= items.length || base[i2] !== items[i2]) {
                  breakPoint = i2 + 1;
                  break;
                }
              }
            }
            if (base.length < items.length) {
              for (i2 = 0, l = items.length; i2 < l; i2++) {
                if (i2 >= base.length || base[i2] !== items[i2]) {
                  breakPoint = i2 + 1;
                  break;
                }
              }
            }
            if (breakPoint === 1) {
              return path2;
            }
            for (i2 = 0, l = base.length - (breakPoint - 1); i2 < l; i2++) {
              out += "../";
            }
            for (i2 = breakPoint - 1, l = items.length; i2 < l; i2++) {
              if (i2 !== breakPoint - 1) {
                out += "/" + items[i2];
              } else {
                out += items[i2];
              }
            }
            return out;
          },
          toAbsPath: function(base, path2) {
            var i2, nb = 0, o = [], tr, outPath;
            tr = /\/$/.test(path2) ? "/" : "";
            base = base.split("/");
            path2 = path2.split("/");
            each$k(base, function(k) {
              if (k) {
                o.push(k);
              }
            });
            base = o;
            for (i2 = path2.length - 1, o = []; i2 >= 0; i2--) {
              if (path2[i2].length === 0 || path2[i2] === ".") {
                continue;
              }
              if (path2[i2] === "..") {
                nb++;
                continue;
              }
              if (nb > 0) {
                nb--;
                continue;
              }
              o.push(path2[i2]);
            }
            i2 = base.length - nb;
            if (i2 <= 0) {
              outPath = o.reverse().join("/");
            } else {
              outPath = base.slice(0, i2).join("/") + "/" + o.reverse().join("/");
            }
            if (outPath.indexOf("/") !== 0) {
              outPath = "/" + outPath;
            }
            if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) {
              outPath += tr;
            }
            return outPath;
          },
          getURI: function(noProtoHost) {
            var s;
            var self2 = this;
            if (!self2.source || noProtoHost) {
              s = "";
              if (!noProtoHost) {
                if (self2.protocol) {
                  s += self2.protocol + "://";
                } else {
                  s += "//";
                }
                if (self2.userInfo) {
                  s += self2.userInfo + "@";
                }
                if (self2.host) {
                  s += self2.host;
                }
                if (self2.port) {
                  s += ":" + self2.port;
                }
              }
              if (self2.path) {
                s += self2.path;
              }
              if (self2.query) {
                s += "?" + self2.query;
              }
              if (self2.anchor) {
                s += "#" + self2.anchor;
              }
              self2.source = s;
            }
            return self2.source;
          }
        };
        URI.parseDataUri = function(uri) {
          var type2, matches2;
          uri = decodeURIComponent(uri).split(",");
          matches2 = /data:([^;]+)/.exec(uri[0]);
          if (matches2) {
            type2 = matches2[1];
          }
          return {
            type: type2,
            data: uri[1]
          };
        };
        URI.getDocumentBaseUrl = function(loc) {
          var baseUrl;
          if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") {
            baseUrl = loc.href;
          } else {
            baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
          }
          if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
            baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
            if (!/[\/\\]$/.test(baseUrl)) {
              baseUrl += "/";
            }
          }
          return baseUrl;
        };
        var defaultFormat = "html";
        var trimEmptyContents = function(editor, html) {
          var blockName = Settings.getForcedRootBlock(editor);
          var emptyRegExp = new RegExp("^(<" + blockName + "[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/" + blockName + ">[\r\n]*|<br \\/>[\r\n]*)$");
          return html.replace(emptyRegExp, "");
        };
        var getContentFromBody = function(editor, args, body) {
          var content;
          args.format = args.format ? args.format : defaultFormat;
          args.get = true;
          args.getInner = true;
          if (!args.no_events) {
            editor.fire("BeforeGetContent", args);
          }
          if (args.format === "raw") {
            content = Tools.trim(TrimHtml.trimExternal(editor.serializer, body.innerHTML));
          } else if (args.format === "text") {
            content = Zwsp.trim(body.innerText || body.textContent);
          } else if (args.format === "tree") {
            return editor.serializer.serialize(body, args);
          } else {
            content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
          }
          if (args.format !== "text" && !isWsPreserveElement(Element.fromDom(body))) {
            args.content = Tools.trim(content);
          } else {
            args.content = content;
          }
          if (!args.no_events) {
            editor.fire("GetContent", args);
          }
          return args.content;
        };
        var getContent$1 = function(editor, args) {
          if (args === void 0) {
            args = {};
          }
          return Option.from(editor.getBody()).fold(constant(args.format === "tree" ? new Node$1("body", 11) : ""), function(body) {
            return getContentFromBody(editor, args, body);
          });
        };
        var traverse = function(node2, fn) {
          fn(node2);
          if (node2.firstChild) {
            traverse(node2.firstChild, fn);
          }
          if (node2.next) {
            traverse(node2.next, fn);
          }
        };
        var findMatchingNodes = function(nodeFilters, attributeFilters, node2) {
          var nodeMatches = {};
          var attrMatches = {};
          var matches2 = [];
          if (node2.firstChild) {
            traverse(node2.firstChild, function(node3) {
              each(nodeFilters, function(filter2) {
                if (filter2.name === node3.name) {
                  if (nodeMatches[filter2.name]) {
                    nodeMatches[filter2.name].nodes.push(node3);
                  } else {
                    nodeMatches[filter2.name] = {
                      filter: filter2,
                      nodes: [node3]
                    };
                  }
                }
              });
              each(attributeFilters, function(filter2) {
                if (typeof node3.attr(filter2.name) === "string") {
                  if (attrMatches[filter2.name]) {
                    attrMatches[filter2.name].nodes.push(node3);
                  } else {
                    attrMatches[filter2.name] = {
                      filter: filter2,
                      nodes: [node3]
                    };
                  }
                }
              });
            });
          }
          for (var name2 in nodeMatches) {
            if (nodeMatches.hasOwnProperty(name2)) {
              matches2.push(nodeMatches[name2]);
            }
          }
          for (var name2 in attrMatches) {
            if (attrMatches.hasOwnProperty(name2)) {
              matches2.push(attrMatches[name2]);
            }
          }
          return matches2;
        };
        var filter$3 = function(nodeFilters, attributeFilters, node2) {
          var matches2 = findMatchingNodes(nodeFilters, attributeFilters, node2);
          each(matches2, function(match2) {
            each(match2.filter.callbacks, function(callback) {
              callback(match2.nodes, match2.filter.name, {});
            });
          });
        };
        var defaultFormat$1 = "html";
        var isTreeNode = function(content) {
          return content instanceof Node$1;
        };
        var moveSelection = function(editor) {
          if (EditorFocus.hasFocus(editor)) {
            CaretFinder.firstPositionIn(editor.getBody()).each(function(pos) {
              var node2 = pos.getNode();
              var caretPos = NodeType.isTable(node2) ? CaretFinder.firstPositionIn(node2).getOr(pos) : pos;
              editor.selection.setRng(caretPos.toRange());
            });
          }
        };
        var setEditorHtml = function(editor, html) {
          editor.dom.setHTML(editor.getBody(), html);
          moveSelection(editor);
        };
        var setContentString = function(editor, body, content, args) {
          var forcedRootBlockName, padd;
          if (content.length === 0 || /^\s+$/.test(content)) {
            padd = '<br data-mce-bogus="1">';
            if (body.nodeName === "TABLE") {
              content = "<tr><td>" + padd + "</td></tr>";
            } else if (/^(UL|OL)$/.test(body.nodeName)) {
              content = "<li>" + padd + "</li>";
            }
            forcedRootBlockName = Settings.getForcedRootBlock(editor);
            if (forcedRootBlockName && editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
              content = padd;
              content = editor.dom.createHTML(forcedRootBlockName, editor.settings.forced_root_block_attrs, content);
            } else if (!content) {
              content = '<br data-mce-bogus="1">';
            }
            setEditorHtml(editor, content);
            editor.fire("SetContent", args);
          } else {
            if (args.format !== "raw") {
              content = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {
                isRootContent: true,
                insert: true
              }));
            }
            args.content = isWsPreserveElement(Element.fromDom(body)) ? content : Tools.trim(content);
            setEditorHtml(editor, args.content);
            if (!args.no_events) {
              editor.fire("SetContent", args);
            }
          }
          return args.content;
        };
        var setContentTree = function(editor, body, content, args) {
          filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
          var html = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(content);
          args.content = isWsPreserveElement(Element.fromDom(body)) ? html : Tools.trim(html);
          setEditorHtml(editor, args.content);
          if (!args.no_events) {
            editor.fire("SetContent", args);
          }
          return content;
        };
        var setContent$1 = function(editor, content, args) {
          if (args === void 0) {
            args = {};
          }
          args.format = args.format ? args.format : defaultFormat$1;
          args.set = true;
          args.content = isTreeNode(content) ? "" : content;
          if (!isTreeNode(content) && !args.no_events) {
            editor.fire("BeforeSetContent", args);
            content = args.content;
          }
          return Option.from(editor.getBody()).fold(constant(content), function(body) {
            return isTreeNode(content) ? setContentTree(editor, body, content, args) : setContentString(editor, body, content, args);
          });
        };
        var DOM$6 = DOMUtils$1.DOM;
        var restoreOriginalStyles = function(editor) {
          DOM$6.setStyle(editor.id, "display", editor.orgDisplay);
        };
        var safeDestroy = function(x) {
          return Option.from(x).each(function(x2) {
            return x2.destroy();
          });
        };
        var clearDomReferences = function(editor) {
          editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;
          editor.bodyElement = editor.contentDocument = editor.contentWindow = null;
          editor.iframeElement = editor.targetElm = null;
          if (editor.selection) {
            editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;
          }
        };
        var restoreForm = function(editor) {
          var form = editor.formElement;
          if (form) {
            if (form._mceOldSubmit) {
              form.submit = form._mceOldSubmit;
              form._mceOldSubmit = null;
            }
            DOM$6.unbind(form, "submit reset", editor.formEventDelegate);
          }
        };
        var remove$7 = function(editor) {
          if (!editor.removed) {
            var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;
            var body = editor.getBody();
            var element = editor.getElement();
            if (body) {
              editor.save({ is_removing: true });
            }
            editor.removed = true;
            editor.unbindAllNativeEvents();
            if (editor.hasHiddenInput && element) {
              DOM$6.remove(element.nextSibling);
            }
            Events.fireRemove(editor);
            editor.editorManager.remove(editor);
            if (!editor.inline && body) {
              restoreOriginalStyles(editor);
            }
            Events.fireDetach(editor);
            DOM$6.remove(editor.getContainer());
            safeDestroy(_selectionOverrides);
            safeDestroy(editorUpload);
            editor.destroy();
          }
        };
        var destroy = function(editor, automatic) {
          var selection = editor.selection, dom2 = editor.dom;
          if (editor.destroyed) {
            return;
          }
          if (!automatic && !editor.removed) {
            editor.remove();
            return;
          }
          if (!automatic) {
            editor.editorManager.off("beforeunload", editor._beforeUnload);
            if (editor.theme && editor.theme.destroy) {
              editor.theme.destroy();
            }
            safeDestroy(selection);
            safeDestroy(dom2);
          }
          restoreForm(editor);
          clearDomReferences(editor);
          editor.destroyed = true;
        };
        var DOM$7 = DOMUtils$1.DOM;
        var extend$4 = Tools.extend, each$l = Tools.each;
        var resolve$4 = Tools.resolve;
        var ie$2 = Env.ie;
        var Editor = function(id, settings, editorManager) {
          var self2 = this;
          var documentBaseUrl = self2.documentBaseUrl = editorManager.documentBaseURL;
          var baseUri = editorManager.baseURI;
          settings = getEditorSettings(self2, id, documentBaseUrl, editorManager.defaultSettings, settings);
          self2.settings = settings;
          AddOnManager.language = settings.language || "en";
          AddOnManager.languageLoad = settings.language_load;
          AddOnManager.baseURL = editorManager.baseURL;
          self2.id = id;
          self2.setDirty(false);
          self2.plugins = {};
          self2.documentBaseURI = new URI(settings.document_base_url, { base_uri: baseUri });
          self2.baseURI = baseUri;
          self2.contentCSS = [];
          self2.contentStyles = [];
          self2.shortcuts = new Shortcuts(self2);
          self2.loadedCSS = {};
          self2.editorCommands = new EditorCommands(self2);
          self2.suffix = editorManager.suffix;
          self2.editorManager = editorManager;
          self2.inline = settings.inline;
          self2.buttons = {};
          self2.menuItems = {};
          if (settings.cache_suffix) {
            Env.cacheSuffix = settings.cache_suffix.replace(/^[\?\&]+/, "");
          }
          if (settings.override_viewport === false) {
            Env.overrideViewPort = false;
          }
          editorManager.fire("SetupEditor", { editor: self2 });
          self2.execCallback("setup", self2);
          self2.$ = DomQuery.overrideDefaults(function() {
            return {
              context: self2.inline ? self2.getBody() : self2.getDoc(),
              element: self2.getBody()
            };
          });
        };
        Editor.prototype = {
          render: function() {
            Render.render(this);
          },
          focus: function(skipFocus) {
            EditorFocus.focus(this, skipFocus);
          },
          hasFocus: function() {
            return EditorFocus.hasFocus(this);
          },
          execCallback: function(name2) {
            var x = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              x[_i - 1] = arguments[_i];
            }
            var self2 = this;
            var callback = self2.settings[name2], scope;
            if (!callback) {
              return;
            }
            if (self2.callbackLookup && (scope = self2.callbackLookup[name2])) {
              callback = scope.func;
              scope = scope.scope;
            }
            if (typeof callback === "string") {
              scope = callback.replace(/\.\w+$/, "");
              scope = scope ? resolve$4(scope) : 0;
              callback = resolve$4(callback);
              self2.callbackLookup = self2.callbackLookup || {};
              self2.callbackLookup[name2] = {
                func: callback,
                scope
              };
            }
            return callback.apply(scope || self2, Array.prototype.slice.call(arguments, 1));
          },
          translate: function(text) {
            if (text && Tools.is(text, "string")) {
              var lang_1 = this.settings.language || "en", i18n_1 = this.editorManager.i18n;
              text = i18n_1.data[lang_1 + "." + text] || text.replace(/\{\#([^\}]+)\}/g, function(a, b) {
                return i18n_1.data[lang_1 + "." + b] || "{#" + b + "}";
              });
            }
            return this.editorManager.translate(text);
          },
          getLang: function(name2, defaultVal) {
            return this.editorManager.i18n.data[(this.settings.language || "en") + "." + name2] || (defaultVal !== void 0 ? defaultVal : "{#" + name2 + "}");
          },
          getParam: function(name2, defaultVal, type2) {
            return getParam(this, name2, defaultVal, type2);
          },
          nodeChanged: function(args) {
            this._nodeChangeDispatcher.nodeChanged(args);
          },
          addButton: function(name2, settings) {
            var self2 = this;
            if (settings.cmd) {
              settings.onclick = function() {
                self2.execCommand(settings.cmd);
              };
            }
            if (settings.stateSelector && typeof settings.active === "undefined") {
              settings.active = false;
            }
            if (!settings.text && !settings.icon) {
              settings.icon = name2;
            }
            settings.tooltip = settings.tooltip || settings.title;
            self2.buttons[name2] = settings;
          },
          addSidebar: function(name2, settings) {
            return Sidebar.add(this, name2, settings);
          },
          addMenuItem: function(name2, settings) {
            var self2 = this;
            if (settings.cmd) {
              settings.onclick = function() {
                self2.execCommand(settings.cmd);
              };
            }
            self2.menuItems[name2] = settings;
          },
          addContextToolbar: function(predicate, items) {
            var self2 = this;
            var selector;
            self2.contextToolbars = self2.contextToolbars || [];
            if (typeof predicate === "string") {
              selector = predicate;
              predicate = function(elm) {
                return self2.dom.is(elm, selector);
              };
            }
            self2.contextToolbars.push({
              id: Uuid.uuid("mcet"),
              predicate,
              items
            });
          },
          addCommand: function(name2, callback, scope) {
            this.editorCommands.addCommand(name2, callback, scope);
          },
          addQueryStateHandler: function(name2, callback, scope) {
            this.editorCommands.addQueryStateHandler(name2, callback, scope);
          },
          addQueryValueHandler: function(name2, callback, scope) {
            this.editorCommands.addQueryValueHandler(name2, callback, scope);
          },
          addShortcut: function(pattern, desc, cmdFunc, scope) {
            this.shortcuts.add(pattern, desc, cmdFunc, scope);
          },
          execCommand: function(cmd, ui, value2, args) {
            return this.editorCommands.execCommand(cmd, ui, value2, args);
          },
          queryCommandState: function(cmd) {
            return this.editorCommands.queryCommandState(cmd);
          },
          queryCommandValue: function(cmd) {
            return this.editorCommands.queryCommandValue(cmd);
          },
          queryCommandSupported: function(cmd) {
            return this.editorCommands.queryCommandSupported(cmd);
          },
          show: function() {
            var self2 = this;
            if (self2.hidden) {
              self2.hidden = false;
              if (self2.inline) {
                self2.getBody().contentEditable = true;
              } else {
                DOM$7.show(self2.getContainer());
                DOM$7.hide(self2.id);
              }
              self2.load();
              self2.fire("show");
            }
          },
          hide: function() {
            var self2 = this, doc2 = self2.getDoc();
            if (!self2.hidden) {
              if (ie$2 && doc2 && !self2.inline) {
                doc2.execCommand("SelectAll");
              }
              self2.save();
              if (self2.inline) {
                self2.getBody().contentEditable = false;
                if (self2 === self2.editorManager.focusedEditor) {
                  self2.editorManager.focusedEditor = null;
                }
              } else {
                DOM$7.hide(self2.getContainer());
                DOM$7.setStyle(self2.id, "display", self2.orgDisplay);
              }
              self2.hidden = true;
              self2.fire("hide");
            }
          },
          isHidden: function() {
            return !!this.hidden;
          },
          setProgressState: function(state, time) {
            this.fire("ProgressState", {
              state,
              time
            });
          },
          load: function(args) {
            var self2 = this;
            var elm = self2.getElement(), html;
            if (self2.removed) {
              return "";
            }
            if (elm) {
              args = args || {};
              args.load = true;
              html = self2.setContent(elm.value !== void 0 ? elm.value : elm.innerHTML, args);
              args.element = elm;
              if (!args.no_events) {
                self2.fire("LoadContent", args);
              }
              args.element = elm = null;
              return html;
            }
          },
          save: function(args) {
            var self2 = this;
            var elm = self2.getElement(), html, form;
            if (!elm || !self2.initialized || self2.removed) {
              return;
            }
            args = args || {};
            args.save = true;
            args.element = elm;
            html = args.content = self2.getContent(args);
            if (!args.no_events) {
              self2.fire("SaveContent", args);
            }
            if (args.format === "raw") {
              self2.fire("RawSaveContent", args);
            }
            html = args.content;
            if (!/TEXTAREA|INPUT/i.test(elm.nodeName)) {
              if (args.is_removing || !self2.inline) {
                elm.innerHTML = html;
              }
              if (form = DOM$7.getParent(self2.id, "form")) {
                each$l(form.elements, function(elm2) {
                  if (elm2.name === self2.id) {
                    elm2.value = html;
                    return false;
                  }
                });
              }
            } else {
              elm.value = html;
            }
            args.element = elm = null;
            if (args.set_dirty !== false) {
              self2.setDirty(false);
            }
            return html;
          },
          setContent: function(content, args) {
            return setContent$1(this, content, args);
          },
          getContent: function(args) {
            return getContent$1(this, args);
          },
          insertContent: function(content, args) {
            if (args) {
              content = extend$4({ content }, args);
            }
            this.execCommand("mceInsertContent", false, content);
          },
          isDirty: function() {
            return !this.isNotDirty;
          },
          setDirty: function(state) {
            var oldState = !this.isNotDirty;
            this.isNotDirty = !state;
            if (state && state !== oldState) {
              this.fire("dirty");
            }
          },
          setMode: function(mode) {
            setMode(this, mode);
          },
          getContainer: function() {
            var self2 = this;
            if (!self2.container) {
              self2.container = DOM$7.get(self2.editorContainer || self2.id + "_parent");
            }
            return self2.container;
          },
          getContentAreaContainer: function() {
            return this.contentAreaContainer;
          },
          getElement: function() {
            if (!this.targetElm) {
              this.targetElm = DOM$7.get(this.id);
            }
            return this.targetElm;
          },
          getWin: function() {
            var self2 = this;
            var elm;
            if (!self2.contentWindow) {
              elm = self2.iframeElement;
              if (elm) {
                self2.contentWindow = elm.contentWindow;
              }
            }
            return self2.contentWindow;
          },
          getDoc: function() {
            var self2 = this;
            var win;
            if (!self2.contentDocument) {
              win = self2.getWin();
              if (win) {
                self2.contentDocument = win.document;
              }
            }
            return self2.contentDocument;
          },
          getBody: function() {
            var doc2 = this.getDoc();
            return this.bodyElement || (doc2 ? doc2.body : null);
          },
          convertURL: function(url2, name2, elm) {
            var self2 = this, settings = self2.settings;
            if (settings.urlconverter_callback) {
              return self2.execCallback("urlconverter_callback", url2, elm, true, name2);
            }
            if (!settings.convert_urls || elm && elm.nodeName === "LINK" || url2.indexOf("file:") === 0 || url2.length === 0) {
              return url2;
            }
            if (settings.relative_urls) {
              return self2.documentBaseURI.toRelative(url2);
            }
            url2 = self2.documentBaseURI.toAbsolute(url2, settings.remove_script_host);
            return url2;
          },
          addVisual: function(elm) {
            var self2 = this;
            var settings = self2.settings;
            var dom2 = self2.dom;
            var cls;
            elm = elm || self2.getBody();
            if (self2.hasVisual === void 0) {
              self2.hasVisual = settings.visual;
            }
            each$l(dom2.select("table,a", elm), function(elm2) {
              var value2;
              switch (elm2.nodeName) {
                case "TABLE":
                  cls = settings.visual_table_class || "mce-item-table";
                  value2 = dom2.getAttrib(elm2, "border");
                  if ((!value2 || value2 === "0") && self2.hasVisual) {
                    dom2.addClass(elm2, cls);
                  } else {
                    dom2.removeClass(elm2, cls);
                  }
                  return;
                case "A":
                  if (!dom2.getAttrib(elm2, "href")) {
                    value2 = dom2.getAttrib(elm2, "name") || elm2.id;
                    cls = settings.visual_anchor_class || "mce-item-anchor";
                    if (value2 && self2.hasVisual) {
                      dom2.addClass(elm2, cls);
                    } else {
                      dom2.removeClass(elm2, cls);
                    }
                  }
                  return;
              }
            });
            self2.fire("VisualAid", {
              element: elm,
              hasVisual: self2.hasVisual
            });
          },
          remove: function() {
            remove$7(this);
          },
          destroy: function(automatic) {
            destroy(this, automatic);
          },
          uploadImages: function(callback) {
            return this.editorUpload.uploadImages(callback);
          },
          _scanForImages: function() {
            return this.editorUpload.scanForImages();
          }
        };
        extend$4(Editor.prototype, EditorObservable$1);
        var isEditorUIElement = function(elm) {
          return elm.className.toString().indexOf("mce-") !== -1;
        };
        var FocusManager = { isEditorUIElement };
        var isManualNodeChange = function(e) {
          return e.type === "nodechange" && e.selectionChange;
        };
        var registerPageMouseUp = function(editor, throttledStore) {
          var mouseUpPage = function() {
            throttledStore.throttle();
          };
          DOMUtils$1.DOM.bind(domGlobals.document, "mouseup", mouseUpPage);
          editor.on("remove", function() {
            DOMUtils$1.DOM.unbind(domGlobals.document, "mouseup", mouseUpPage);
          });
        };
        var registerFocusOut = function(editor) {
          editor.on("focusout", function() {
            SelectionBookmark.store(editor);
          });
        };
        var registerMouseUp = function(editor, throttledStore) {
          editor.on("mouseup touchend", function(e) {
            throttledStore.throttle();
          });
        };
        var registerEditorEvents = function(editor, throttledStore) {
          var browser2 = PlatformDetection$1.detect().browser;
          if (browser2.isIE()) {
            registerFocusOut(editor);
          } else {
            registerMouseUp(editor, throttledStore);
          }
          editor.on("keyup nodechange", function(e) {
            if (!isManualNodeChange(e)) {
              SelectionBookmark.store(editor);
            }
          });
        };
        var register$3 = function(editor) {
          var throttledStore = first(function() {
            SelectionBookmark.store(editor);
          }, 0);
          if (editor.inline) {
            registerPageMouseUp(editor, throttledStore);
          }
          editor.on("init", function() {
            registerEditorEvents(editor, throttledStore);
          });
          editor.on("remove", function() {
            throttledStore.cancel();
          });
        };
        var SelectionRestore = { register: register$3 };
        var documentFocusInHandler;
        var DOM$8 = DOMUtils$1.DOM;
        var isEditorUIElement$1 = function(elm) {
          return FocusManager.isEditorUIElement(elm);
        };
        var isUIElement = function(editor, elm) {
          var customSelector = editor ? editor.settings.custom_ui_selector : "";
          var parent2 = DOM$8.getParent(elm, function(elm2) {
            return isEditorUIElement$1(elm2) || (customSelector ? editor.dom.is(elm2, customSelector) : false);
          });
          return parent2 !== null;
        };
        var getActiveElement = function() {
          try {
            return domGlobals.document.activeElement;
          } catch (ex) {
            return domGlobals.document.body;
          }
        };
        var registerEvents = function(editorManager, e) {
          var editor = e.editor;
          SelectionRestore.register(editor);
          editor.on("focusin", function() {
            var self2 = this;
            var focusedEditor = editorManager.focusedEditor;
            if (focusedEditor !== self2) {
              if (focusedEditor) {
                focusedEditor.fire("blur", { focusedEditor: self2 });
              }
              editorManager.setActive(self2);
              editorManager.focusedEditor = self2;
              self2.fire("focus", { blurredEditor: focusedEditor });
              self2.focus(true);
            }
          });
          editor.on("focusout", function() {
            var self2 = this;
            Delay.setEditorTimeout(self2, function() {
              var focusedEditor = editorManager.focusedEditor;
              if (!isUIElement(self2, getActiveElement()) && focusedEditor === self2) {
                self2.fire("blur", { focusedEditor: null });
                editorManager.focusedEditor = null;
              }
            });
          });
          if (!documentFocusInHandler) {
            documentFocusInHandler = function(e2) {
              var activeEditor = editorManager.activeEditor;
              var target;
              target = e2.target;
              if (activeEditor && target.ownerDocument === domGlobals.document) {
                if (target !== domGlobals.document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {
                  activeEditor.fire("blur", { focusedEditor: null });
                  editorManager.focusedEditor = null;
                }
              }
            };
            DOM$8.bind(domGlobals.document, "focusin", documentFocusInHandler);
          }
        };
        var unregisterDocumentEvents = function(editorManager, e) {
          if (editorManager.focusedEditor === e.editor) {
            editorManager.focusedEditor = null;
          }
          if (!editorManager.activeEditor) {
            DOM$8.unbind(domGlobals.document, "focusin", documentFocusInHandler);
            documentFocusInHandler = null;
          }
        };
        var setup$h = function(editorManager) {
          editorManager.on("AddEditor", curry(registerEvents, editorManager));
          editorManager.on("RemoveEditor", curry(unregisterDocumentEvents, editorManager));
        };
        var FocusController = {
          setup: setup$h,
          isEditorUIElement: isEditorUIElement$1,
          isUIElement
        };
        var DOM$9 = DOMUtils$1.DOM;
        var explode$4 = Tools.explode, each$m = Tools.each, extend$5 = Tools.extend;
        var instanceCounter = 0, beforeUnloadDelegate, EditorManager, boundGlobalEvents = false;
        var legacyEditors = [];
        var editors = [];
        var isValidLegacyKey = function(id) {
          return id !== "length";
        };
        var globalEventDelegate = function(e) {
          var type2 = e.type;
          each$m(EditorManager.get(), function(editor) {
            switch (type2) {
              case "scroll":
                editor.fire("ScrollWindow", e);
                break;
              case "resize":
                editor.fire("ResizeWindow", e);
                break;
            }
          });
        };
        var toggleGlobalEvents = function(state) {
          if (state !== boundGlobalEvents) {
            if (state) {
              DomQuery(window).on("resize scroll", globalEventDelegate);
            } else {
              DomQuery(window).off("resize scroll", globalEventDelegate);
            }
            boundGlobalEvents = state;
          }
        };
        var removeEditorFromList = function(targetEditor) {
          var oldEditors = editors;
          delete legacyEditors[targetEditor.id];
          for (var i2 = 0; i2 < legacyEditors.length; i2++) {
            if (legacyEditors[i2] === targetEditor) {
              legacyEditors.splice(i2, 1);
              break;
            }
          }
          editors = filter(editors, function(editor) {
            return targetEditor !== editor;
          });
          if (EditorManager.activeEditor === targetEditor) {
            EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
          }
          if (EditorManager.focusedEditor === targetEditor) {
            EditorManager.focusedEditor = null;
          }
          return oldEditors.length !== editors.length;
        };
        var purgeDestroyedEditor = function(editor) {
          if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
            removeEditorFromList(editor);
            editor.unbindAllNativeEvents();
            editor.destroy(true);
            editor.removed = true;
            editor = null;
          }
          return editor;
        };
        EditorManager = {
          defaultSettings: {},
          $: DomQuery,
          majorVersion: "4",
          minorVersion: "9.11",
          releaseDate: "2020-07-13",
          editors: legacyEditors,
          i18n: I18n,
          activeEditor: null,
          settings: {},
          setup: function() {
            var self2 = this;
            var baseURL, documentBaseURL, suffix = "";
            documentBaseURL = URI.getDocumentBaseUrl(domGlobals.document.location);
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
              documentBaseURL = documentBaseURL.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
              if (!/[\/\\]$/.test(documentBaseURL)) {
                documentBaseURL += "/";
              }
            }
            var preInit = window.tinymce || window.tinyMCEPreInit;
            if (preInit) {
              baseURL = preInit.base || preInit.baseURL;
              suffix = preInit.suffix;
            } else {
              var scripts = domGlobals.document.getElementsByTagName("script");
              for (var i2 = 0; i2 < scripts.length; i2++) {
                var src = scripts[i2].src || "";
                if (src === "") {
                  continue;
                }
                var srcScript = src.substring(src.lastIndexOf("/"));
                if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
                  if (srcScript.indexOf(".min") !== -1) {
                    suffix = ".min";
                  }
                  baseURL = src.substring(0, src.lastIndexOf("/"));
                  break;
                }
              }
              if (!baseURL && domGlobals.document.currentScript) {
                var src = domGlobals.document.currentScript.src;
                if (src.indexOf(".min") !== -1) {
                  suffix = ".min";
                }
                baseURL = src.substring(0, src.lastIndexOf("/"));
              }
            }
            self2.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
            self2.documentBaseURL = documentBaseURL;
            self2.baseURI = new URI(self2.baseURL);
            self2.suffix = suffix;
            FocusController.setup(self2);
          },
          overrideDefaults: function(defaultSettings) {
            var baseUrl, suffix;
            baseUrl = defaultSettings.base_url;
            if (baseUrl) {
              this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ""));
              this.baseURI = new URI(this.baseURL);
            }
            suffix = defaultSettings.suffix;
            if (defaultSettings.suffix) {
              this.suffix = suffix;
            }
            this.defaultSettings = defaultSettings;
            var pluginBaseUrls = defaultSettings.plugin_base_urls;
            for (var name2 in pluginBaseUrls) {
              AddOnManager.PluginManager.urls[name2] = pluginBaseUrls[name2];
            }
          },
          init: function(settings) {
            var self2 = this;
            var result, invalidInlineTargets;
            invalidInlineTargets = Tools.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option tbody tfoot thead tr script noscript style textarea video audio iframe object menu", " ");
            var isInvalidInlineTarget = function(settings2, elm) {
              return settings2.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
            };
            var createId = function(elm) {
              var id = elm.id;
              if (!id) {
                id = elm.name;
                if (id && !DOM$9.get(id)) {
                  id = elm.name;
                } else {
                  id = DOM$9.uniqueId();
                }
                elm.setAttribute("id", id);
              }
              return id;
            };
            var execCallback = function(name2) {
              var callback = settings[name2];
              if (!callback) {
                return;
              }
              return callback.apply(self2, Array.prototype.slice.call(arguments, 2));
            };
            var hasClass2 = function(elm, className) {
              return className.constructor === RegExp ? className.test(elm.className) : DOM$9.hasClass(elm, className);
            };
            var findTargets = function(settings2) {
              var l, targets = [];
              if (Env.ie && Env.ie < 11) {
                ErrorReporter.initError("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/");
                return [];
              }
              if (settings2.types) {
                each$m(settings2.types, function(type2) {
                  targets = targets.concat(DOM$9.select(type2.selector));
                });
                return targets;
              } else if (settings2.selector) {
                return DOM$9.select(settings2.selector);
              } else if (settings2.target) {
                return [settings2.target];
              }
              switch (settings2.mode) {
                case "exact":
                  l = settings2.elements || "";
                  if (l.length > 0) {
                    each$m(explode$4(l), function(id) {
                      var elm;
                      if (elm = DOM$9.get(id)) {
                        targets.push(elm);
                      } else {
                        each$m(domGlobals.document.forms, function(f) {
                          each$m(f.elements, function(e) {
                            if (e.name === id) {
                              id = "mce_editor_" + instanceCounter++;
                              DOM$9.setAttrib(e, "id", id);
                              targets.push(e);
                            }
                          });
                        });
                      }
                    });
                  }
                  break;
                case "textareas":
                case "specific_textareas":
                  each$m(DOM$9.select("textarea"), function(elm) {
                    if (settings2.editor_deselector && hasClass2(elm, settings2.editor_deselector)) {
                      return;
                    }
                    if (!settings2.editor_selector || hasClass2(elm, settings2.editor_selector)) {
                      targets.push(elm);
                    }
                  });
                  break;
              }
              return targets;
            };
            var provideResults = function(editors2) {
              result = editors2;
            };
            var initEditors = function() {
              var initCount = 0;
              var editors2 = [];
              var targets;
              var createEditor = function(id, settings2, targetElm) {
                var editor = new Editor(id, settings2, self2);
                editors2.push(editor);
                editor.on("init", function() {
                  if (++initCount === targets.length) {
                    provideResults(editors2);
                  }
                });
                editor.targetElm = editor.targetElm || targetElm;
                editor.render();
              };
              DOM$9.unbind(window, "ready", initEditors);
              execCallback("onpageload");
              targets = DomQuery.unique(findTargets(settings));
              if (settings.types) {
                each$m(settings.types, function(type2) {
                  Tools.each(targets, function(elm) {
                    if (DOM$9.is(elm, type2.selector)) {
                      createEditor(createId(elm), extend$5({}, settings, type2), elm);
                      return false;
                    }
                    return true;
                  });
                });
                return;
              }
              Tools.each(targets, function(elm) {
                purgeDestroyedEditor(self2.get(elm.id));
              });
              targets = Tools.grep(targets, function(elm) {
                return !self2.get(elm.id);
              });
              if (targets.length === 0) {
                provideResults([]);
              } else {
                each$m(targets, function(elm) {
                  if (isInvalidInlineTarget(settings, elm)) {
                    ErrorReporter.initError("Could not initialize inline editor on invalid inline target element", elm);
                  } else {
                    createEditor(createId(elm), settings, elm);
                  }
                });
              }
            };
            self2.settings = settings;
            DOM$9.bind(window, "ready", initEditors);
            return new promiseObj(function(resolve2) {
              if (result) {
                resolve2(result);
              } else {
                provideResults = function(editors2) {
                  resolve2(editors2);
                };
              }
            });
          },
          get: function(id) {
            if (arguments.length === 0) {
              return editors.slice(0);
            } else if (isString(id)) {
              return find(editors, function(editor) {
                return editor.id === id;
              }).getOr(null);
            } else if (isNumber(id)) {
              return editors[id] ? editors[id] : null;
            } else {
              return null;
            }
          },
          add: function(editor) {
            var self2 = this;
            var existingEditor;
            existingEditor = legacyEditors[editor.id];
            if (existingEditor === editor) {
              return editor;
            }
            if (self2.get(editor.id) === null) {
              if (isValidLegacyKey(editor.id)) {
                legacyEditors[editor.id] = editor;
              }
              legacyEditors.push(editor);
              editors.push(editor);
            }
            toggleGlobalEvents(true);
            self2.activeEditor = editor;
            self2.fire("AddEditor", { editor });
            if (!beforeUnloadDelegate) {
              beforeUnloadDelegate = function() {
                self2.fire("BeforeUnload");
              };
              DOM$9.bind(window, "beforeunload", beforeUnloadDelegate);
            }
            return editor;
          },
          createEditor: function(id, settings) {
            return this.add(new Editor(id, settings, this));
          },
          remove: function(selector) {
            var self2 = this;
            var i2, editor;
            if (!selector) {
              for (i2 = editors.length - 1; i2 >= 0; i2--) {
                self2.remove(editors[i2]);
              }
              return;
            }
            if (isString(selector)) {
              each$m(DOM$9.select(selector), function(elm) {
                editor = self2.get(elm.id);
                if (editor) {
                  self2.remove(editor);
                }
              });
              return;
            }
            editor = selector;
            if (isNull(self2.get(editor.id))) {
              return null;
            }
            if (removeEditorFromList(editor)) {
              self2.fire("RemoveEditor", { editor });
            }
            if (editors.length === 0) {
              DOM$9.unbind(window, "beforeunload", beforeUnloadDelegate);
            }
            editor.remove();
            toggleGlobalEvents(editors.length > 0);
            return editor;
          },
          execCommand: function(cmd, ui, value2) {
            var self2 = this, editor = self2.get(value2);
            switch (cmd) {
              case "mceAddEditor":
                if (!self2.get(value2)) {
                  new Editor(value2, self2.settings, self2).render();
                }
                return true;
              case "mceRemoveEditor":
                if (editor) {
                  editor.remove();
                }
                return true;
              case "mceToggleEditor":
                if (!editor) {
                  self2.execCommand("mceAddEditor", 0, value2);
                  return true;
                }
                if (editor.isHidden()) {
                  editor.show();
                } else {
                  editor.hide();
                }
                return true;
            }
            if (self2.activeEditor) {
              return self2.activeEditor.execCommand(cmd, ui, value2);
            }
            return false;
          },
          triggerSave: function() {
            each$m(editors, function(editor) {
              editor.save();
            });
          },
          addI18n: function(code2, items) {
            I18n.add(code2, items);
          },
          translate: function(text) {
            return I18n.translate(text);
          },
          setActive: function(editor) {
            var activeEditor = this.activeEditor;
            if (this.activeEditor !== editor) {
              if (activeEditor) {
                activeEditor.fire("deactivate", { relatedTarget: editor });
              }
              editor.fire("activate", { relatedTarget: activeEditor });
            }
            this.activeEditor = editor;
          }
        };
        extend$5(EditorManager, Observable);
        EditorManager.setup();
        var EditorManager$1 = EditorManager;
        function RangeUtils(dom2) {
          var walk2 = function(rng, callback) {
            return RangeWalk.walk(dom2, rng, callback);
          };
          var split2 = SplitRange.split;
          var normalize2 = function(rng) {
            return NormalizeRange.normalize(dom2, rng).fold(constant(false), function(normalizedRng) {
              rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
              rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
              return true;
            });
          };
          return {
            walk: walk2,
            split: split2,
            normalize: normalize2
          };
        }
        (function(RangeUtils2) {
          RangeUtils2.compareRanges = RangeCompare.isEq;
          RangeUtils2.getCaretRangeFromPoint = CaretRangeFromPoint.fromPoint;
          RangeUtils2.getSelectedNode = getSelectedNode;
          RangeUtils2.getNode = getNode;
        })(RangeUtils || (RangeUtils = {}));
        var RangeUtils$1 = RangeUtils;
        var min = Math.min, max = Math.max, round$2 = Math.round;
        var relativePosition = function(rect, targetRect, rel) {
          var x, y, w, h, targetW, targetH;
          x = targetRect.x;
          y = targetRect.y;
          w = rect.w;
          h = rect.h;
          targetW = targetRect.w;
          targetH = targetRect.h;
          rel = (rel || "").split("");
          if (rel[0] === "b") {
            y += targetH;
          }
          if (rel[1] === "r") {
            x += targetW;
          }
          if (rel[0] === "c") {
            y += round$2(targetH / 2);
          }
          if (rel[1] === "c") {
            x += round$2(targetW / 2);
          }
          if (rel[3] === "b") {
            y -= h;
          }
          if (rel[4] === "r") {
            x -= w;
          }
          if (rel[3] === "c") {
            y -= round$2(h / 2);
          }
          if (rel[4] === "c") {
            x -= round$2(w / 2);
          }
          return create$4(x, y, w, h);
        };
        var findBestRelativePosition = function(rect, targetRect, constrainRect, rels) {
          var pos, i2;
          for (i2 = 0; i2 < rels.length; i2++) {
            pos = relativePosition(rect, targetRect, rels[i2]);
            if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
              return rels[i2];
            }
          }
          return null;
        };
        var inflate = function(rect, w, h) {
          return create$4(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
        };
        var intersect = function(rect, cropRect) {
          var x1, y1, x2, y2;
          x1 = max(rect.x, cropRect.x);
          y1 = max(rect.y, cropRect.y);
          x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
          y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
          if (x2 - x1 < 0 || y2 - y1 < 0) {
            return null;
          }
          return create$4(x1, y1, x2 - x1, y2 - y1);
        };
        var clamp$1 = function(rect, clampRect, fixedSize) {
          var underflowX1, underflowY1, overflowX2, overflowY2, x1, y1, x2, y2, cx2, cy2;
          x1 = rect.x;
          y1 = rect.y;
          x2 = rect.x + rect.w;
          y2 = rect.y + rect.h;
          cx2 = clampRect.x + clampRect.w;
          cy2 = clampRect.y + clampRect.h;
          underflowX1 = max(0, clampRect.x - x1);
          underflowY1 = max(0, clampRect.y - y1);
          overflowX2 = max(0, x2 - cx2);
          overflowY2 = max(0, y2 - cy2);
          x1 += underflowX1;
          y1 += underflowY1;
          if (fixedSize) {
            x2 += underflowX1;
            y2 += underflowY1;
            x1 -= overflowX2;
            y1 -= overflowY2;
          }
          x2 -= overflowX2;
          y2 -= overflowY2;
          return create$4(x1, y1, x2 - x1, y2 - y1);
        };
        var create$4 = function(x, y, w, h) {
          return {
            x,
            y,
            w,
            h
          };
        };
        var fromClientRect = function(clientRect) {
          return create$4(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
        };
        var Rect = {
          inflate,
          relativePosition,
          findBestRelativePosition,
          intersect,
          clamp: clamp$1,
          create: create$4,
          fromClientRect
        };
        var types = {};
        var Factory = {
          add: function(type2, typeClass) {
            types[type2.toLowerCase()] = typeClass;
          },
          has: function(type2) {
            return !!types[type2.toLowerCase()];
          },
          get: function(type2) {
            var lctype = type2.toLowerCase();
            var controlType = types.hasOwnProperty(lctype) ? types[lctype] : null;
            if (controlType === null) {
              throw new Error("Could not find module for type: " + type2);
            }
            return controlType;
          },
          create: function(type2, settings) {
            var ControlType;
            if (typeof type2 === "string") {
              settings = settings || {};
              settings.type = type2;
            } else {
              settings = type2;
              type2 = settings.type;
            }
            type2 = type2.toLowerCase();
            ControlType = types[type2];
            if (!ControlType) {
              throw new Error("Could not find control by type: " + type2);
            }
            ControlType = new ControlType(settings);
            ControlType.type = type2;
            return ControlType;
          }
        };
        var each$n = Tools.each, extend$6 = Tools.extend;
        var extendClass, initializing;
        var Class = function() {
        };
        Class.extend = extendClass = function(prop) {
          var self2 = this;
          var _super = self2.prototype;
          var prototype, name2, member;
          var Class2 = function() {
            var i2, mixins, mixin;
            var self3 = this;
            if (!initializing) {
              if (self3.init) {
                self3.init.apply(self3, arguments);
              }
              mixins = self3.Mixins;
              if (mixins) {
                i2 = mixins.length;
                while (i2--) {
                  mixin = mixins[i2];
                  if (mixin.init) {
                    mixin.init.apply(self3, arguments);
                  }
                }
              }
            }
          };
          var dummy = function() {
            return this;
          };
          var createMethod = function(name3, fn) {
            return function() {
              var self3 = this;
              var tmp = self3._super;
              var ret;
              self3._super = _super[name3];
              ret = fn.apply(self3, arguments);
              self3._super = tmp;
              return ret;
            };
          };
          initializing = true;
          prototype = new self2();
          initializing = false;
          if (prop.Mixins) {
            each$n(prop.Mixins, function(mixin) {
              for (var name_1 in mixin) {
                if (name_1 !== "init") {
                  prop[name_1] = mixin[name_1];
                }
              }
            });
            if (_super.Mixins) {
              prop.Mixins = _super.Mixins.concat(prop.Mixins);
            }
          }
          if (prop.Methods) {
            each$n(prop.Methods.split(","), function(name3) {
              prop[name3] = dummy;
            });
          }
          if (prop.Properties) {
            each$n(prop.Properties.split(","), function(name3) {
              var fieldName = "_" + name3;
              prop[name3] = function(value2) {
                var self3 = this;
                if (value2 !== void 0) {
                  self3[fieldName] = value2;
                  return self3;
                }
                return self3[fieldName];
              };
            });
          }
          if (prop.Statics) {
            each$n(prop.Statics, function(func, name3) {
              Class2[name3] = func;
            });
          }
          if (prop.Defaults && _super.Defaults) {
            prop.Defaults = extend$6({}, _super.Defaults, prop.Defaults);
          }
          for (name2 in prop) {
            member = prop[name2];
            if (typeof member === "function" && _super[name2]) {
              prototype[name2] = createMethod(name2, member);
            } else {
              prototype[name2] = member;
            }
          }
          Class2.prototype = prototype;
          Class2.constructor = Class2;
          Class2.extend = extendClass;
          return Class2;
        };
        var min$1 = Math.min, max$1 = Math.max, round$3 = Math.round;
        var Color = function(value2) {
          var self2 = {};
          var r = 0, g = 0, b = 0;
          var rgb2hsv = function(r2, g2, b2) {
            var h, s, v, d, minRGB, maxRGB;
            h = 0;
            s = 0;
            v = 0;
            r2 = r2 / 255;
            g2 = g2 / 255;
            b2 = b2 / 255;
            minRGB = min$1(r2, min$1(g2, b2));
            maxRGB = max$1(r2, max$1(g2, b2));
            if (minRGB === maxRGB) {
              v = minRGB;
              return {
                h: 0,
                s: 0,
                v: v * 100
              };
            }
            d = r2 === minRGB ? g2 - b2 : b2 === minRGB ? r2 - g2 : b2 - r2;
            h = r2 === minRGB ? 3 : b2 === minRGB ? 1 : 5;
            h = 60 * (h - d / (maxRGB - minRGB));
            s = (maxRGB - minRGB) / maxRGB;
            v = maxRGB;
            return {
              h: round$3(h),
              s: round$3(s * 100),
              v: round$3(v * 100)
            };
          };
          var hsvToRgb = function(hue, saturation, brightness) {
            var side, chroma, x, match2;
            hue = (parseInt(hue, 10) || 0) % 360;
            saturation = parseInt(saturation, 10) / 100;
            brightness = parseInt(brightness, 10) / 100;
            saturation = max$1(0, min$1(saturation, 1));
            brightness = max$1(0, min$1(brightness, 1));
            if (saturation === 0) {
              r = g = b = round$3(255 * brightness);
              return;
            }
            side = hue / 60;
            chroma = brightness * saturation;
            x = chroma * (1 - Math.abs(side % 2 - 1));
            match2 = brightness - chroma;
            switch (Math.floor(side)) {
              case 0:
                r = chroma;
                g = x;
                b = 0;
                break;
              case 1:
                r = x;
                g = chroma;
                b = 0;
                break;
              case 2:
                r = 0;
                g = chroma;
                b = x;
                break;
              case 3:
                r = 0;
                g = x;
                b = chroma;
                break;
              case 4:
                r = x;
                g = 0;
                b = chroma;
                break;
              case 5:
                r = chroma;
                g = 0;
                b = x;
                break;
              default:
                r = g = b = 0;
            }
            r = round$3(255 * (r + match2));
            g = round$3(255 * (g + match2));
            b = round$3(255 * (b + match2));
          };
          var toHex2 = function() {
            var hex = function(val) {
              val = parseInt(val, 10).toString(16);
              return val.length > 1 ? val : "0" + val;
            };
            return "#" + hex(r) + hex(g) + hex(b);
          };
          var toRgb = function() {
            return {
              r,
              g,
              b
            };
          };
          var toHsv = function() {
            return rgb2hsv(r, g, b);
          };
          var parse = function(value3) {
            var matches2;
            if (typeof value3 === "object") {
              if ("r" in value3) {
                r = value3.r;
                g = value3.g;
                b = value3.b;
              } else if ("v" in value3) {
                hsvToRgb(value3.h, value3.s, value3.v);
              }
            } else {
              if (matches2 = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value3)) {
                r = parseInt(matches2[1], 10);
                g = parseInt(matches2[2], 10);
                b = parseInt(matches2[3], 10);
              } else if (matches2 = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value3)) {
                r = parseInt(matches2[1], 16);
                g = parseInt(matches2[2], 16);
                b = parseInt(matches2[3], 16);
              } else if (matches2 = /#([0-F])([0-F])([0-F])/gi.exec(value3)) {
                r = parseInt(matches2[1] + matches2[1], 16);
                g = parseInt(matches2[2] + matches2[2], 16);
                b = parseInt(matches2[3] + matches2[3], 16);
              }
            }
            r = r < 0 ? 0 : r > 255 ? 255 : r;
            g = g < 0 ? 0 : g > 255 ? 255 : g;
            b = b < 0 ? 0 : b > 255 ? 255 : b;
            return self2;
          };
          if (value2) {
            parse(value2);
          }
          self2.toRgb = toRgb;
          self2.toHsv = toHsv;
          self2.toHex = toHex2;
          self2.parse = parse;
          return self2;
        };
        var serialize = function(o, quote) {
          var i2, v, t, name2;
          quote = quote || '"';
          if (o === null) {
            return "null";
          }
          t = typeof o;
          if (t === "string") {
            v = `\bb	t
n\ff\rr""''\\\\`;
            return quote + o.replace(/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g, function(a, b) {
              if (quote === '"' && a === "'") {
                return a;
              }
              i2 = v.indexOf(b);
              if (i2 + 1) {
                return "\\" + v.charAt(i2 + 1);
              }
              a = b.charCodeAt().toString(16);
              return "\\u" + "0000".substring(a.length) + a;
            }) + quote;
          }
          if (t === "object") {
            if (o.hasOwnProperty && Object.prototype.toString.call(o) === "[object Array]") {
              for (i2 = 0, v = "["; i2 < o.length; i2++) {
                v += (i2 > 0 ? "," : "") + serialize(o[i2], quote);
              }
              return v + "]";
            }
            v = "{";
            for (name2 in o) {
              if (o.hasOwnProperty(name2)) {
                v += typeof o[name2] !== "function" ? (v.length > 1 ? "," + quote : quote) + name2 + quote + ":" + serialize(o[name2], quote) : "";
              }
            }
            return v + "}";
          }
          return "" + o;
        };
        var JSON$1 = {
          serialize,
          parse: function(text) {
            try {
              return JSON.parse(text);
            } catch (ex) {
            }
          }
        };
        var JSONP = {
          callbacks: {},
          count: 0,
          send: function(settings) {
            var self2 = this, dom2 = DOMUtils$1.DOM, count2 = settings.count !== void 0 ? settings.count : self2.count;
            var id = "tinymce_jsonp_" + count2;
            self2.callbacks[count2] = function(json) {
              dom2.remove(id);
              delete self2.callbacks[count2];
              settings.callback(json);
            };
            dom2.add(dom2.doc.body, "script", {
              id,
              src: settings.url,
              type: "text/javascript"
            });
            self2.count++;
          }
        };
        var XHR = {
          send: function(settings) {
            var xhr, count2 = 0;
            var ready = function() {
              if (!settings.async || xhr.readyState === 4 || count2++ > 1e4) {
                if (settings.success && count2 < 1e4 && xhr.status === 200) {
                  settings.success.call(settings.success_scope, "" + xhr.responseText, xhr, settings);
                } else if (settings.error) {
                  settings.error.call(settings.error_scope, count2 > 1e4 ? "TIMED_OUT" : "GENERAL", xhr, settings);
                }
                xhr = null;
              } else {
                setTimeout(ready, 10);
              }
            };
            settings.scope = settings.scope || this;
            settings.success_scope = settings.success_scope || settings.scope;
            settings.error_scope = settings.error_scope || settings.scope;
            settings.async = settings.async === false ? false : true;
            settings.data = settings.data || "";
            XHR.fire("beforeInitialize", { settings });
            xhr = XMLHttpRequest();
            if (xhr) {
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType(settings.content_type);
              }
              xhr.open(settings.type || (settings.data ? "POST" : "GET"), settings.url, settings.async);
              if (settings.crossDomain) {
                xhr.withCredentials = true;
              }
              if (settings.content_type) {
                xhr.setRequestHeader("Content-Type", settings.content_type);
              }
              if (settings.requestheaders) {
                Tools.each(settings.requestheaders, function(header) {
                  xhr.setRequestHeader(header.key, header.value);
                });
              }
              xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
              xhr = XHR.fire("beforeSend", {
                xhr,
                settings
              }).xhr;
              xhr.send(settings.data);
              if (!settings.async) {
                return ready();
              }
              setTimeout(ready, 10);
            }
          }
        };
        Tools.extend(XHR, Observable);
        var extend$7 = Tools.extend;
        var JSONRequest = function(settings) {
          this.settings = extend$7({}, settings);
          this.count = 0;
        };
        JSONRequest.sendRPC = function(o) {
          return new JSONRequest().send(o);
        };
        JSONRequest.prototype = {
          send: function(args) {
            var ecb = args.error, scb = args.success;
            args = extend$7(this.settings, args);
            args.success = function(c, x) {
              c = JSON$1.parse(c);
              if (typeof c === "undefined") {
                c = { error: "JSON Parse error." };
              }
              if (c.error) {
                ecb.call(args.error_scope || args.scope, c.error, x);
              } else {
                scb.call(args.success_scope || args.scope, c.result);
              }
            };
            args.error = function(ty, x) {
              if (ecb) {
                ecb.call(args.error_scope || args.scope, ty, x);
              }
            };
            args.data = JSON$1.serialize({
              id: args.id || "c" + this.count++,
              method: args.method,
              params: args.params
            });
            args.content_type = "application/json";
            XHR.send(args);
          }
        };
        var create$5 = function() {
          return function() {
            var data2 = {};
            var keys2 = [];
            var storage = {
              getItem: function(key) {
                var item = data2[key];
                return item ? item : null;
              },
              setItem: function(key, value2) {
                keys2.push(key);
                data2[key] = String(value2);
              },
              key: function(index) {
                return keys2[index];
              },
              removeItem: function(key) {
                keys2 = keys2.filter(function(k) {
                  return k === key;
                });
                delete data2[key];
              },
              clear: function() {
                keys2 = [];
                data2 = {};
              },
              length: 0
            };
            Object.defineProperty(storage, "length", {
              get: function() {
                return keys2.length;
              },
              configurable: false,
              enumerable: false
            });
            return storage;
          }();
        };
        var localStorage;
        try {
          localStorage = domGlobals.window.localStorage;
        } catch (e) {
          localStorage = create$5();
        }
        var LocalStorage = localStorage;
        var tinymce = EditorManager$1;
        var publicApi = {
          geom: { Rect },
          util: {
            Promise: promiseObj,
            Delay,
            Tools,
            VK,
            URI,
            Class,
            EventDispatcher: Dispatcher,
            Observable,
            I18n,
            XHR,
            JSON: JSON$1,
            JSONRequest,
            JSONP,
            LocalStorage,
            Color
          },
          dom: {
            EventUtils,
            Sizzle,
            DomQuery,
            TreeWalker,
            DOMUtils: DOMUtils$1,
            ScriptLoader,
            RangeUtils: RangeUtils$1,
            Serializer: DomSerializer$1,
            ControlSelection,
            BookmarkManager: BookmarkManager$1,
            Selection: Selection$1,
            Event: EventUtils.Event
          },
          html: {
            Styles,
            Entities,
            Node: Node$1,
            Schema,
            SaxParser: SaxParser$1,
            DomParser,
            Writer,
            Serializer: HtmlSerializer
          },
          ui: { Factory },
          Env,
          AddOnManager,
          Annotator,
          Formatter,
          UndoManager,
          EditorCommands,
          WindowManager,
          NotificationManager,
          EditorObservable: EditorObservable$1,
          Shortcuts,
          Editor,
          FocusManager,
          EditorManager: EditorManager$1,
          DOM: DOMUtils$1.DOM,
          ScriptLoader: ScriptLoader.ScriptLoader,
          PluginManager: AddOnManager.PluginManager,
          ThemeManager: AddOnManager.ThemeManager,
          trim: Tools.trim,
          isArray: Tools.isArray,
          is: Tools.is,
          toArray: Tools.toArray,
          makeMap: Tools.makeMap,
          each: Tools.each,
          map: Tools.map,
          grep: Tools.grep,
          inArray: Tools.inArray,
          extend: Tools.extend,
          create: Tools.create,
          walk: Tools.walk,
          createNS: Tools.createNS,
          resolve: Tools.resolve,
          explode: Tools.explode,
          _addCacheSuffix: Tools._addCacheSuffix,
          isOpera: Env.opera,
          isWebKit: Env.webkit,
          isIE: Env.ie,
          isGecko: Env.gecko,
          isMac: Env.mac
        };
        tinymce = Tools.extend(tinymce, publicApi);
        var Tinymce = tinymce;
        var exportToModuleLoaders = function(tinymce2) {
          if (typeof module === "object") {
            try {
              module.exports = tinymce2;
            } catch (_) {
            }
          }
        };
        var exportToWindowGlobal = function(tinymce2) {
          window.tinymce = tinymce2;
          window.tinyMCE = tinymce2;
        };
        exportToWindowGlobal(Tinymce);
        exportToModuleLoaders(Tinymce);
      })(window);
    })();
  }
});

// dep:tinymce_tinymce
var tinymce_tinymce_default = require_tinymce();
export {
  tinymce_tinymce_default as default
};
//# sourceMappingURL=tinymce_tinymce.js.map
