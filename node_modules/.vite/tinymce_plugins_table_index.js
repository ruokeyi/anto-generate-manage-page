import {
  __commonJS
} from "./chunk-BWTIIPT6.js";

// node_modules/tinymce/plugins/table/plugin.js
var require_plugin = __commonJS({
  "node_modules/tinymce/plugins/table/plugin.js"() {
    (function() {
      var table = function(domGlobals) {
        "use strict";
        var global = tinymce.util.Tools.resolve("tinymce.PluginManager");
        var noop = function() {
        };
        var compose = function(fa, fb) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return fa(fb.apply(null, args));
          };
        };
        var constant = function(value2) {
          return function() {
            return value2;
          };
        };
        var identity = function(x) {
          return x;
        };
        function curry(fn) {
          var initialArgs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            initialArgs[_i - 1] = arguments[_i];
          }
          return function() {
            var restArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              restArgs[_i2] = arguments[_i2];
            }
            var all2 = initialArgs.concat(restArgs);
            return fn.apply(null, all2);
          };
        }
        var not = function(f) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return !f.apply(null, args);
          };
        };
        var die = function(msg) {
          return function() {
            throw new Error(msg);
          };
        };
        var never = constant(false);
        var always = constant(true);
        var none = function() {
          return NONE;
        };
        var NONE = function() {
          var eq2 = function(o) {
            return o.isNone();
          };
          var call = function(thunk) {
            return thunk();
          };
          var id = function(n) {
            return n;
          };
          var me = {
            fold: function(n, s) {
              return n();
            },
            is: never,
            isSome: never,
            isNone: always,
            getOr: id,
            getOrThunk: call,
            getOrDie: function(msg) {
              throw new Error(msg || "error: getOrDie called on none.");
            },
            getOrNull: constant(null),
            getOrUndefined: constant(void 0),
            or: id,
            orThunk: call,
            map: none,
            each: noop,
            bind: none,
            exists: never,
            forall: always,
            filter: none,
            equals: eq2,
            equals_: eq2,
            toArray: function() {
              return [];
            },
            toString: constant("none()")
          };
          if (Object.freeze) {
            Object.freeze(me);
          }
          return me;
        }();
        var some = function(a) {
          var constant_a = constant(a);
          var self = function() {
            return me;
          };
          var bind2 = function(f) {
            return f(a);
          };
          var me = {
            fold: function(n, s) {
              return s(a);
            },
            is: function(v) {
              return a === v;
            },
            isSome: always,
            isNone: never,
            getOr: constant_a,
            getOrThunk: constant_a,
            getOrDie: constant_a,
            getOrNull: constant_a,
            getOrUndefined: constant_a,
            or: self,
            orThunk: self,
            map: function(f) {
              return some(f(a));
            },
            each: function(f) {
              f(a);
            },
            bind: bind2,
            exists: bind2,
            forall: bind2,
            filter: function(f) {
              return f(a) ? me : NONE;
            },
            toArray: function() {
              return [a];
            },
            toString: function() {
              return "some(" + a + ")";
            },
            equals: function(o) {
              return o.is(a);
            },
            equals_: function(o, elementEq) {
              return o.fold(never, function(b) {
                return elementEq(a, b);
              });
            }
          };
          return me;
        };
        var from = function(value2) {
          return value2 === null || value2 === void 0 ? NONE : some(value2);
        };
        var Option = {
          some,
          none,
          from
        };
        var typeOf = function(x) {
          if (x === null) {
            return "null";
          }
          var t = typeof x;
          if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
            return "array";
          }
          if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
            return "string";
          }
          return t;
        };
        var isType = function(type2) {
          return function(value2) {
            return typeOf(value2) === type2;
          };
        };
        var isString = isType("string");
        var isArray = isType("array");
        var isBoolean = isType("boolean");
        var isFunction = isType("function");
        var isNumber = isType("number");
        var nativeSlice = Array.prototype.slice;
        var nativeIndexOf = Array.prototype.indexOf;
        var nativePush = Array.prototype.push;
        var rawIndexOf = function(ts, t) {
          return nativeIndexOf.call(ts, t);
        };
        var contains = function(xs, x) {
          return rawIndexOf(xs, x) > -1;
        };
        var exists = function(xs, pred) {
          for (var i = 0, len = xs.length; i < len; i++) {
            var x = xs[i];
            if (pred(x, i)) {
              return true;
            }
          }
          return false;
        };
        var map = function(xs, f) {
          var len = xs.length;
          var r2 = new Array(len);
          for (var i = 0; i < len; i++) {
            var x = xs[i];
            r2[i] = f(x, i);
          }
          return r2;
        };
        var each = function(xs, f) {
          for (var i = 0, len = xs.length; i < len; i++) {
            var x = xs[i];
            f(x, i);
          }
        };
        var eachr = function(xs, f) {
          for (var i = xs.length - 1; i >= 0; i--) {
            var x = xs[i];
            f(x, i);
          }
        };
        var filter = function(xs, pred) {
          var r2 = [];
          for (var i = 0, len = xs.length; i < len; i++) {
            var x = xs[i];
            if (pred(x, i)) {
              r2.push(x);
            }
          }
          return r2;
        };
        var foldr = function(xs, f, acc) {
          eachr(xs, function(x) {
            acc = f(acc, x);
          });
          return acc;
        };
        var foldl = function(xs, f, acc) {
          each(xs, function(x) {
            acc = f(acc, x);
          });
          return acc;
        };
        var find = function(xs, pred) {
          for (var i = 0, len = xs.length; i < len; i++) {
            var x = xs[i];
            if (pred(x, i)) {
              return Option.some(x);
            }
          }
          return Option.none();
        };
        var findIndex = function(xs, pred) {
          for (var i = 0, len = xs.length; i < len; i++) {
            var x = xs[i];
            if (pred(x, i)) {
              return Option.some(i);
            }
          }
          return Option.none();
        };
        var flatten = function(xs) {
          var r2 = [];
          for (var i = 0, len = xs.length; i < len; ++i) {
            if (!isArray(xs[i])) {
              throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
            }
            nativePush.apply(r2, xs[i]);
          }
          return r2;
        };
        var bind = function(xs, f) {
          var output = map(xs, f);
          return flatten(output);
        };
        var forall = function(xs, pred) {
          for (var i = 0, len = xs.length; i < len; ++i) {
            var x = xs[i];
            if (pred(x, i) !== true) {
              return false;
            }
          }
          return true;
        };
        var reverse = function(xs) {
          var r2 = nativeSlice.call(xs, 0);
          r2.reverse();
          return r2;
        };
        var last = function(xs) {
          return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
        };
        var from$1 = isFunction(Array.from) ? Array.from : function(x) {
          return nativeSlice.call(x);
        };
        var keys = Object.keys;
        var each$1 = function(obj, f) {
          var props = keys(obj);
          for (var k = 0, len = props.length; k < len; k++) {
            var i = props[k];
            var x = obj[i];
            f(x, i);
          }
        };
        var map$1 = function(obj, f) {
          return tupleMap(obj, function(x, i) {
            return {
              k: i,
              v: f(x, i)
            };
          });
        };
        var tupleMap = function(obj, f) {
          var r2 = {};
          each$1(obj, function(x, i) {
            var tuple = f(x, i);
            r2[tuple.k] = tuple.v;
          });
          return r2;
        };
        var Immutable = function() {
          var fields = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            fields[_i] = arguments[_i];
          }
          return function() {
            var values = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              values[_i2] = arguments[_i2];
            }
            if (fields.length !== values.length) {
              throw new Error('Wrong number of arguments to struct. Expected "[' + fields.length + ']", got ' + values.length + " arguments");
            }
            var struct = {};
            each(fields, function(name2, i) {
              struct[name2] = constant(values[i]);
            });
            return struct;
          };
        };
        var sort = function(arr) {
          return arr.slice(0).sort();
        };
        var reqMessage = function(required, keys2) {
          throw new Error("All required keys (" + sort(required).join(", ") + ") were not specified. Specified keys were: " + sort(keys2).join(", ") + ".");
        };
        var unsuppMessage = function(unsupported) {
          throw new Error("Unsupported keys for object: " + sort(unsupported).join(", "));
        };
        var validateStrArr = function(label, array) {
          if (!isArray(array)) {
            throw new Error("The " + label + " fields must be an array. Was: " + array + ".");
          }
          each(array, function(a) {
            if (!isString(a)) {
              throw new Error("The value " + a + " in the " + label + " fields was not a string.");
            }
          });
        };
        var invalidTypeMessage = function(incorrect, type2) {
          throw new Error("All values need to be of type: " + type2 + ". Keys (" + sort(incorrect).join(", ") + ") were not.");
        };
        var checkDupes = function(everything) {
          var sorted = sort(everything);
          var dupe = find(sorted, function(s, i) {
            return i < sorted.length - 1 && s === sorted[i + 1];
          });
          dupe.each(function(d) {
            throw new Error("The field: " + d + " occurs more than once in the combined fields: [" + sorted.join(", ") + "].");
          });
        };
        var MixedBag = function(required, optional) {
          var everything = required.concat(optional);
          if (everything.length === 0) {
            throw new Error("You must specify at least one required or optional field.");
          }
          validateStrArr("required", required);
          validateStrArr("optional", optional);
          checkDupes(everything);
          return function(obj) {
            var keys$1 = keys(obj);
            var allReqd = forall(required, function(req) {
              return contains(keys$1, req);
            });
            if (!allReqd) {
              reqMessage(required, keys$1);
            }
            var unsupported = filter(keys$1, function(key2) {
              return !contains(everything, key2);
            });
            if (unsupported.length > 0) {
              unsuppMessage(unsupported);
            }
            var r2 = {};
            each(required, function(req) {
              r2[req] = constant(obj[req]);
            });
            each(optional, function(opt) {
              r2[opt] = constant(Object.prototype.hasOwnProperty.call(obj, opt) ? Option.some(obj[opt]) : Option.none());
            });
            return r2;
          };
        };
        var ATTRIBUTE = domGlobals.Node.ATTRIBUTE_NODE;
        var CDATA_SECTION = domGlobals.Node.CDATA_SECTION_NODE;
        var COMMENT = domGlobals.Node.COMMENT_NODE;
        var DOCUMENT = domGlobals.Node.DOCUMENT_NODE;
        var DOCUMENT_TYPE = domGlobals.Node.DOCUMENT_TYPE_NODE;
        var DOCUMENT_FRAGMENT = domGlobals.Node.DOCUMENT_FRAGMENT_NODE;
        var ELEMENT = domGlobals.Node.ELEMENT_NODE;
        var TEXT = domGlobals.Node.TEXT_NODE;
        var PROCESSING_INSTRUCTION = domGlobals.Node.PROCESSING_INSTRUCTION_NODE;
        var ENTITY_REFERENCE = domGlobals.Node.ENTITY_REFERENCE_NODE;
        var ENTITY = domGlobals.Node.ENTITY_NODE;
        var NOTATION = domGlobals.Node.NOTATION_NODE;
        var Global = typeof domGlobals.window !== "undefined" ? domGlobals.window : Function("return this;")();
        var path = function(parts, scope) {
          var o = scope !== void 0 && scope !== null ? scope : Global;
          for (var i = 0; i < parts.length && o !== void 0 && o !== null; ++i) {
            o = o[parts[i]];
          }
          return o;
        };
        var resolve = function(p, scope) {
          var parts = p.split(".");
          return path(parts, scope);
        };
        var unsafe = function(name2, scope) {
          return resolve(name2, scope);
        };
        var getOrDie = function(name2, scope) {
          var actual = unsafe(name2, scope);
          if (actual === void 0 || actual === null) {
            throw new Error(name2 + " not available on this browser");
          }
          return actual;
        };
        var Global$1 = { getOrDie };
        var name = function(element) {
          var r2 = element.dom().nodeName;
          return r2.toLowerCase();
        };
        var type = function(element) {
          return element.dom().nodeType;
        };
        var isType$1 = function(t) {
          return function(element) {
            return type(element) === t;
          };
        };
        var isComment = function(element) {
          return type(element) === COMMENT || name(element) === "#comment";
        };
        var isElement = isType$1(ELEMENT);
        var isText = isType$1(TEXT);
        var rawSet = function(dom, key2, value2) {
          if (isString(value2) || isBoolean(value2) || isNumber(value2)) {
            dom.setAttribute(key2, value2 + "");
          } else {
            domGlobals.console.error("Invalid call to Attr.set. Key ", key2, ":: Value ", value2, ":: Element ", dom);
            throw new Error("Attribute value was not simple");
          }
        };
        var set = function(element, key2, value2) {
          rawSet(element.dom(), key2, value2);
        };
        var setAll = function(element, attrs) {
          var dom = element.dom();
          each$1(attrs, function(v, k) {
            rawSet(dom, k, v);
          });
        };
        var get = function(element, key2) {
          var v = element.dom().getAttribute(key2);
          return v === null ? void 0 : v;
        };
        var has = function(element, key2) {
          var dom = element.dom();
          return dom && dom.hasAttribute ? dom.hasAttribute(key2) : false;
        };
        var remove = function(element, key2) {
          element.dom().removeAttribute(key2);
        };
        var clone = function(element) {
          return foldl(element.dom().attributes, function(acc, attr2) {
            acc[attr2.name] = attr2.value;
            return acc;
          }, {});
        };
        var checkRange = function(str, substr, start) {
          if (substr === "") {
            return true;
          }
          if (str.length < substr.length) {
            return false;
          }
          var x = str.substr(start, start + substr.length);
          return x === substr;
        };
        var contains$1 = function(str, substr) {
          return str.indexOf(substr) !== -1;
        };
        var endsWith = function(str, suffix) {
          return checkRange(str, suffix, str.length - suffix.length);
        };
        var trim = function(str) {
          return str.replace(/^\s+|\s+$/g, "");
        };
        var isSupported = function(dom) {
          return dom.style !== void 0 && isFunction(dom.style.getPropertyValue);
        };
        var cached = function(f) {
          var called = false;
          var r2;
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (!called) {
              called = true;
              r2 = f.apply(null, args);
            }
            return r2;
          };
        };
        var fromHtml = function(html, scope) {
          var doc = scope || domGlobals.document;
          var div = doc.createElement("div");
          div.innerHTML = html;
          if (!div.hasChildNodes() || div.childNodes.length > 1) {
            domGlobals.console.error("HTML does not have a single root node", html);
            throw new Error("HTML must have a single root node");
          }
          return fromDom(div.childNodes[0]);
        };
        var fromTag = function(tag, scope) {
          var doc = scope || domGlobals.document;
          var node2 = doc.createElement(tag);
          return fromDom(node2);
        };
        var fromText = function(text2, scope) {
          var doc = scope || domGlobals.document;
          var node2 = doc.createTextNode(text2);
          return fromDom(node2);
        };
        var fromDom = function(node2) {
          if (node2 === null || node2 === void 0) {
            throw new Error("Node cannot be null or undefined");
          }
          return { dom: constant(node2) };
        };
        var fromPoint = function(docElm, x, y) {
          var doc = docElm.dom();
          return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
        };
        var Element = {
          fromHtml,
          fromTag,
          fromText,
          fromDom,
          fromPoint
        };
        var inBody = function(element) {
          var dom = isText(element) ? element.dom().parentNode : element.dom();
          return dom !== void 0 && dom !== null && dom.ownerDocument.body.contains(dom);
        };
        var body = cached(function() {
          return getBody(Element.fromDom(domGlobals.document));
        });
        var getBody = function(doc) {
          var b = doc.dom().body;
          if (b === null || b === void 0) {
            throw new Error("Body is not available yet");
          }
          return Element.fromDom(b);
        };
        var internalSet = function(dom, property, value2) {
          if (!isString(value2)) {
            domGlobals.console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom);
            throw new Error("CSS value must be a string: " + value2);
          }
          if (isSupported(dom)) {
            dom.style.setProperty(property, value2);
          }
        };
        var internalRemove = function(dom, property) {
          if (isSupported(dom)) {
            dom.style.removeProperty(property);
          }
        };
        var set$1 = function(element, property, value2) {
          var dom = element.dom();
          internalSet(dom, property, value2);
        };
        var setAll$1 = function(element, css2) {
          var dom = element.dom();
          each$1(css2, function(v, k) {
            internalSet(dom, k, v);
          });
        };
        var get$1 = function(element, property) {
          var dom = element.dom();
          var styles2 = domGlobals.window.getComputedStyle(dom);
          var r2 = styles2.getPropertyValue(property);
          var v = r2 === "" && !inBody(element) ? getUnsafeProperty(dom, property) : r2;
          return v === null ? void 0 : v;
        };
        var getUnsafeProperty = function(dom, property) {
          return isSupported(dom) ? dom.style.getPropertyValue(property) : "";
        };
        var getRaw = function(element, property) {
          var dom = element.dom();
          var raw = getUnsafeProperty(dom, property);
          return Option.from(raw).filter(function(r2) {
            return r2.length > 0;
          });
        };
        var remove$1 = function(element, property) {
          var dom = element.dom();
          internalRemove(dom, property);
          if (has(element, "style") && trim(get(element, "style")) === "") {
            remove(element, "style");
          }
        };
        var copy = function(source, target) {
          var sourceDom = source.dom();
          var targetDom = target.dom();
          if (isSupported(sourceDom) && isSupported(targetDom)) {
            targetDom.style.cssText = sourceDom.style.cssText;
          }
        };
        var node = function() {
          var f = Global$1.getOrDie("Node");
          return f;
        };
        var compareDocumentPosition = function(a, b, match) {
          return (a.compareDocumentPosition(b) & match) !== 0;
        };
        var documentPositionPreceding = function(a, b) {
          return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
        };
        var documentPositionContainedBy = function(a, b) {
          return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
        };
        var Node = {
          documentPositionPreceding,
          documentPositionContainedBy
        };
        var firstMatch = function(regexes, s) {
          for (var i = 0; i < regexes.length; i++) {
            var x = regexes[i];
            if (x.test(s)) {
              return x;
            }
          }
          return void 0;
        };
        var find$1 = function(regexes, agent) {
          var r2 = firstMatch(regexes, agent);
          if (!r2) {
            return {
              major: 0,
              minor: 0
            };
          }
          var group = function(i) {
            return Number(agent.replace(r2, "$" + i));
          };
          return nu(group(1), group(2));
        };
        var detect = function(versionRegexes, agent) {
          var cleanedAgent = String(agent).toLowerCase();
          if (versionRegexes.length === 0) {
            return unknown();
          }
          return find$1(versionRegexes, cleanedAgent);
        };
        var unknown = function() {
          return nu(0, 0);
        };
        var nu = function(major, minor) {
          return {
            major,
            minor
          };
        };
        var Version = {
          nu,
          detect,
          unknown
        };
        var edge = "Edge";
        var chrome = "Chrome";
        var ie = "IE";
        var opera = "Opera";
        var firefox = "Firefox";
        var safari = "Safari";
        var isBrowser = function(name2, current) {
          return function() {
            return current === name2;
          };
        };
        var unknown$1 = function() {
          return nu$1({
            current: void 0,
            version: Version.unknown()
          });
        };
        var nu$1 = function(info) {
          var current = info.current;
          var version = info.version;
          return {
            current,
            version,
            isEdge: isBrowser(edge, current),
            isChrome: isBrowser(chrome, current),
            isIE: isBrowser(ie, current),
            isOpera: isBrowser(opera, current),
            isFirefox: isBrowser(firefox, current),
            isSafari: isBrowser(safari, current)
          };
        };
        var Browser = {
          unknown: unknown$1,
          nu: nu$1,
          edge: constant(edge),
          chrome: constant(chrome),
          ie: constant(ie),
          opera: constant(opera),
          firefox: constant(firefox),
          safari: constant(safari)
        };
        var windows = "Windows";
        var ios = "iOS";
        var android = "Android";
        var linux = "Linux";
        var osx = "OSX";
        var solaris = "Solaris";
        var freebsd = "FreeBSD";
        var isOS = function(name2, current) {
          return function() {
            return current === name2;
          };
        };
        var unknown$2 = function() {
          return nu$2({
            current: void 0,
            version: Version.unknown()
          });
        };
        var nu$2 = function(info) {
          var current = info.current;
          var version = info.version;
          return {
            current,
            version,
            isWindows: isOS(windows, current),
            isiOS: isOS(ios, current),
            isAndroid: isOS(android, current),
            isOSX: isOS(osx, current),
            isLinux: isOS(linux, current),
            isSolaris: isOS(solaris, current),
            isFreeBSD: isOS(freebsd, current)
          };
        };
        var OperatingSystem = {
          unknown: unknown$2,
          nu: nu$2,
          windows: constant(windows),
          ios: constant(ios),
          android: constant(android),
          linux: constant(linux),
          osx: constant(osx),
          solaris: constant(solaris),
          freebsd: constant(freebsd)
        };
        var DeviceType = function(os, browser2, userAgent) {
          var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
          var isiPhone = os.isiOS() && !isiPad;
          var isAndroid3 = os.isAndroid() && os.version.major === 3;
          var isAndroid4 = os.isAndroid() && os.version.major === 4;
          var isTablet = isiPad || isAndroid3 || isAndroid4 && /mobile/i.test(userAgent) === true;
          var isTouch = os.isiOS() || os.isAndroid();
          var isPhone = isTouch && !isTablet;
          var iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
          return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet),
            isPhone: constant(isPhone),
            isTouch: constant(isTouch),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant(iOSwebview)
          };
        };
        var detect$1 = function(candidates, userAgent) {
          var agent = String(userAgent).toLowerCase();
          return find(candidates, function(candidate) {
            return candidate.search(agent);
          });
        };
        var detectBrowser = function(browsers2, userAgent) {
          return detect$1(browsers2, userAgent).map(function(browser2) {
            var version = Version.detect(browser2.versionRegexes, userAgent);
            return {
              current: browser2.name,
              version
            };
          });
        };
        var detectOs = function(oses2, userAgent) {
          return detect$1(oses2, userAgent).map(function(os) {
            var version = Version.detect(os.versionRegexes, userAgent);
            return {
              current: os.name,
              version
            };
          });
        };
        var UaString = {
          detectBrowser,
          detectOs
        };
        var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
        var checkContains = function(target) {
          return function(uastring) {
            return contains$1(uastring, target);
          };
        };
        var browsers = [
          {
            name: "Edge",
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search: function(uastring) {
              return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
            }
          },
          {
            name: "Chrome",
            versionRegexes: [
              /.*?chrome\/([0-9]+)\.([0-9]+).*/,
              normalVersionRegex
            ],
            search: function(uastring) {
              return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
            }
          },
          {
            name: "IE",
            versionRegexes: [
              /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
              /.*?rv:([0-9]+)\.([0-9]+).*/
            ],
            search: function(uastring) {
              return contains$1(uastring, "msie") || contains$1(uastring, "trident");
            }
          },
          {
            name: "Opera",
            versionRegexes: [
              normalVersionRegex,
              /.*?opera\/([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains("opera")
          },
          {
            name: "Firefox",
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains("firefox")
          },
          {
            name: "Safari",
            versionRegexes: [
              normalVersionRegex,
              /.*?cpu os ([0-9]+)_([0-9]+).*/
            ],
            search: function(uastring) {
              return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
            }
          }
        ];
        var oses = [
          {
            name: "Windows",
            search: checkContains("win"),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "iOS",
            search: function(uastring) {
              return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
            },
            versionRegexes: [
              /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
              /.*cpu os ([0-9]+)_([0-9]+).*/,
              /.*cpu iphone os ([0-9]+)_([0-9]+).*/
            ]
          },
          {
            name: "Android",
            search: checkContains("android"),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "OSX",
            search: checkContains("os x"),
            versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
          },
          {
            name: "Linux",
            search: checkContains("linux"),
            versionRegexes: []
          },
          {
            name: "Solaris",
            search: checkContains("sunos"),
            versionRegexes: []
          },
          {
            name: "FreeBSD",
            search: checkContains("freebsd"),
            versionRegexes: []
          }
        ];
        var PlatformInfo = {
          browsers: constant(browsers),
          oses: constant(oses)
        };
        var detect$2 = function(userAgent) {
          var browsers2 = PlatformInfo.browsers();
          var oses2 = PlatformInfo.oses();
          var browser2 = UaString.detectBrowser(browsers2, userAgent).fold(Browser.unknown, Browser.nu);
          var os = UaString.detectOs(oses2, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
          var deviceType = DeviceType(os, browser2, userAgent);
          return {
            browser: browser2,
            os,
            deviceType
          };
        };
        var PlatformDetection = { detect: detect$2 };
        var detect$3 = cached(function() {
          var userAgent = domGlobals.navigator.userAgent;
          return PlatformDetection.detect(userAgent);
        });
        var PlatformDetection$1 = { detect: detect$3 };
        var ELEMENT$1 = ELEMENT;
        var DOCUMENT$1 = DOCUMENT;
        var is = function(element, selector) {
          var dom = element.dom();
          if (dom.nodeType !== ELEMENT$1) {
            return false;
          } else {
            var elem = dom;
            if (elem.matches !== void 0) {
              return elem.matches(selector);
            } else if (elem.msMatchesSelector !== void 0) {
              return elem.msMatchesSelector(selector);
            } else if (elem.webkitMatchesSelector !== void 0) {
              return elem.webkitMatchesSelector(selector);
            } else if (elem.mozMatchesSelector !== void 0) {
              return elem.mozMatchesSelector(selector);
            } else {
              throw new Error("Browser lacks native selectors");
            }
          }
        };
        var bypassSelector = function(dom) {
          return dom.nodeType !== ELEMENT$1 && dom.nodeType !== DOCUMENT$1 || dom.childElementCount === 0;
        };
        var all = function(selector, scope) {
          var base2 = scope === void 0 ? domGlobals.document : scope.dom();
          return bypassSelector(base2) ? [] : map(base2.querySelectorAll(selector), Element.fromDom);
        };
        var one = function(selector, scope) {
          var base2 = scope === void 0 ? domGlobals.document : scope.dom();
          return bypassSelector(base2) ? Option.none() : Option.from(base2.querySelector(selector)).map(Element.fromDom);
        };
        var eq = function(e1, e2) {
          return e1.dom() === e2.dom();
        };
        var regularContains = function(e1, e2) {
          var d1 = e1.dom();
          var d2 = e2.dom();
          return d1 === d2 ? false : d1.contains(d2);
        };
        var ieContains = function(e1, e2) {
          return Node.documentPositionContainedBy(e1.dom(), e2.dom());
        };
        var browser = PlatformDetection$1.detect().browser;
        var contains$2 = browser.isIE() ? ieContains : regularContains;
        var is$1 = is;
        var owner = function(element) {
          return Element.fromDom(element.dom().ownerDocument);
        };
        var defaultView = function(element) {
          return Element.fromDom(element.dom().ownerDocument.defaultView);
        };
        var parent = function(element) {
          return Option.from(element.dom().parentNode).map(Element.fromDom);
        };
        var parents = function(element, isRoot) {
          var stop = isFunction(isRoot) ? isRoot : never;
          var dom = element.dom();
          var ret = [];
          while (dom.parentNode !== null && dom.parentNode !== void 0) {
            var rawParent = dom.parentNode;
            var p = Element.fromDom(rawParent);
            ret.push(p);
            if (stop(p) === true) {
              break;
            } else {
              dom = rawParent;
            }
          }
          return ret;
        };
        var prevSibling = function(element) {
          return Option.from(element.dom().previousSibling).map(Element.fromDom);
        };
        var nextSibling = function(element) {
          return Option.from(element.dom().nextSibling).map(Element.fromDom);
        };
        var children = function(element) {
          return map(element.dom().childNodes, Element.fromDom);
        };
        var child = function(element, index) {
          var cs = element.dom().childNodes;
          return Option.from(cs[index]).map(Element.fromDom);
        };
        var firstChild = function(element) {
          return child(element, 0);
        };
        var spot = Immutable("element", "offset");
        var before = function(marker, element) {
          var parent$1 = parent(marker);
          parent$1.each(function(v) {
            v.dom().insertBefore(element.dom(), marker.dom());
          });
        };
        var after = function(marker, element) {
          var sibling = nextSibling(marker);
          sibling.fold(function() {
            var parent$1 = parent(marker);
            parent$1.each(function(v) {
              append(v, element);
            });
          }, function(v) {
            before(v, element);
          });
        };
        var prepend = function(parent2, element) {
          var firstChild$1 = firstChild(parent2);
          firstChild$1.fold(function() {
            append(parent2, element);
          }, function(v) {
            parent2.dom().insertBefore(element.dom(), v.dom());
          });
        };
        var append = function(parent2, element) {
          parent2.dom().appendChild(element.dom());
        };
        var wrap = function(element, wrapper) {
          before(element, wrapper);
          append(wrapper, element);
        };
        var before$1 = function(marker, elements) {
          each(elements, function(x) {
            before(marker, x);
          });
        };
        var after$1 = function(marker, elements) {
          each(elements, function(x, i) {
            var e = i === 0 ? marker : elements[i - 1];
            after(e, x);
          });
        };
        var append$1 = function(parent2, elements) {
          each(elements, function(x) {
            append(parent2, x);
          });
        };
        var empty = function(element) {
          element.dom().textContent = "";
          each(children(element), function(rogue) {
            remove$2(rogue);
          });
        };
        var remove$2 = function(element) {
          var dom = element.dom();
          if (dom.parentNode !== null) {
            dom.parentNode.removeChild(dom);
          }
        };
        var unwrap = function(wrapper) {
          var children$12 = children(wrapper);
          if (children$12.length > 0) {
            before$1(wrapper, children$12);
          }
          remove$2(wrapper);
        };
        var dimension = Immutable("width", "height");
        var dimensions = Immutable("width", "height");
        var grid = Immutable("rows", "columns");
        var address = Immutable("row", "column");
        var coords = Immutable("x", "y");
        var detail = Immutable("element", "rowspan", "colspan");
        var detailnew = Immutable("element", "rowspan", "colspan", "isNew");
        var extended = Immutable("element", "rowspan", "colspan", "row", "column");
        var rowdata = Immutable("element", "cells", "section");
        var elementnew = Immutable("element", "isNew");
        var rowdatanew = Immutable("element", "cells", "section", "isNew");
        var rowcells = Immutable("cells", "section");
        var rowdetails = Immutable("details", "section");
        var bounds = Immutable("startRow", "startCol", "finishRow", "finishCol");
        var ancestors = function(scope, predicate, isRoot) {
          return filter(parents(scope, isRoot), predicate);
        };
        var children$1 = function(scope, predicate) {
          return filter(children(scope), predicate);
        };
        var descendants = function(scope, predicate) {
          var result = [];
          each(children(scope), function(x) {
            if (predicate(x)) {
              result = result.concat([x]);
            }
            result = result.concat(descendants(x, predicate));
          });
          return result;
        };
        var ancestors$1 = function(scope, selector, isRoot) {
          return ancestors(scope, function(e) {
            return is(e, selector);
          }, isRoot);
        };
        var children$2 = function(scope, selector) {
          return children$1(scope, function(e) {
            return is(e, selector);
          });
        };
        var descendants$1 = function(scope, selector) {
          return all(selector, scope);
        };
        function ClosestOrAncestor(is2, ancestor2, scope, a, isRoot) {
          return is2(scope, a) ? Option.some(scope) : isFunction(isRoot) && isRoot(scope) ? Option.none() : ancestor2(scope, a, isRoot);
        }
        var ancestor = function(scope, predicate, isRoot) {
          var element = scope.dom();
          var stop = isFunction(isRoot) ? isRoot : constant(false);
          while (element.parentNode) {
            element = element.parentNode;
            var el = Element.fromDom(element);
            if (predicate(el)) {
              return Option.some(el);
            } else if (stop(el)) {
              break;
            }
          }
          return Option.none();
        };
        var closest = function(scope, predicate, isRoot) {
          var is2 = function(s, test) {
            return test(s);
          };
          return ClosestOrAncestor(is2, ancestor, scope, predicate, isRoot);
        };
        var child$1 = function(scope, predicate) {
          var pred = function(node2) {
            return predicate(Element.fromDom(node2));
          };
          var result = find(scope.dom().childNodes, pred);
          return result.map(Element.fromDom);
        };
        var descendant = function(scope, predicate) {
          var descend = function(node2) {
            for (var i = 0; i < node2.childNodes.length; i++) {
              var child_1 = Element.fromDom(node2.childNodes[i]);
              if (predicate(child_1)) {
                return Option.some(child_1);
              }
              var res = descend(node2.childNodes[i]);
              if (res.isSome()) {
                return res;
              }
            }
            return Option.none();
          };
          return descend(scope.dom());
        };
        var ancestor$1 = function(scope, selector, isRoot) {
          return ancestor(scope, function(e) {
            return is(e, selector);
          }, isRoot);
        };
        var child$2 = function(scope, selector) {
          return child$1(scope, function(e) {
            return is(e, selector);
          });
        };
        var descendant$1 = function(scope, selector) {
          return one(selector, scope);
        };
        var closest$1 = function(scope, selector, isRoot) {
          return ClosestOrAncestor(is, ancestor$1, scope, selector, isRoot);
        };
        var firstLayer = function(scope, selector) {
          return filterFirstLayer(scope, selector, constant(true));
        };
        var filterFirstLayer = function(scope, selector, predicate) {
          return bind(children(scope), function(x) {
            return is(x, selector) ? predicate(x) ? [x] : [] : filterFirstLayer(x, selector, predicate);
          });
        };
        var LayerSelector = {
          firstLayer,
          filterFirstLayer
        };
        var lookup = function(tags, element, isRoot) {
          if (isRoot === void 0) {
            isRoot = never;
          }
          if (isRoot(element)) {
            return Option.none();
          }
          if (contains(tags, name(element))) {
            return Option.some(element);
          }
          var isRootOrUpperTable = function(elm) {
            return is(elm, "table") || isRoot(elm);
          };
          return ancestor$1(element, tags.join(","), isRootOrUpperTable);
        };
        var cell = function(element, isRoot) {
          return lookup([
            "td",
            "th"
          ], element, isRoot);
        };
        var cells = function(ancestor2) {
          return LayerSelector.firstLayer(ancestor2, "th,td");
        };
        var notCell = function(element, isRoot) {
          return lookup([
            "caption",
            "tr",
            "tbody",
            "tfoot",
            "thead"
          ], element, isRoot);
        };
        var neighbours = function(selector, element) {
          return parent(element).map(function(parent2) {
            return children$2(parent2, selector);
          });
        };
        var neighbourCells = curry(neighbours, "th,td");
        var neighbourRows = curry(neighbours, "tr");
        var firstCell = function(ancestor2) {
          return descendant$1(ancestor2, "th,td");
        };
        var table2 = function(element, isRoot) {
          return closest$1(element, "table", isRoot);
        };
        var row = function(element, isRoot) {
          return lookup(["tr"], element, isRoot);
        };
        var rows = function(ancestor2) {
          return LayerSelector.firstLayer(ancestor2, "tr");
        };
        var attr = function(element, property) {
          return parseInt(get(element, property), 10);
        };
        var grid$1 = function(element, rowProp, colProp) {
          var rowsCount = attr(element, rowProp);
          var cols = attr(element, colProp);
          return grid(rowsCount, cols);
        };
        var TableLookup = {
          cell,
          firstCell,
          cells,
          neighbourCells,
          table: table2,
          row,
          rows,
          notCell,
          neighbourRows,
          attr,
          grid: grid$1
        };
        var fromTable = function(table3) {
          var rows2 = TableLookup.rows(table3);
          return map(rows2, function(row2) {
            var element = row2;
            var parent$1 = parent(element);
            var parentSection = parent$1.map(function(p) {
              var parentName = name(p);
              return parentName === "tfoot" || parentName === "thead" || parentName === "tbody" ? parentName : "tbody";
            }).getOr("tbody");
            var cells2 = map(TableLookup.cells(row2), function(cell2) {
              var rowspan = has(cell2, "rowspan") ? parseInt(get(cell2, "rowspan"), 10) : 1;
              var colspan = has(cell2, "colspan") ? parseInt(get(cell2, "colspan"), 10) : 1;
              return detail(cell2, rowspan, colspan);
            });
            return rowdata(element, cells2, parentSection);
          });
        };
        var fromPastedRows = function(rows2, example) {
          return map(rows2, function(row2) {
            var cells2 = map(TableLookup.cells(row2), function(cell2) {
              var rowspan = has(cell2, "rowspan") ? parseInt(get(cell2, "rowspan"), 10) : 1;
              var colspan = has(cell2, "colspan") ? parseInt(get(cell2, "colspan"), 10) : 1;
              return detail(cell2, rowspan, colspan);
            });
            return rowdata(row2, cells2, example.section());
          });
        };
        var DetailsList = {
          fromTable,
          fromPastedRows
        };
        var key = function(row2, column) {
          return row2 + "," + column;
        };
        var getAt = function(warehouse, row2, column) {
          var raw = warehouse.access()[key(row2, column)];
          return raw !== void 0 ? Option.some(raw) : Option.none();
        };
        var findItem = function(warehouse, item, comparator) {
          var filtered = filterItems(warehouse, function(detail2) {
            return comparator(item, detail2.element());
          });
          return filtered.length > 0 ? Option.some(filtered[0]) : Option.none();
        };
        var filterItems = function(warehouse, predicate) {
          var all2 = bind(warehouse.all(), function(r2) {
            return r2.cells();
          });
          return filter(all2, predicate);
        };
        var generate = function(list) {
          var access = {};
          var cells2 = [];
          var maxRows = list.length;
          var maxColumns = 0;
          each(list, function(details, r2) {
            var currentRow = [];
            each(details.cells(), function(detail2) {
              var start = 0;
              while (access[key(r2, start)] !== void 0) {
                start++;
              }
              var current = extended(detail2.element(), detail2.rowspan(), detail2.colspan(), r2, start);
              for (var i = 0; i < detail2.colspan(); i++) {
                for (var j = 0; j < detail2.rowspan(); j++) {
                  var cr = r2 + j;
                  var cc = start + i;
                  var newpos = key(cr, cc);
                  access[newpos] = current;
                  maxColumns = Math.max(maxColumns, cc + 1);
                }
              }
              currentRow.push(current);
            });
            cells2.push(rowdata(details.element(), currentRow, details.section()));
          });
          var grid$12 = grid(maxRows, maxColumns);
          return {
            grid: constant(grid$12),
            access: constant(access),
            all: constant(cells2)
          };
        };
        var justCells = function(warehouse) {
          var rows2 = map(warehouse.all(), function(w) {
            return w.cells();
          });
          return flatten(rows2);
        };
        var Warehouse = {
          generate,
          getAt,
          findItem,
          filterItems,
          justCells
        };
        var statsStruct = Immutable("minRow", "minCol", "maxRow", "maxCol");
        var findSelectedStats = function(house, isSelected) {
          var totalColumns = house.grid().columns();
          var totalRows = house.grid().rows();
          var minRow = totalRows;
          var minCol = totalColumns;
          var maxRow = 0;
          var maxCol = 0;
          each$1(house.access(), function(detail2) {
            if (isSelected(detail2)) {
              var startRow = detail2.row();
              var endRow = startRow + detail2.rowspan() - 1;
              var startCol = detail2.column();
              var endCol = startCol + detail2.colspan() - 1;
              if (startRow < minRow) {
                minRow = startRow;
              } else if (endRow > maxRow) {
                maxRow = endRow;
              }
              if (startCol < minCol) {
                minCol = startCol;
              } else if (endCol > maxCol) {
                maxCol = endCol;
              }
            }
          });
          return statsStruct(minRow, minCol, maxRow, maxCol);
        };
        var makeCell = function(list, seenSelected, rowIndex) {
          var row2 = list[rowIndex].element();
          var td = Element.fromTag("td");
          append(td, Element.fromTag("br"));
          var f = seenSelected ? append : prepend;
          f(row2, td);
        };
        var fillInGaps = function(list, house, stats, isSelected) {
          var totalColumns = house.grid().columns();
          var totalRows = house.grid().rows();
          for (var i = 0; i < totalRows; i++) {
            var seenSelected = false;
            for (var j = 0; j < totalColumns; j++) {
              if (!(i < stats.minRow() || i > stats.maxRow() || j < stats.minCol() || j > stats.maxCol())) {
                var needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();
                if (needCell) {
                  makeCell(list, seenSelected, i);
                } else {
                  seenSelected = true;
                }
              }
            }
          }
        };
        var clean = function(table3, stats) {
          var emptyRows = filter(LayerSelector.firstLayer(table3, "tr"), function(row2) {
            return row2.dom().childElementCount === 0;
          });
          each(emptyRows, remove$2);
          if (stats.minCol() === stats.maxCol() || stats.minRow() === stats.maxRow()) {
            each(LayerSelector.firstLayer(table3, "th,td"), function(cell2) {
              remove(cell2, "rowspan");
              remove(cell2, "colspan");
            });
          }
          remove(table3, "width");
          remove(table3, "height");
          remove$1(table3, "width");
          remove$1(table3, "height");
        };
        var extract = function(table3, selectedSelector2) {
          var isSelected = function(detail2) {
            return is(detail2.element(), selectedSelector2);
          };
          var list = DetailsList.fromTable(table3);
          var house = Warehouse.generate(list);
          var stats = findSelectedStats(house, isSelected);
          var selector = "th:not(" + selectedSelector2 + "),td:not(" + selectedSelector2 + ")";
          var unselectedCells = LayerSelector.filterFirstLayer(table3, "th,td", function(cell2) {
            return is(cell2, selector);
          });
          each(unselectedCells, remove$2);
          fillInGaps(list, house, stats, isSelected);
          clean(table3, stats);
          return table3;
        };
        var CopySelected = { extract };
        function NodeValue(is2, name2) {
          var get2 = function(element) {
            if (!is2(element)) {
              throw new Error("Can only get " + name2 + " value of a " + name2 + " node");
            }
            return getOption2(element).getOr("");
          };
          var getOption2 = function(element) {
            return is2(element) ? Option.from(element.dom().nodeValue) : Option.none();
          };
          var set2 = function(element, value2) {
            if (!is2(element)) {
              throw new Error("Can only set raw " + name2 + " value of a " + name2 + " node");
            }
            element.dom().nodeValue = value2;
          };
          return {
            get: get2,
            getOption: getOption2,
            set: set2
          };
        }
        var api = NodeValue(isText, "text");
        var get$2 = function(element) {
          return api.get(element);
        };
        var getOption = function(element) {
          return api.getOption(element);
        };
        var set$2 = function(element, value2) {
          api.set(element, value2);
        };
        var getEnd = function(element) {
          return name(element) === "img" ? 1 : getOption(element).fold(function() {
            return children(element).length;
          }, function(v) {
            return v.length;
          });
        };
        var NBSP = "\xA0";
        var isTextNodeWithCursorPosition = function(el) {
          return getOption(el).filter(function(text2) {
            return text2.trim().length !== 0 || text2.indexOf(NBSP) > -1;
          }).isSome();
        };
        var elementsWithCursorPosition = [
          "img",
          "br"
        ];
        var isCursorPosition = function(elem) {
          var hasCursorPosition = isTextNodeWithCursorPosition(elem);
          return hasCursorPosition || contains(elementsWithCursorPosition, name(elem));
        };
        var first = function(element) {
          return descendant(element, isCursorPosition);
        };
        var last$1 = function(element) {
          return descendantRtl(element, isCursorPosition);
        };
        var descendantRtl = function(scope, predicate) {
          var descend = function(element) {
            var children$12 = children(element);
            for (var i = children$12.length - 1; i >= 0; i--) {
              var child2 = children$12[i];
              if (predicate(child2)) {
                return Option.some(child2);
              }
              var res = descend(child2);
              if (res.isSome()) {
                return res;
              }
            }
            return Option.none();
          };
          return descend(scope);
        };
        var clone$1 = function(original, isDeep) {
          return Element.fromDom(original.dom().cloneNode(isDeep));
        };
        var shallow = function(original) {
          return clone$1(original, false);
        };
        var deep = function(original) {
          return clone$1(original, true);
        };
        var shallowAs = function(original, tag) {
          var nu2 = Element.fromTag(tag);
          var attributes = clone(original);
          setAll(nu2, attributes);
          return nu2;
        };
        var copy$1 = function(original, tag) {
          var nu2 = shallowAs(original, tag);
          var cloneChildren = children(deep(original));
          append$1(nu2, cloneChildren);
          return nu2;
        };
        var createCell = function() {
          var td = Element.fromTag("td");
          append(td, Element.fromTag("br"));
          return td;
        };
        var replace = function(cell2, tag, attrs) {
          var replica = copy$1(cell2, tag);
          each$1(attrs, function(v, k) {
            if (v === null) {
              remove(replica, k);
            } else {
              set(replica, k, v);
            }
          });
          return replica;
        };
        var pasteReplace = function(cell2) {
          return cell2;
        };
        var newRow = function(doc) {
          return function() {
            return Element.fromTag("tr", doc.dom());
          };
        };
        var cloneFormats = function(oldCell, newCell, formats) {
          var first$1 = first(oldCell);
          return first$1.map(function(firstText) {
            var formatSelector = formats.join(",");
            var parents2 = ancestors$1(firstText, formatSelector, function(element) {
              return eq(element, oldCell);
            });
            return foldr(parents2, function(last2, parent2) {
              var clonedFormat = shallow(parent2);
              remove(clonedFormat, "contenteditable");
              append(last2, clonedFormat);
              return clonedFormat;
            }, newCell);
          }).getOr(newCell);
        };
        var cellOperations = function(mutate2, doc, formatsToClone) {
          var newCell = function(prev2) {
            var docu = owner(prev2.element());
            var td = Element.fromTag(name(prev2.element()), docu.dom());
            var formats = formatsToClone.getOr([
              "strong",
              "em",
              "b",
              "i",
              "span",
              "font",
              "h1",
              "h2",
              "h3",
              "h4",
              "h5",
              "h6",
              "p",
              "div"
            ]);
            var lastNode = formats.length > 0 ? cloneFormats(prev2.element(), td, formats) : td;
            append(lastNode, Element.fromTag("br"));
            copy(prev2.element(), td);
            remove$1(td, "height");
            if (prev2.colspan() !== 1) {
              remove$1(prev2.element(), "width");
            }
            mutate2(prev2.element(), td);
            return td;
          };
          return {
            row: newRow(doc),
            cell: newCell,
            replace,
            gap: createCell
          };
        };
        var paste = function(doc) {
          return {
            row: newRow(doc),
            cell: createCell,
            replace: pasteReplace,
            gap: createCell
          };
        };
        var TableFill = {
          cellOperations,
          paste
        };
        var fromHtml$1 = function(html, scope) {
          var doc = scope || domGlobals.document;
          var div = doc.createElement("div");
          div.innerHTML = html;
          return children(Element.fromDom(div));
        };
        var inSelection = function(bounds2, detail2) {
          var leftEdge = detail2.column();
          var rightEdge = detail2.column() + detail2.colspan() - 1;
          var topEdge = detail2.row();
          var bottomEdge = detail2.row() + detail2.rowspan() - 1;
          return leftEdge <= bounds2.finishCol() && rightEdge >= bounds2.startCol() && (topEdge <= bounds2.finishRow() && bottomEdge >= bounds2.startRow());
        };
        var isWithin = function(bounds2, detail2) {
          return detail2.column() >= bounds2.startCol() && detail2.column() + detail2.colspan() - 1 <= bounds2.finishCol() && detail2.row() >= bounds2.startRow() && detail2.row() + detail2.rowspan() - 1 <= bounds2.finishRow();
        };
        var isRectangular = function(warehouse, bounds2) {
          var isRect = true;
          var detailIsWithin = curry(isWithin, bounds2);
          for (var i = bounds2.startRow(); i <= bounds2.finishRow(); i++) {
            for (var j = bounds2.startCol(); j <= bounds2.finishCol(); j++) {
              isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);
            }
          }
          return isRect ? Option.some(bounds2) : Option.none();
        };
        var CellBounds = {
          inSelection,
          isWithin,
          isRectangular
        };
        var getBounds = function(detailA, detailB) {
          return bounds(Math.min(detailA.row(), detailB.row()), Math.min(detailA.column(), detailB.column()), Math.max(detailA.row() + detailA.rowspan() - 1, detailB.row() + detailB.rowspan() - 1), Math.max(detailA.column() + detailA.colspan() - 1, detailB.column() + detailB.colspan() - 1));
        };
        var getAnyBox = function(warehouse, startCell, finishCell) {
          var startCoords = Warehouse.findItem(warehouse, startCell, eq);
          var finishCoords = Warehouse.findItem(warehouse, finishCell, eq);
          return startCoords.bind(function(sc) {
            return finishCoords.map(function(fc) {
              return getBounds(sc, fc);
            });
          });
        };
        var getBox = function(warehouse, startCell, finishCell) {
          return getAnyBox(warehouse, startCell, finishCell).bind(function(bounds2) {
            return CellBounds.isRectangular(warehouse, bounds2);
          });
        };
        var CellGroup = {
          getAnyBox,
          getBox
        };
        var moveBy = function(warehouse, cell2, row2, column) {
          return Warehouse.findItem(warehouse, cell2, eq).bind(function(detail2) {
            var startRow = row2 > 0 ? detail2.row() + detail2.rowspan() - 1 : detail2.row();
            var startCol = column > 0 ? detail2.column() + detail2.colspan() - 1 : detail2.column();
            var dest = Warehouse.getAt(warehouse, startRow + row2, startCol + column);
            return dest.map(function(d) {
              return d.element();
            });
          });
        };
        var intercepts = function(warehouse, start, finish) {
          return CellGroup.getAnyBox(warehouse, start, finish).map(function(bounds2) {
            var inside = Warehouse.filterItems(warehouse, curry(CellBounds.inSelection, bounds2));
            return map(inside, function(detail2) {
              return detail2.element();
            });
          });
        };
        var parentCell = function(warehouse, innerCell) {
          var isContainedBy = function(c1, c2) {
            return contains$2(c2, c1);
          };
          return Warehouse.findItem(warehouse, innerCell, isContainedBy).map(function(detail2) {
            return detail2.element();
          });
        };
        var CellFinder = {
          moveBy,
          intercepts,
          parentCell
        };
        var moveBy$1 = function(cell2, deltaRow, deltaColumn) {
          return TableLookup.table(cell2).bind(function(table3) {
            var warehouse = getWarehouse(table3);
            return CellFinder.moveBy(warehouse, cell2, deltaRow, deltaColumn);
          });
        };
        var intercepts$1 = function(table3, first2, last2) {
          var warehouse = getWarehouse(table3);
          return CellFinder.intercepts(warehouse, first2, last2);
        };
        var nestedIntercepts = function(table3, first2, firstTable, last2, lastTable) {
          var warehouse = getWarehouse(table3);
          var optStartCell = eq(table3, firstTable) ? Option.some(first2) : CellFinder.parentCell(warehouse, first2);
          var optLastCell = eq(table3, lastTable) ? Option.some(last2) : CellFinder.parentCell(warehouse, last2);
          return optStartCell.bind(function(startCell) {
            return optLastCell.bind(function(lastCell) {
              return CellFinder.intercepts(warehouse, startCell, lastCell);
            });
          });
        };
        var getBox$1 = function(table3, first2, last2) {
          var warehouse = getWarehouse(table3);
          return CellGroup.getBox(warehouse, first2, last2);
        };
        var getWarehouse = function(table3) {
          var list = DetailsList.fromTable(table3);
          return Warehouse.generate(list);
        };
        var TablePositions = {
          moveBy: moveBy$1,
          intercepts: intercepts$1,
          nestedIntercepts,
          getBox: getBox$1
        };
        var TagBoundaries = [
          "body",
          "p",
          "div",
          "article",
          "aside",
          "figcaption",
          "figure",
          "footer",
          "header",
          "nav",
          "section",
          "ol",
          "ul",
          "li",
          "table",
          "thead",
          "tbody",
          "tfoot",
          "caption",
          "tr",
          "td",
          "th",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "blockquote",
          "pre",
          "address"
        ];
        function DomUniverse() {
          var clone$12 = function(element) {
            return Element.fromDom(element.dom().cloneNode(false));
          };
          var document2 = function(element) {
            return element.dom().ownerDocument;
          };
          var isBoundary = function(element) {
            if (!isElement(element)) {
              return false;
            }
            if (name(element) === "body") {
              return true;
            }
            return contains(TagBoundaries, name(element));
          };
          var isEmptyTag2 = function(element) {
            if (!isElement(element)) {
              return false;
            }
            return contains([
              "br",
              "img",
              "hr",
              "input"
            ], name(element));
          };
          var comparePosition = function(element, other) {
            return element.dom().compareDocumentPosition(other.dom());
          };
          var copyAttributesTo = function(source, destination) {
            var as = clone(source);
            setAll(destination, as);
          };
          return {
            up: constant({
              selector: ancestor$1,
              closest: closest$1,
              predicate: ancestor,
              all: parents
            }),
            down: constant({
              selector: descendants$1,
              predicate: descendants
            }),
            styles: constant({
              get: get$1,
              getRaw,
              set: set$1,
              remove: remove$1
            }),
            attrs: constant({
              get,
              set,
              remove,
              copyTo: copyAttributesTo
            }),
            insert: constant({
              before,
              after,
              afterAll: after$1,
              append,
              appendAll: append$1,
              prepend,
              wrap
            }),
            remove: constant({
              unwrap,
              remove: remove$2
            }),
            create: constant({
              nu: Element.fromTag,
              clone: clone$12,
              text: Element.fromText
            }),
            query: constant({
              comparePosition,
              prevSibling,
              nextSibling
            }),
            property: constant({
              children,
              name,
              parent,
              document: document2,
              isText,
              isComment,
              isElement,
              getText: get$2,
              setText: set$2,
              isBoundary,
              isEmptyTag: isEmptyTag2
            }),
            eq,
            is: is$1
          };
        }
        var leftRight = Immutable("left", "right");
        var brokenPath = Immutable("first", "second", "splits");
        var bisect = function(universe2, parent2, child2) {
          var children2 = universe2.property().children(parent2);
          var index = findIndex(children2, curry(universe2.eq, child2));
          return index.map(function(ind) {
            return {
              before: constant(children2.slice(0, ind)),
              after: constant(children2.slice(ind + 1))
            };
          });
        };
        var breakToRight = function(universe2, parent2, child2) {
          return bisect(universe2, parent2, child2).map(function(parts) {
            var second = universe2.create().clone(parent2);
            universe2.insert().appendAll(second, parts.after());
            universe2.insert().after(parent2, second);
            return leftRight(parent2, second);
          });
        };
        var breakToLeft = function(universe2, parent2, child2) {
          return bisect(universe2, parent2, child2).map(function(parts) {
            var prior = universe2.create().clone(parent2);
            universe2.insert().appendAll(prior, parts.before().concat([child2]));
            universe2.insert().appendAll(parent2, parts.after());
            universe2.insert().before(parent2, prior);
            return leftRight(prior, parent2);
          });
        };
        var breakPath = function(universe2, item, isTop, breaker) {
          var next2 = function(child2, group, splits) {
            var fallback = brokenPath(child2, Option.none(), splits);
            if (isTop(child2)) {
              return brokenPath(child2, group, splits);
            } else {
              return universe2.property().parent(child2).bind(function(parent2) {
                return breaker(universe2, parent2, child2).map(function(breakage) {
                  var extra = [{
                    first: breakage.left,
                    second: breakage.right
                  }];
                  var nextChild = isTop(parent2) ? parent2 : breakage.left();
                  return next2(nextChild, Option.some(breakage.right()), splits.concat(extra));
                });
              }).getOr(fallback);
            }
          };
          return next2(item, Option.none(), []);
        };
        var all$1 = function(universe2, look, elements, f) {
          var head = elements[0];
          var tail = elements.slice(1);
          return f(universe2, look, head, tail);
        };
        var oneAll = function(universe2, look, elements) {
          return elements.length > 0 ? all$1(universe2, look, elements, unsafeOne) : Option.none();
        };
        var unsafeOne = function(universe2, look, head, tail) {
          var start = look(universe2, head);
          return foldr(tail, function(b, a) {
            var current = look(universe2, a);
            return commonElement(universe2, b, current);
          }, start);
        };
        var commonElement = function(universe2, start, end) {
          return start.bind(function(s) {
            return end.filter(curry(universe2.eq, s));
          });
        };
        var eq$1 = function(universe2, item) {
          return curry(universe2.eq, item);
        };
        var unsafeSubset = function(universe2, common, ps1, ps2) {
          var children2 = universe2.property().children(common);
          if (universe2.eq(common, ps1[0])) {
            return Option.some([ps1[0]]);
          }
          if (universe2.eq(common, ps2[0])) {
            return Option.some([ps2[0]]);
          }
          var finder = function(ps) {
            var topDown = reverse(ps);
            var index = findIndex(topDown, eq$1(universe2, common)).getOr(-1);
            var item = index < topDown.length - 1 ? topDown[index + 1] : topDown[index];
            return findIndex(children2, eq$1(universe2, item));
          };
          var startIndex = finder(ps1);
          var endIndex = finder(ps2);
          return startIndex.bind(function(sIndex) {
            return endIndex.map(function(eIndex) {
              var first2 = Math.min(sIndex, eIndex);
              var last2 = Math.max(sIndex, eIndex);
              return children2.slice(first2, last2 + 1);
            });
          });
        };
        var ancestors$2 = function(universe2, start, end, isRoot) {
          if (isRoot === void 0) {
            isRoot = never;
          }
          var ps1 = [start].concat(universe2.up().all(start));
          var ps2 = [end].concat(universe2.up().all(end));
          var prune2 = function(path2) {
            var index = findIndex(path2, isRoot);
            return index.fold(function() {
              return path2;
            }, function(ind) {
              return path2.slice(0, ind + 1);
            });
          };
          var pruned1 = prune2(ps1);
          var pruned2 = prune2(ps2);
          var shared = find(pruned1, function(x) {
            return exists(pruned2, eq$1(universe2, x));
          });
          return {
            firstpath: constant(pruned1),
            secondpath: constant(pruned2),
            shared: constant(shared)
          };
        };
        var subset = function(universe2, start, end) {
          var ancs = ancestors$2(universe2, start, end);
          return ancs.shared().bind(function(shared) {
            return unsafeSubset(universe2, shared, ancs.firstpath(), ancs.secondpath());
          });
        };
        var SubsetFn = {
          subset,
          ancestors: ancestors$2
        };
        var sharedOne = oneAll;
        var subset$1 = SubsetFn.subset;
        var ancestors$3 = SubsetFn.ancestors;
        var breakToLeft$1 = breakToLeft;
        var breakToRight$1 = breakToRight;
        var breakPath$1 = breakPath;
        var Parent = {
          sharedOne,
          subset: subset$1,
          ancestors: ancestors$3,
          breakToLeft: breakToLeft$1,
          breakToRight: breakToRight$1,
          breakPath: breakPath$1
        };
        var universe = DomUniverse();
        var sharedOne$1 = function(look, elements) {
          return Parent.sharedOne(universe, function(_universe, element) {
            return look(element);
          }, elements);
        };
        var subset$2 = function(start, finish) {
          return Parent.subset(universe, start, finish);
        };
        var ancestors$4 = function(start, finish, isRoot) {
          return Parent.ancestors(universe, start, finish, isRoot);
        };
        var breakToLeft$2 = function(parent2, child2) {
          return Parent.breakToLeft(universe, parent2, child2);
        };
        var breakToRight$2 = function(parent2, child2) {
          return Parent.breakToRight(universe, parent2, child2);
        };
        var breakPath$2 = function(child2, isTop, breaker) {
          return Parent.breakPath(universe, child2, isTop, function(u, p, c) {
            return breaker(p, c);
          });
        };
        var DomParent = {
          sharedOne: sharedOne$1,
          subset: subset$2,
          ancestors: ancestors$4,
          breakToLeft: breakToLeft$2,
          breakToRight: breakToRight$2,
          breakPath: breakPath$2
        };
        var create = MixedBag([
          "boxes",
          "start",
          "finish"
        ], []);
        var Identified = { create };
        var lookupTable = function(container) {
          return ancestor$1(container, "table");
        };
        var identify = function(start, finish, isRoot) {
          var getIsRoot2 = function(rootTable) {
            return function(element) {
              return isRoot !== void 0 && isRoot(element) || eq(element, rootTable);
            };
          };
          if (eq(start, finish)) {
            return Option.some(Identified.create({
              boxes: Option.some([start]),
              start,
              finish
            }));
          } else {
            return lookupTable(start).bind(function(startTable) {
              return lookupTable(finish).bind(function(finishTable) {
                if (eq(startTable, finishTable)) {
                  return Option.some(Identified.create({
                    boxes: TablePositions.intercepts(startTable, start, finish),
                    start,
                    finish
                  }));
                } else if (contains$2(startTable, finishTable)) {
                  var ancestorCells = ancestors$1(finish, "td,th", getIsRoot2(startTable));
                  var finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;
                  return Option.some(Identified.create({
                    boxes: TablePositions.nestedIntercepts(startTable, start, startTable, finish, finishTable),
                    start,
                    finish: finishCell
                  }));
                } else if (contains$2(finishTable, startTable)) {
                  var ancestorCells = ancestors$1(start, "td,th", getIsRoot2(finishTable));
                  var startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;
                  return Option.some(Identified.create({
                    boxes: TablePositions.nestedIntercepts(finishTable, start, startTable, finish, finishTable),
                    start,
                    finish: startCell
                  }));
                } else {
                  return DomParent.ancestors(start, finish).shared().bind(function(lca) {
                    return closest$1(lca, "table", isRoot).bind(function(lcaTable) {
                      var finishAncestorCells = ancestors$1(finish, "td,th", getIsRoot2(lcaTable));
                      var finishCell2 = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;
                      var startAncestorCells = ancestors$1(start, "td,th", getIsRoot2(lcaTable));
                      var startCell2 = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;
                      return Option.some(Identified.create({
                        boxes: TablePositions.nestedIntercepts(lcaTable, start, startTable, finish, finishTable),
                        start: startCell2,
                        finish: finishCell2
                      }));
                    });
                  });
                }
              });
            });
          }
        };
        var retrieve = function(container, selector) {
          var sels = descendants$1(container, selector);
          return sels.length > 0 ? Option.some(sels) : Option.none();
        };
        var getLast = function(boxes, lastSelectedSelector2) {
          return find(boxes, function(box) {
            return is(box, lastSelectedSelector2);
          });
        };
        var getEdges = function(container, firstSelectedSelector2, lastSelectedSelector2) {
          return descendant$1(container, firstSelectedSelector2).bind(function(first2) {
            return descendant$1(container, lastSelectedSelector2).bind(function(last2) {
              return DomParent.sharedOne(lookupTable, [
                first2,
                last2
              ]).map(function(tbl) {
                return {
                  first: constant(first2),
                  last: constant(last2),
                  table: constant(tbl)
                };
              });
            });
          });
        };
        var expandTo = function(finish, firstSelectedSelector2) {
          return ancestor$1(finish, "table").bind(function(table3) {
            return descendant$1(table3, firstSelectedSelector2).bind(function(start) {
              return identify(start, finish).bind(function(identified) {
                return identified.boxes().map(function(boxes) {
                  return {
                    boxes: constant(boxes),
                    start: constant(identified.start()),
                    finish: constant(identified.finish())
                  };
                });
              });
            });
          });
        };
        var shiftSelection = function(boxes, deltaRow, deltaColumn, firstSelectedSelector2, lastSelectedSelector2) {
          return getLast(boxes, lastSelectedSelector2).bind(function(last2) {
            return TablePositions.moveBy(last2, deltaRow, deltaColumn).bind(function(finish) {
              return expandTo(finish, firstSelectedSelector2);
            });
          });
        };
        var CellSelection = {
          identify,
          retrieve,
          shiftSelection,
          getEdges
        };
        var retrieve$1 = function(container, selector) {
          return CellSelection.retrieve(container, selector);
        };
        var retrieveBox = function(container, firstSelectedSelector2, lastSelectedSelector2) {
          return CellSelection.getEdges(container, firstSelectedSelector2, lastSelectedSelector2).bind(function(edges) {
            var isRoot = function(ancestor2) {
              return eq(container, ancestor2);
            };
            var firstAncestor = ancestor$1(edges.first(), "thead,tfoot,tbody,table", isRoot);
            var lastAncestor = ancestor$1(edges.last(), "thead,tfoot,tbody,table", isRoot);
            return firstAncestor.bind(function(fA) {
              return lastAncestor.bind(function(lA) {
                return eq(fA, lA) ? TablePositions.getBox(edges.table(), edges.first(), edges.last()) : Option.none();
              });
            });
          });
        };
        var TableSelection = {
          retrieve: retrieve$1,
          retrieveBox
        };
        var selected = "data-mce-selected";
        var selectedSelector = "td[" + selected + "],th[" + selected + "]";
        var attributeSelector = "[" + selected + "]";
        var firstSelected = "data-mce-first-selected";
        var firstSelectedSelector = "td[" + firstSelected + "],th[" + firstSelected + "]";
        var lastSelected = "data-mce-last-selected";
        var lastSelectedSelector = "td[" + lastSelected + "],th[" + lastSelected + "]";
        var Ephemera = {
          selected: constant(selected),
          selectedSelector: constant(selectedSelector),
          attributeSelector: constant(attributeSelector),
          firstSelected: constant(firstSelected),
          firstSelectedSelector: constant(firstSelectedSelector),
          lastSelected: constant(lastSelected),
          lastSelectedSelector: constant(lastSelectedSelector)
        };
        var generate$1 = function(cases) {
          if (!isArray(cases)) {
            throw new Error("cases must be an array");
          }
          if (cases.length === 0) {
            throw new Error("there must be at least one case");
          }
          var constructors = [];
          var adt2 = {};
          each(cases, function(acase, count) {
            var keys$1 = keys(acase);
            if (keys$1.length !== 1) {
              throw new Error("one and only one name per case");
            }
            var key2 = keys$1[0];
            var value2 = acase[key2];
            if (adt2[key2] !== void 0) {
              throw new Error("duplicate key detected:" + key2);
            } else if (key2 === "cata") {
              throw new Error("cannot have a case named cata (sorry)");
            } else if (!isArray(value2)) {
              throw new Error("case arguments must be an array");
            }
            constructors.push(key2);
            adt2[key2] = function() {
              var argLength = arguments.length;
              if (argLength !== value2.length) {
                throw new Error("Wrong number of arguments to case " + key2 + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
              }
              var args = new Array(argLength);
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
              }
              var match = function(branches) {
                var branchKeys = keys(branches);
                if (constructors.length !== branchKeys.length) {
                  throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
                }
                var allReqd = forall(constructors, function(reqKey) {
                  return contains(branchKeys, reqKey);
                });
                if (!allReqd) {
                  throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
                }
                return branches[key2].apply(null, args);
              };
              return {
                fold: function() {
                  if (arguments.length !== cases.length) {
                    throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + arguments.length);
                  }
                  var target = arguments[count];
                  return target.apply(null, args);
                },
                match,
                log: function(label) {
                  domGlobals.console.log(label, {
                    constructors,
                    constructor: key2,
                    params: args
                  });
                }
              };
            };
          });
          return adt2;
        };
        var Adt = { generate: generate$1 };
        var type$1 = Adt.generate([
          { none: [] },
          { multiple: ["elements"] },
          { single: ["selection"] }
        ]);
        var cata = function(subject, onNone, onMultiple, onSingle) {
          return subject.fold(onNone, onMultiple, onSingle);
        };
        var SelectionTypes = {
          cata,
          none: type$1.none,
          multiple: type$1.multiple,
          single: type$1.single
        };
        var selection = function(cell2, selections) {
          return SelectionTypes.cata(selections.get(), constant([]), identity, constant([cell2]));
        };
        var unmergable = function(cell2, selections) {
          var hasSpan = function(elem) {
            return has(elem, "rowspan") && parseInt(get(elem, "rowspan"), 10) > 1 || has(elem, "colspan") && parseInt(get(elem, "colspan"), 10) > 1;
          };
          var candidates = selection(cell2, selections);
          return candidates.length > 0 && forall(candidates, hasSpan) ? Option.some(candidates) : Option.none();
        };
        var mergable = function(table3, selections) {
          return SelectionTypes.cata(selections.get(), Option.none, function(cells2, _env) {
            if (cells2.length === 0) {
              return Option.none();
            }
            return TableSelection.retrieveBox(table3, Ephemera.firstSelectedSelector(), Ephemera.lastSelectedSelector()).bind(function(bounds2) {
              return cells2.length > 1 ? Option.some({
                bounds: constant(bounds2),
                cells: constant(cells2)
              }) : Option.none();
            });
          }, Option.none);
        };
        var CellOperations = {
          mergable,
          unmergable,
          selection
        };
        var noMenu = function(cell2) {
          return {
            element: constant(cell2),
            mergable: Option.none,
            unmergable: Option.none,
            selection: constant([cell2])
          };
        };
        var forMenu = function(selections, table3, cell2) {
          return {
            element: constant(cell2),
            mergable: constant(CellOperations.mergable(table3, selections)),
            unmergable: constant(CellOperations.unmergable(cell2, selections)),
            selection: constant(CellOperations.selection(cell2, selections))
          };
        };
        var notCell$1 = function(element) {
          return noMenu(element);
        };
        var paste$1 = Immutable("element", "clipboard", "generators");
        var pasteRows = function(selections, table3, cell2, clipboard, generators) {
          return {
            element: constant(cell2),
            mergable: Option.none,
            unmergable: Option.none,
            selection: constant(CellOperations.selection(cell2, selections)),
            clipboard: constant(clipboard),
            generators: constant(generators)
          };
        };
        var TableTargets = {
          noMenu,
          forMenu,
          notCell: notCell$1,
          paste: paste$1,
          pasteRows
        };
        var extractSelected = function(cells2) {
          return TableLookup.table(cells2[0]).map(deep).map(function(replica) {
            return [CopySelected.extract(replica, Ephemera.attributeSelector())];
          });
        };
        var serializeElements = function(editor, elements) {
          return map(elements, function(elm) {
            return editor.selection.serializer.serialize(elm.dom(), {});
          }).join("");
        };
        var getTextContent = function(elements) {
          return map(elements, function(element) {
            return element.dom().innerText;
          }).join("");
        };
        var registerEvents = function(editor, selections, actions, cellSelection) {
          editor.on("BeforeGetContent", function(e) {
            var multiCellContext = function(cells2) {
              e.preventDefault();
              extractSelected(cells2).each(function(elements) {
                e.content = e.format === "text" ? getTextContent(elements) : serializeElements(editor, elements);
              });
            };
            if (e.selection === true) {
              SelectionTypes.cata(selections.get(), noop, multiCellContext, noop);
            }
          });
          editor.on("BeforeSetContent", function(e) {
            if (e.selection === true && e.paste === true) {
              var cellOpt = Option.from(editor.dom.getParent(editor.selection.getStart(), "th,td"));
              cellOpt.each(function(domCell) {
                var cell2 = Element.fromDom(domCell);
                TableLookup.table(cell2).each(function(table3) {
                  var elements = filter(fromHtml$1(e.content), function(content) {
                    return name(content) !== "meta";
                  });
                  if (elements.length === 1 && name(elements[0]) === "table") {
                    e.preventDefault();
                    var doc = Element.fromDom(editor.getDoc());
                    var generators = TableFill.paste(doc);
                    var targets = TableTargets.paste(cell2, elements[0], generators);
                    actions.pasteCells(table3, targets).each(function(rng) {
                      editor.selection.setRng(rng);
                      editor.focus();
                      cellSelection.clear(table3);
                    });
                  }
                });
              });
            }
          });
        };
        var Clipboard = { registerEvents };
        function Dimension(name2, getOffset) {
          var set2 = function(element, h) {
            if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
              throw new Error(name2 + ".set accepts only positive integer values. Value was " + h);
            }
            var dom = element.dom();
            if (isSupported(dom)) {
              dom.style[name2] = h + "px";
            }
          };
          var get2 = function(element) {
            var r2 = getOffset(element);
            if (r2 <= 0 || r2 === null) {
              var css2 = get$1(element, name2);
              return parseFloat(css2) || 0;
            }
            return r2;
          };
          var getOuter2 = get2;
          var aggregate = function(element, properties) {
            return foldl(properties, function(acc, property) {
              var val = get$1(element, property);
              var value2 = val === void 0 ? 0 : parseInt(val, 10);
              return isNaN(value2) ? acc : acc + value2;
            }, 0);
          };
          var max = function(element, value2, properties) {
            var cumulativeInclusions = aggregate(element, properties);
            var absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
            return absoluteMax;
          };
          return {
            set: set2,
            get: get2,
            getOuter: getOuter2,
            aggregate,
            max
          };
        }
        var api$1 = Dimension("height", function(element) {
          var dom = element.dom();
          return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
        });
        var get$3 = function(element) {
          return api$1.get(element);
        };
        var getOuter = function(element) {
          return api$1.getOuter(element);
        };
        var api$2 = Dimension("width", function(element) {
          return element.dom().offsetWidth;
        });
        var get$4 = function(element) {
          return api$2.get(element);
        };
        var getOuter$1 = function(element) {
          return api$2.getOuter(element);
        };
        var platform = PlatformDetection$1.detect();
        var needManualCalc = function() {
          return platform.browser.isIE() || platform.browser.isEdge();
        };
        var toNumber = function(px, fallback) {
          var num = parseFloat(px);
          return isNaN(num) ? fallback : num;
        };
        var getProp = function(elm, name2, fallback) {
          return toNumber(get$1(elm, name2), fallback);
        };
        var getCalculatedHeight = function(cell2) {
          var paddingTop = getProp(cell2, "padding-top", 0);
          var paddingBottom = getProp(cell2, "padding-bottom", 0);
          var borderTop = getProp(cell2, "border-top-width", 0);
          var borderBottom = getProp(cell2, "border-bottom-width", 0);
          var height2 = cell2.dom().getBoundingClientRect().height;
          var boxSizing = get$1(cell2, "box-sizing");
          var borders = borderTop + borderBottom;
          return boxSizing === "border-box" ? height2 : height2 - paddingTop - paddingBottom - borders;
        };
        var getWidth = function(cell2) {
          return getProp(cell2, "width", get$4(cell2));
        };
        var getHeight = function(cell2) {
          return needManualCalc() ? getCalculatedHeight(cell2) : getProp(cell2, "height", get$3(cell2));
        };
        var RuntimeSize = {
          getWidth,
          getHeight
        };
        var genericSizeRegex = /(\d+(\.\d+)?)(\w|%)*/;
        var percentageBasedSizeRegex = /(\d+(\.\d+)?)%/;
        var pixelBasedSizeRegex = /(\d+(\.\d+)?)px|em/;
        var setPixelWidth = function(cell2, amount) {
          set$1(cell2, "width", amount + "px");
        };
        var setPercentageWidth = function(cell2, amount) {
          set$1(cell2, "width", amount + "%");
        };
        var setHeight = function(cell2, amount) {
          set$1(cell2, "height", amount + "px");
        };
        var getHeightValue = function(cell2) {
          return getRaw(cell2, "height").getOrThunk(function() {
            return RuntimeSize.getHeight(cell2) + "px";
          });
        };
        var convert = function(cell2, number, getter, setter) {
          var newSize = TableLookup.table(cell2).map(function(table3) {
            var total2 = getter(table3);
            return Math.floor(number / 100 * total2);
          }).getOr(number);
          setter(cell2, newSize);
          return newSize;
        };
        var normalizePixelSize = function(value2, cell2, getter, setter) {
          var number = parseInt(value2, 10);
          return endsWith(value2, "%") && name(cell2) !== "table" ? convert(cell2, number, getter, setter) : number;
        };
        var getTotalHeight = function(cell2) {
          var value2 = getHeightValue(cell2);
          if (!value2) {
            return get$3(cell2);
          }
          return normalizePixelSize(value2, cell2, get$3, setHeight);
        };
        var get$5 = function(cell2, type2, f) {
          var v = f(cell2);
          var span = getSpan(cell2, type2);
          return v / span;
        };
        var getSpan = function(cell2, type2) {
          return has(cell2, type2) ? parseInt(get(cell2, type2), 10) : 1;
        };
        var getRawWidth = function(element) {
          var cssWidth = getRaw(element, "width");
          return cssWidth.fold(function() {
            return Option.from(get(element, "width"));
          }, function(width) {
            return Option.some(width);
          });
        };
        var normalizePercentageWidth = function(cellWidth, tableSize) {
          return cellWidth / tableSize.pixelWidth() * 100;
        };
        var choosePercentageSize = function(element, width, tableSize) {
          var percentMatch = percentageBasedSizeRegex.exec(width);
          if (percentMatch !== null) {
            return parseFloat(percentMatch[1]);
          } else {
            var intWidth = get$4(element);
            return normalizePercentageWidth(intWidth, tableSize);
          }
        };
        var getPercentageWidth = function(cell2, tableSize) {
          var width = getRawWidth(cell2);
          return width.fold(function() {
            var intWidth = get$4(cell2);
            return normalizePercentageWidth(intWidth, tableSize);
          }, function(w) {
            return choosePercentageSize(cell2, w, tableSize);
          });
        };
        var normalizePixelWidth = function(cellWidth, tableSize) {
          return cellWidth / 100 * tableSize.pixelWidth();
        };
        var choosePixelSize = function(element, width, tableSize) {
          var pixelMatch = pixelBasedSizeRegex.exec(width);
          if (pixelMatch !== null) {
            return parseInt(pixelMatch[1], 10);
          }
          var percentMatch = percentageBasedSizeRegex.exec(width);
          if (percentMatch !== null) {
            var floatWidth = parseFloat(percentMatch[1]);
            return normalizePixelWidth(floatWidth, tableSize);
          }
          return get$4(element);
        };
        var getPixelWidth = function(cell2, tableSize) {
          var width = getRawWidth(cell2);
          return width.fold(function() {
            return get$4(cell2);
          }, function(w) {
            return choosePixelSize(cell2, w, tableSize);
          });
        };
        var getHeight$1 = function(cell2) {
          return get$5(cell2, "rowspan", getTotalHeight);
        };
        var getGenericWidth = function(cell2) {
          var width = getRawWidth(cell2);
          return width.bind(function(w) {
            var match = genericSizeRegex.exec(w);
            if (match !== null) {
              return Option.some({
                width: constant(parseFloat(match[1])),
                unit: constant(match[3])
              });
            } else {
              return Option.none();
            }
          });
        };
        var setGenericWidth = function(cell2, amount, unit) {
          set$1(cell2, "width", amount + unit);
        };
        var Sizes = {
          percentageBasedSizeRegex: constant(percentageBasedSizeRegex),
          pixelBasedSizeRegex: constant(pixelBasedSizeRegex),
          setPixelWidth,
          setPercentageWidth,
          setHeight,
          getPixelWidth,
          getPercentageWidth,
          getGenericWidth,
          setGenericWidth,
          getHeight: getHeight$1,
          getRawWidth
        };
        var halve = function(main, other) {
          var width = Sizes.getGenericWidth(main);
          width.each(function(w) {
            var newWidth = w.width() / 2;
            Sizes.setGenericWidth(main, newWidth, w.unit());
            Sizes.setGenericWidth(other, newWidth, w.unit());
          });
        };
        var CellMutations = { halve };
        var r = function(left2, top) {
          var translate2 = function(x, y) {
            return r(left2 + x, top + y);
          };
          return {
            left: constant(left2),
            top: constant(top),
            translate: translate2
          };
        };
        var Position = r;
        var boxPosition = function(dom) {
          var box = dom.getBoundingClientRect();
          return Position(box.left, box.top);
        };
        var firstDefinedOrZero = function(a, b) {
          return a !== void 0 ? a : b !== void 0 ? b : 0;
        };
        var absolute = function(element) {
          var doc = element.dom().ownerDocument;
          var body2 = doc.body;
          var win = doc.defaultView;
          var html = doc.documentElement;
          var scrollTop = firstDefinedOrZero(win.pageYOffset, html.scrollTop);
          var scrollLeft = firstDefinedOrZero(win.pageXOffset, html.scrollLeft);
          var clientTop = firstDefinedOrZero(html.clientTop, body2.clientTop);
          var clientLeft = firstDefinedOrZero(html.clientLeft, body2.clientLeft);
          return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
        };
        var viewport = function(element) {
          var dom = element.dom();
          var doc = dom.ownerDocument;
          var body2 = doc.body;
          if (body2 === dom) {
            return Position(body2.offsetLeft, body2.offsetTop);
          }
          if (!inBody(element)) {
            return Position(0, 0);
          }
          return boxPosition(dom);
        };
        var rowInfo = Immutable("row", "y");
        var colInfo = Immutable("col", "x");
        var rtlEdge = function(cell2) {
          var pos = absolute(cell2);
          return pos.left() + getOuter$1(cell2);
        };
        var ltrEdge = function(cell2) {
          return absolute(cell2).left();
        };
        var getLeftEdge = function(index, cell2) {
          return colInfo(index, ltrEdge(cell2));
        };
        var getRightEdge = function(index, cell2) {
          return colInfo(index, rtlEdge(cell2));
        };
        var getTop = function(cell2) {
          return absolute(cell2).top();
        };
        var getTopEdge = function(index, cell2) {
          return rowInfo(index, getTop(cell2));
        };
        var getBottomEdge = function(index, cell2) {
          return rowInfo(index, getTop(cell2) + getOuter(cell2));
        };
        var findPositions = function(getInnerEdge, getOuterEdge, array) {
          if (array.length === 0) {
            return [];
          }
          var lines = map(array.slice(1), function(cellOption, index) {
            return cellOption.map(function(cell2) {
              return getInnerEdge(index, cell2);
            });
          });
          var lastLine = array[array.length - 1].map(function(cell2) {
            return getOuterEdge(array.length - 1, cell2);
          });
          return lines.concat([lastLine]);
        };
        var negate = function(step) {
          return -step;
        };
        var height = {
          delta: identity,
          positions: function(optElements) {
            return findPositions(getTopEdge, getBottomEdge, optElements);
          },
          edge: getTop
        };
        var ltr = {
          delta: identity,
          edge: ltrEdge,
          positions: function(optElements) {
            return findPositions(getLeftEdge, getRightEdge, optElements);
          }
        };
        var rtl = {
          delta: negate,
          edge: rtlEdge,
          positions: function(optElements) {
            return findPositions(getRightEdge, getLeftEdge, optElements);
          }
        };
        var BarPositions = {
          height,
          rtl,
          ltr
        };
        var ResizeDirection = {
          ltr: BarPositions.ltr,
          rtl: BarPositions.rtl
        };
        function TableDirection(directionAt2) {
          var auto = function(table3) {
            return directionAt2(table3).isRtl() ? ResizeDirection.rtl : ResizeDirection.ltr;
          };
          var delta2 = function(amount, table3) {
            return auto(table3).delta(amount, table3);
          };
          var positions = function(cols, table3) {
            return auto(table3).positions(cols, table3);
          };
          var edge2 = function(cell2) {
            return auto(cell2).edge(cell2);
          };
          return {
            delta: delta2,
            edge: edge2,
            positions
          };
        }
        var getGridSize = function(table3) {
          var input = DetailsList.fromTable(table3);
          var warehouse = Warehouse.generate(input);
          return warehouse.grid();
        };
        var TableGridSize = { getGridSize };
        var __assign = function() {
          __assign = Object.assign || function __assign2(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        var cat = function(arr) {
          var r2 = [];
          var push = function(x) {
            r2.push(x);
          };
          for (var i = 0; i < arr.length; i++) {
            arr[i].each(push);
          }
          return r2;
        };
        var findMap = function(arr, f) {
          for (var i = 0; i < arr.length; i++) {
            var r2 = f(arr[i], i);
            if (r2.isSome()) {
              return r2;
            }
          }
          return Option.none();
        };
        var setIfNot = function(element, property, value2, ignore) {
          if (value2 === ignore) {
            remove(element, property);
          } else {
            set(element, property, value2);
          }
        };
        var render = function(table3, grid2) {
          var newRows = [];
          var newCells = [];
          var renderSection = function(gridSection, sectionName) {
            var section = child$2(table3, sectionName).getOrThunk(function() {
              var tb = Element.fromTag(sectionName, owner(table3).dom());
              append(table3, tb);
              return tb;
            });
            empty(section);
            var rows2 = map(gridSection, function(row2) {
              if (row2.isNew()) {
                newRows.push(row2.element());
              }
              var tr = row2.element();
              empty(tr);
              each(row2.cells(), function(cell2) {
                if (cell2.isNew()) {
                  newCells.push(cell2.element());
                }
                setIfNot(cell2.element(), "colspan", cell2.colspan(), 1);
                setIfNot(cell2.element(), "rowspan", cell2.rowspan(), 1);
                append(tr, cell2.element());
              });
              return tr;
            });
            append$1(section, rows2);
          };
          var removeSection = function(sectionName) {
            child$2(table3, sectionName).each(remove$2);
          };
          var renderOrRemoveSection = function(gridSection, sectionName) {
            if (gridSection.length > 0) {
              renderSection(gridSection, sectionName);
            } else {
              removeSection(sectionName);
            }
          };
          var headSection = [];
          var bodySection = [];
          var footSection = [];
          each(grid2, function(row2) {
            switch (row2.section()) {
              case "thead":
                headSection.push(row2);
                break;
              case "tbody":
                bodySection.push(row2);
                break;
              case "tfoot":
                footSection.push(row2);
                break;
            }
          });
          renderOrRemoveSection(headSection, "thead");
          renderOrRemoveSection(bodySection, "tbody");
          renderOrRemoveSection(footSection, "tfoot");
          return {
            newRows: constant(newRows),
            newCells: constant(newCells)
          };
        };
        var copy$2 = function(grid2) {
          var rows2 = map(grid2, function(row2) {
            var tr = shallow(row2.element());
            each(row2.cells(), function(cell2) {
              var clonedCell = deep(cell2.element());
              setIfNot(clonedCell, "colspan", cell2.colspan(), 1);
              setIfNot(clonedCell, "rowspan", cell2.rowspan(), 1);
              append(tr, clonedCell);
            });
            return tr;
          });
          return rows2;
        };
        var Redraw = {
          render,
          copy: copy$2
        };
        var read = function(element, attr2) {
          var value2 = get(element, attr2);
          return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
        };
        var add = function(element, attr2, id) {
          var old = read(element, attr2);
          var nu2 = old.concat([id]);
          set(element, attr2, nu2.join(" "));
          return true;
        };
        var remove$3 = function(element, attr2, id) {
          var nu2 = filter(read(element, attr2), function(v) {
            return v !== id;
          });
          if (nu2.length > 0) {
            set(element, attr2, nu2.join(" "));
          } else {
            remove(element, attr2);
          }
          return false;
        };
        var supports = function(element) {
          return element.dom().classList !== void 0;
        };
        var get$6 = function(element) {
          return read(element, "class");
        };
        var add$1 = function(element, clazz) {
          return add(element, "class", clazz);
        };
        var remove$4 = function(element, clazz) {
          return remove$3(element, "class", clazz);
        };
        var add$2 = function(element, clazz) {
          if (supports(element)) {
            element.dom().classList.add(clazz);
          } else {
            add$1(element, clazz);
          }
        };
        var cleanClass = function(element) {
          var classList = supports(element) ? element.dom().classList : get$6(element);
          if (classList.length === 0) {
            remove(element, "class");
          }
        };
        var remove$5 = function(element, clazz) {
          if (supports(element)) {
            var classList = element.dom().classList;
            classList.remove(clazz);
          } else {
            remove$4(element, clazz);
          }
          cleanClass(element);
        };
        var has$1 = function(element, clazz) {
          return supports(element) && element.dom().classList.contains(clazz);
        };
        var repeat = function(repititions, f) {
          var r2 = [];
          for (var i = 0; i < repititions; i++) {
            r2.push(f(i));
          }
          return r2;
        };
        var range = function(start, end) {
          var r2 = [];
          for (var i = start; i < end; i++) {
            r2.push(i);
          }
          return r2;
        };
        var deduce = function(xs, index) {
          if (index < 0 || index >= xs.length - 1) {
            return Option.none();
          }
          var current = xs[index].fold(function() {
            var rest = reverse(xs.slice(0, index));
            return findMap(rest, function(a, i) {
              return a.map(function(aa) {
                return {
                  value: aa,
                  delta: i + 1
                };
              });
            });
          }, function(c) {
            return Option.some({
              value: c,
              delta: 0
            });
          });
          var next2 = xs[index + 1].fold(function() {
            var rest = xs.slice(index + 1);
            return findMap(rest, function(a, i) {
              return a.map(function(aa) {
                return {
                  value: aa,
                  delta: i + 1
                };
              });
            });
          }, function(n) {
            return Option.some({
              value: n,
              delta: 1
            });
          });
          return current.bind(function(c) {
            return next2.map(function(n) {
              var extras = n.delta + c.delta;
              return Math.abs(n.value - c.value) / extras;
            });
          });
        };
        var columns = function(warehouse) {
          var grid2 = warehouse.grid();
          var cols = range(0, grid2.columns());
          var rowsArr = range(0, grid2.rows());
          return map(cols, function(col2) {
            var getBlock = function() {
              return bind(rowsArr, function(r2) {
                return Warehouse.getAt(warehouse, r2, col2).filter(function(detail2) {
                  return detail2.column() === col2;
                }).fold(constant([]), function(detail2) {
                  return [detail2];
                });
              });
            };
            var isSingle = function(detail2) {
              return detail2.colspan() === 1;
            };
            var getFallback = function() {
              return Warehouse.getAt(warehouse, 0, col2);
            };
            return decide(getBlock, isSingle, getFallback);
          });
        };
        var decide = function(getBlock, isSingle, getFallback) {
          var inBlock = getBlock();
          var singleInBlock = find(inBlock, isSingle);
          var detailOption = singleInBlock.orThunk(function() {
            return Option.from(inBlock[0]).orThunk(getFallback);
          });
          return detailOption.map(function(detail2) {
            return detail2.element();
          });
        };
        var rows$1 = function(warehouse) {
          var grid2 = warehouse.grid();
          var rowsArr = range(0, grid2.rows());
          var cols = range(0, grid2.columns());
          return map(rowsArr, function(row2) {
            var getBlock = function() {
              return bind(cols, function(c) {
                return Warehouse.getAt(warehouse, row2, c).filter(function(detail2) {
                  return detail2.row() === row2;
                }).fold(constant([]), function(detail2) {
                  return [detail2];
                });
              });
            };
            var isSingle = function(detail2) {
              return detail2.rowspan() === 1;
            };
            var getFallback = function() {
              return Warehouse.getAt(warehouse, row2, 0);
            };
            return decide(getBlock, isSingle, getFallback);
          });
        };
        var Blocks = {
          columns,
          rows: rows$1
        };
        var css = function(namespace) {
          var dashNamespace = namespace.replace(/\./g, "-");
          var resolve2 = function(str) {
            return dashNamespace + "-" + str;
          };
          return { resolve: resolve2 };
        };
        var styles = css("ephox-snooker");
        var Styles = { resolve: styles.resolve };
        var col = function(column, x, y, w, h) {
          var blocker = Element.fromTag("div");
          setAll$1(blocker, {
            position: "absolute",
            left: x - w / 2 + "px",
            top: y + "px",
            height: h + "px",
            width: w + "px"
          });
          setAll(blocker, {
            "data-column": column,
            "role": "presentation"
          });
          return blocker;
        };
        var row$1 = function(r2, x, y, w, h) {
          var blocker = Element.fromTag("div");
          setAll$1(blocker, {
            position: "absolute",
            left: x + "px",
            top: y - h / 2 + "px",
            height: h + "px",
            width: w + "px"
          });
          setAll(blocker, {
            "data-row": r2,
            "role": "presentation"
          });
          return blocker;
        };
        var Bar = {
          col,
          row: row$1
        };
        var resizeBar = Styles.resolve("resizer-bar");
        var resizeRowBar = Styles.resolve("resizer-rows");
        var resizeColBar = Styles.resolve("resizer-cols");
        var BAR_THICKNESS = 7;
        var destroy = function(wire) {
          var previous = descendants$1(wire.parent(), "." + resizeBar);
          each(previous, remove$2);
        };
        var drawBar = function(wire, positions, create2) {
          var origin = wire.origin();
          each(positions, function(cpOption, i) {
            cpOption.each(function(cp) {
              var bar = create2(origin, cp);
              add$2(bar, resizeBar);
              append(wire.parent(), bar);
            });
          });
        };
        var refreshCol = function(wire, colPositions, position, tableHeight) {
          drawBar(wire, colPositions, function(origin, cp) {
            var colBar = Bar.col(cp.col(), cp.x() - origin.left(), position.top() - origin.top(), BAR_THICKNESS, tableHeight);
            add$2(colBar, resizeColBar);
            return colBar;
          });
        };
        var refreshRow = function(wire, rowPositions, position, tableWidth) {
          drawBar(wire, rowPositions, function(origin, cp) {
            var rowBar = Bar.row(cp.row(), position.left() - origin.left(), cp.y() - origin.top(), tableWidth, BAR_THICKNESS);
            add$2(rowBar, resizeRowBar);
            return rowBar;
          });
        };
        var refreshGrid = function(wire, table3, rows2, cols, hdirection, vdirection) {
          var position = absolute(table3);
          var rowPositions = rows2.length > 0 ? hdirection.positions(rows2, table3) : [];
          refreshRow(wire, rowPositions, position, getOuter$1(table3));
          var colPositions = cols.length > 0 ? vdirection.positions(cols, table3) : [];
          refreshCol(wire, colPositions, position, getOuter(table3));
        };
        var refresh = function(wire, table3, hdirection, vdirection) {
          destroy(wire);
          var list = DetailsList.fromTable(table3);
          var warehouse = Warehouse.generate(list);
          var rows2 = Blocks.rows(warehouse);
          var cols = Blocks.columns(warehouse);
          refreshGrid(wire, table3, rows2, cols, hdirection, vdirection);
        };
        var each$2 = function(wire, f) {
          var bars = descendants$1(wire.parent(), "." + resizeBar);
          each(bars, f);
        };
        var hide = function(wire) {
          each$2(wire, function(bar) {
            set$1(bar, "display", "none");
          });
        };
        var show = function(wire) {
          each$2(wire, function(bar) {
            set$1(bar, "display", "block");
          });
        };
        var isRowBar = function(element) {
          return has$1(element, resizeRowBar);
        };
        var isColBar = function(element) {
          return has$1(element, resizeColBar);
        };
        var Bars = {
          refresh,
          hide,
          show,
          destroy,
          isRowBar,
          isColBar
        };
        var addCell = function(gridRow, index, cell2) {
          var cells2 = gridRow.cells();
          var before2 = cells2.slice(0, index);
          var after2 = cells2.slice(index);
          var newCells = before2.concat([cell2]).concat(after2);
          return setCells(gridRow, newCells);
        };
        var mutateCell = function(gridRow, index, cell2) {
          var cells2 = gridRow.cells();
          cells2[index] = cell2;
        };
        var setCells = function(gridRow, cells2) {
          return rowcells(cells2, gridRow.section());
        };
        var mapCells = function(gridRow, f) {
          var cells2 = gridRow.cells();
          var r2 = map(cells2, f);
          return rowcells(r2, gridRow.section());
        };
        var getCell = function(gridRow, index) {
          return gridRow.cells()[index];
        };
        var getCellElement = function(gridRow, index) {
          return getCell(gridRow, index).element();
        };
        var cellLength = function(gridRow) {
          return gridRow.cells().length;
        };
        var GridRow = {
          addCell,
          setCells,
          mutateCell,
          getCell,
          getCellElement,
          mapCells,
          cellLength
        };
        var getColumn = function(grid2, index) {
          return map(grid2, function(row2) {
            return GridRow.getCell(row2, index);
          });
        };
        var getRow = function(grid2, index) {
          return grid2[index];
        };
        var findDiff = function(xs, comp) {
          if (xs.length === 0) {
            return 0;
          }
          var first2 = xs[0];
          var index = findIndex(xs, function(x) {
            return !comp(first2.element(), x.element());
          });
          return index.fold(function() {
            return xs.length;
          }, function(ind) {
            return ind;
          });
        };
        var subgrid = function(grid2, row2, column, comparator) {
          var restOfRow = getRow(grid2, row2).cells().slice(column);
          var endColIndex = findDiff(restOfRow, comparator);
          var restOfColumn = getColumn(grid2, column).slice(row2);
          var endRowIndex = findDiff(restOfColumn, comparator);
          return {
            colspan: constant(endColIndex),
            rowspan: constant(endRowIndex)
          };
        };
        var TableGrid = { subgrid };
        var toDetails = function(grid2, comparator) {
          var seen = map(grid2, function(row2, ri) {
            return map(row2.cells(), function(col2, ci) {
              return false;
            });
          });
          var updateSeen = function(ri, ci, rowspan, colspan) {
            for (var r2 = ri; r2 < ri + rowspan; r2++) {
              for (var c = ci; c < ci + colspan; c++) {
                seen[r2][c] = true;
              }
            }
          };
          return map(grid2, function(row2, ri) {
            var details = bind(row2.cells(), function(cell2, ci) {
              if (seen[ri][ci] === false) {
                var result = TableGrid.subgrid(grid2, ri, ci, comparator);
                updateSeen(ri, ci, result.rowspan(), result.colspan());
                return [detailnew(cell2.element(), result.rowspan(), result.colspan(), cell2.isNew())];
              } else {
                return [];
              }
            });
            return rowdetails(details, row2.section());
          });
        };
        var toGrid = function(warehouse, generators, isNew) {
          var grid2 = [];
          for (var i = 0; i < warehouse.grid().rows(); i++) {
            var rowCells = [];
            for (var j = 0; j < warehouse.grid().columns(); j++) {
              var element = Warehouse.getAt(warehouse, i, j).map(function(item) {
                return elementnew(item.element(), isNew);
              }).getOrThunk(function() {
                return elementnew(generators.gap(), true);
              });
              rowCells.push(element);
            }
            var row2 = rowcells(rowCells, warehouse.all()[i].section());
            grid2.push(row2);
          }
          return grid2;
        };
        var Transitions = {
          toDetails,
          toGrid
        };
        var fromWarehouse = function(warehouse, generators) {
          return Transitions.toGrid(warehouse, generators, false);
        };
        var deriveRows = function(rendered, generators) {
          var findRow = function(details) {
            var rowOfCells = findMap(details, function(detail2) {
              return parent(detail2.element()).map(function(row2) {
                var isNew = parent(row2).isNone();
                return elementnew(row2, isNew);
              });
            });
            return rowOfCells.getOrThunk(function() {
              return elementnew(generators.row(), true);
            });
          };
          return map(rendered, function(details) {
            var row2 = findRow(details.details());
            return rowdatanew(row2.element(), details.details(), details.section(), row2.isNew());
          });
        };
        var toDetailList = function(grid2, generators) {
          var rendered = Transitions.toDetails(grid2, eq);
          return deriveRows(rendered, generators);
        };
        var findInWarehouse = function(warehouse, element) {
          var all2 = flatten(map(warehouse.all(), function(r2) {
            return r2.cells();
          }));
          return find(all2, function(e) {
            return eq(element, e.element());
          });
        };
        var run = function(operation, extract2, adjustment, postAction, genWrappers) {
          return function(wire, table3, target, generators, direction) {
            var input = DetailsList.fromTable(table3);
            var warehouse = Warehouse.generate(input);
            var output = extract2(warehouse, target).map(function(info) {
              var model = fromWarehouse(warehouse, generators);
              var result = operation(model, info, eq, genWrappers(generators));
              var grid2 = toDetailList(result.grid(), generators);
              return {
                grid: constant(grid2),
                cursor: result.cursor
              };
            });
            return output.fold(function() {
              return Option.none();
            }, function(out) {
              var newElements = Redraw.render(table3, out.grid());
              adjustment(table3, out.grid(), direction);
              postAction(table3);
              Bars.refresh(wire, table3, BarPositions.height, direction);
              return Option.some({
                cursor: out.cursor,
                newRows: newElements.newRows,
                newCells: newElements.newCells
              });
            });
          };
        };
        var onCell = function(warehouse, target) {
          return TableLookup.cell(target.element()).bind(function(cell2) {
            return findInWarehouse(warehouse, cell2);
          });
        };
        var onPaste = function(warehouse, target) {
          return TableLookup.cell(target.element()).bind(function(cell2) {
            return findInWarehouse(warehouse, cell2).map(function(details) {
              var value2 = __assign(__assign({}, details), {
                generators: target.generators,
                clipboard: target.clipboard
              });
              return value2;
            });
          });
        };
        var onPasteRows = function(warehouse, target) {
          var details = map(target.selection(), function(cell2) {
            return TableLookup.cell(cell2).bind(function(lc) {
              return findInWarehouse(warehouse, lc);
            });
          });
          var cells2 = cat(details);
          return cells2.length > 0 ? Option.some({
            cells: cells2,
            generators: target.generators,
            clipboard: target.clipboard
          }) : Option.none();
        };
        var onMergable = function(_warehouse, target) {
          return target.mergable();
        };
        var onUnmergable = function(_warehouse, target) {
          return target.unmergable();
        };
        var onCells = function(warehouse, target) {
          var details = map(target.selection(), function(cell2) {
            return TableLookup.cell(cell2).bind(function(lc) {
              return findInWarehouse(warehouse, lc);
            });
          });
          var cells2 = cat(details);
          return cells2.length > 0 ? Option.some(cells2) : Option.none();
        };
        var value = function(o) {
          var is2 = function(v) {
            return o === v;
          };
          var or = function(opt) {
            return value(o);
          };
          var orThunk = function(f) {
            return value(o);
          };
          var map2 = function(f) {
            return value(f(o));
          };
          var mapError = function(f) {
            return value(o);
          };
          var each2 = function(f) {
            f(o);
          };
          var bind2 = function(f) {
            return f(o);
          };
          var fold = function(_, onValue) {
            return onValue(o);
          };
          var exists2 = function(f) {
            return f(o);
          };
          var forall2 = function(f) {
            return f(o);
          };
          var toOption = function() {
            return Option.some(o);
          };
          return {
            is: is2,
            isValue: always,
            isError: never,
            getOr: constant(o),
            getOrThunk: constant(o),
            getOrDie: constant(o),
            or,
            orThunk,
            fold,
            map: map2,
            mapError,
            each: each2,
            bind: bind2,
            exists: exists2,
            forall: forall2,
            toOption
          };
        };
        var error = function(message) {
          var getOrThunk = function(f) {
            return f();
          };
          var getOrDie2 = function() {
            return die(String(message))();
          };
          var or = function(opt) {
            return opt;
          };
          var orThunk = function(f) {
            return f();
          };
          var map2 = function(f) {
            return error(message);
          };
          var mapError = function(f) {
            return error(f(message));
          };
          var bind2 = function(f) {
            return error(message);
          };
          var fold = function(onError, _) {
            return onError(message);
          };
          return {
            is: never,
            isValue: never,
            isError: always,
            getOr: identity,
            getOrThunk,
            getOrDie: getOrDie2,
            or,
            orThunk,
            fold,
            map: map2,
            mapError,
            each: noop,
            bind: bind2,
            exists: never,
            forall: always,
            toOption: Option.none
          };
        };
        var fromOption = function(opt, err) {
          return opt.fold(function() {
            return error(err);
          }, value);
        };
        var Result = {
          value,
          error,
          fromOption
        };
        var measure = function(startAddress, gridA, gridB) {
          if (startAddress.row() >= gridA.length || startAddress.column() > GridRow.cellLength(gridA[0])) {
            return Result.error("invalid start address out of table bounds, row: " + startAddress.row() + ", column: " + startAddress.column());
          }
          var rowRemainder = gridA.slice(startAddress.row());
          var colRemainder = rowRemainder[0].cells().slice(startAddress.column());
          var colRequired = GridRow.cellLength(gridB[0]);
          var rowRequired = gridB.length;
          return Result.value({
            rowDelta: constant(rowRemainder.length - rowRequired),
            colDelta: constant(colRemainder.length - colRequired)
          });
        };
        var measureWidth = function(gridA, gridB) {
          var colLengthA = GridRow.cellLength(gridA[0]);
          var colLengthB = GridRow.cellLength(gridB[0]);
          return {
            rowDelta: constant(0),
            colDelta: constant(colLengthA - colLengthB)
          };
        };
        var fill = function(cells2, generator) {
          return map(cells2, function() {
            return elementnew(generator.cell(), true);
          });
        };
        var rowFill = function(grid2, amount, generator) {
          return grid2.concat(repeat(amount, function(_row) {
            return GridRow.setCells(grid2[grid2.length - 1], fill(grid2[grid2.length - 1].cells(), generator));
          }));
        };
        var colFill = function(grid2, amount, generator) {
          return map(grid2, function(row2) {
            return GridRow.setCells(row2, row2.cells().concat(fill(range(0, amount), generator)));
          });
        };
        var tailor = function(gridA, delta2, generator) {
          var fillCols = delta2.colDelta() < 0 ? colFill : identity;
          var fillRows = delta2.rowDelta() < 0 ? rowFill : identity;
          var modifiedCols = fillCols(gridA, Math.abs(delta2.colDelta()), generator);
          var tailoredGrid = fillRows(modifiedCols, Math.abs(delta2.rowDelta()), generator);
          return tailoredGrid;
        };
        var Fitment = {
          measure,
          measureWidth,
          tailor
        };
        var merge = function(grid2, bounds2, comparator, substitution) {
          if (grid2.length === 0) {
            return grid2;
          }
          for (var i = bounds2.startRow(); i <= bounds2.finishRow(); i++) {
            for (var j = bounds2.startCol(); j <= bounds2.finishCol(); j++) {
              GridRow.mutateCell(grid2[i], j, elementnew(substitution(), false));
            }
          }
          return grid2;
        };
        var unmerge = function(grid2, target, comparator, substitution) {
          var first2 = true;
          for (var i = 0; i < grid2.length; i++) {
            for (var j = 0; j < GridRow.cellLength(grid2[0]); j++) {
              var current = GridRow.getCellElement(grid2[i], j);
              var isToReplace = comparator(current, target);
              if (isToReplace === true && first2 === false) {
                GridRow.mutateCell(grid2[i], j, elementnew(substitution(), true));
              } else if (isToReplace === true) {
                first2 = false;
              }
            }
          }
          return grid2;
        };
        var uniqueCells = function(row2, comparator) {
          return foldl(row2, function(rest, cell2) {
            return exists(rest, function(currentCell) {
              return comparator(currentCell.element(), cell2.element());
            }) ? rest : rest.concat([cell2]);
          }, []);
        };
        var splitRows = function(grid2, index, comparator, substitution) {
          if (index > 0 && index < grid2.length) {
            var rowPrevCells = grid2[index - 1].cells();
            var cells2 = uniqueCells(rowPrevCells, comparator);
            each(cells2, function(cell2) {
              var replacement = Option.none();
              var _loop_1 = function(i2) {
                var _loop_2 = function(j2) {
                  var current = grid2[i2].cells()[j2];
                  var isToReplace = comparator(current.element(), cell2.element());
                  if (isToReplace) {
                    if (replacement.isNone()) {
                      replacement = Option.some(substitution());
                    }
                    replacement.each(function(sub) {
                      GridRow.mutateCell(grid2[i2], j2, elementnew(sub, true));
                    });
                  }
                };
                for (var j = 0; j < GridRow.cellLength(grid2[0]); j++) {
                  _loop_2(j);
                }
              };
              for (var i = index; i < grid2.length; i++) {
                _loop_1(i);
              }
            });
          }
          return grid2;
        };
        var MergingOperations = {
          merge,
          unmerge,
          splitRows
        };
        var isSpanning = function(grid2, row2, col2, comparator) {
          var candidate = GridRow.getCell(grid2[row2], col2);
          var matching = curry(comparator, candidate.element());
          var currentRow = grid2[row2];
          return grid2.length > 1 && GridRow.cellLength(currentRow) > 1 && (col2 > 0 && matching(GridRow.getCellElement(currentRow, col2 - 1)) || col2 < currentRow.cells().length - 1 && matching(GridRow.getCellElement(currentRow, col2 + 1)) || row2 > 0 && matching(GridRow.getCellElement(grid2[row2 - 1], col2)) || row2 < grid2.length - 1 && matching(GridRow.getCellElement(grid2[row2 + 1], col2)));
        };
        var mergeTables = function(startAddress, gridA, gridB, generator, comparator) {
          var startRow = startAddress.row();
          var startCol = startAddress.column();
          var mergeHeight = gridB.length;
          var mergeWidth = GridRow.cellLength(gridB[0]);
          var endRow = startRow + mergeHeight;
          var endCol = startCol + mergeWidth;
          for (var r2 = startRow; r2 < endRow; r2++) {
            for (var c = startCol; c < endCol; c++) {
              if (isSpanning(gridA, r2, c, comparator)) {
                MergingOperations.unmerge(gridA, GridRow.getCellElement(gridA[r2], c), comparator, generator.cell);
              }
              var newCell = GridRow.getCellElement(gridB[r2 - startRow], c - startCol);
              var replacement = generator.replace(newCell);
              GridRow.mutateCell(gridA[r2], c, elementnew(replacement, true));
            }
          }
          return gridA;
        };
        var merge$1 = function(startAddress, gridA, gridB, generator, comparator) {
          var result = Fitment.measure(startAddress, gridA, gridB);
          return result.map(function(delta2) {
            var fittedGrid = Fitment.tailor(gridA, delta2, generator);
            return mergeTables(startAddress, fittedGrid, gridB, generator, comparator);
          });
        };
        var insert = function(index, gridA, gridB, generator, comparator) {
          MergingOperations.splitRows(gridA, index, comparator, generator.cell);
          var delta2 = Fitment.measureWidth(gridB, gridA);
          var fittedNewGrid = Fitment.tailor(gridB, delta2, generator);
          var secondDelta = Fitment.measureWidth(gridA, fittedNewGrid);
          var fittedOldGrid = Fitment.tailor(gridA, secondDelta, generator);
          return fittedOldGrid.slice(0, index).concat(fittedNewGrid).concat(fittedOldGrid.slice(index, fittedOldGrid.length));
        };
        var TableMerge = {
          merge: merge$1,
          insert
        };
        var insertRowAt = function(grid2, index, example, comparator, substitution) {
          var before2 = grid2.slice(0, index);
          var after2 = grid2.slice(index);
          var between = GridRow.mapCells(grid2[example], function(ex, c) {
            var withinSpan = index > 0 && index < grid2.length && comparator(GridRow.getCellElement(grid2[index - 1], c), GridRow.getCellElement(grid2[index], c));
            var ret = withinSpan ? GridRow.getCell(grid2[index], c) : elementnew(substitution(ex.element(), comparator), true);
            return ret;
          });
          return before2.concat([between]).concat(after2);
        };
        var insertColumnAt = function(grid2, index, example, comparator, substitution) {
          return map(grid2, function(row2) {
            var withinSpan = index > 0 && index < GridRow.cellLength(row2) && comparator(GridRow.getCellElement(row2, index - 1), GridRow.getCellElement(row2, index));
            var sub = withinSpan ? GridRow.getCell(row2, index) : elementnew(substitution(GridRow.getCellElement(row2, example), comparator), true);
            return GridRow.addCell(row2, index, sub);
          });
        };
        var splitCellIntoColumns = function(grid2, exampleRow, exampleCol, comparator, substitution) {
          var index = exampleCol + 1;
          return map(grid2, function(row2, i) {
            var isTargetCell = i === exampleRow;
            var sub = isTargetCell ? elementnew(substitution(GridRow.getCellElement(row2, exampleCol), comparator), true) : GridRow.getCell(row2, exampleCol);
            return GridRow.addCell(row2, index, sub);
          });
        };
        var splitCellIntoRows = function(grid2, exampleRow, exampleCol, comparator, substitution) {
          var index = exampleRow + 1;
          var before2 = grid2.slice(0, index);
          var after2 = grid2.slice(index);
          var between = GridRow.mapCells(grid2[exampleRow], function(ex, i) {
            var isTargetCell = i === exampleCol;
            return isTargetCell ? elementnew(substitution(ex.element(), comparator), true) : ex;
          });
          return before2.concat([between]).concat(after2);
        };
        var deleteColumnsAt = function(grid2, start, finish) {
          var rows2 = map(grid2, function(row2) {
            var cells2 = row2.cells().slice(0, start).concat(row2.cells().slice(finish + 1));
            return rowcells(cells2, row2.section());
          });
          return filter(rows2, function(row2) {
            return row2.cells().length > 0;
          });
        };
        var deleteRowsAt = function(grid2, start, finish) {
          return grid2.slice(0, start).concat(grid2.slice(finish + 1));
        };
        var ModificationOperations = {
          insertRowAt,
          insertColumnAt,
          splitCellIntoColumns,
          splitCellIntoRows,
          deleteRowsAt,
          deleteColumnsAt
        };
        var replaceIn = function(grid2, targets, comparator, substitution) {
          var isTarget = function(cell2) {
            return exists(targets, function(target) {
              return comparator(cell2.element(), target.element());
            });
          };
          return map(grid2, function(row2) {
            return GridRow.mapCells(row2, function(cell2) {
              return isTarget(cell2) ? elementnew(substitution(cell2.element(), comparator), true) : cell2;
            });
          });
        };
        var notStartRow = function(grid2, rowIndex, colIndex, comparator) {
          return GridRow.getCellElement(grid2[rowIndex], colIndex) !== void 0 && (rowIndex > 0 && comparator(GridRow.getCellElement(grid2[rowIndex - 1], colIndex), GridRow.getCellElement(grid2[rowIndex], colIndex)));
        };
        var notStartColumn = function(row2, index, comparator) {
          return index > 0 && comparator(GridRow.getCellElement(row2, index - 1), GridRow.getCellElement(row2, index));
        };
        var replaceColumn = function(grid2, index, comparator, substitution) {
          var targets = bind(grid2, function(row2, i) {
            var alreadyAdded = notStartRow(grid2, i, index, comparator) || notStartColumn(row2, index, comparator);
            return alreadyAdded ? [] : [GridRow.getCell(row2, index)];
          });
          return replaceIn(grid2, targets, comparator, substitution);
        };
        var replaceRow = function(grid2, index, comparator, substitution) {
          var targetRow = grid2[index];
          var targets = bind(targetRow.cells(), function(item, i) {
            var alreadyAdded = notStartRow(grid2, index, i, comparator) || notStartColumn(targetRow, i, comparator);
            return alreadyAdded ? [] : [item];
          });
          return replaceIn(grid2, targets, comparator, substitution);
        };
        var TransformOperations = {
          replaceColumn,
          replaceRow
        };
        var adt = Adt.generate([
          { none: [] },
          { only: ["index"] },
          {
            left: [
              "index",
              "next"
            ]
          },
          {
            middle: [
              "prev",
              "index",
              "next"
            ]
          },
          {
            right: [
              "prev",
              "index"
            ]
          }
        ]);
        var ColumnContext = __assign({}, adt);
        var neighbours$1 = function(input, index) {
          if (input.length === 0) {
            return ColumnContext.none();
          }
          if (input.length === 1) {
            return ColumnContext.only(0);
          }
          if (index === 0) {
            return ColumnContext.left(0, 1);
          }
          if (index === input.length - 1) {
            return ColumnContext.right(index - 1, index);
          }
          if (index > 0 && index < input.length - 1) {
            return ColumnContext.middle(index - 1, index, index + 1);
          }
          return ColumnContext.none();
        };
        var determine = function(input, column, step, tableSize) {
          var result = input.slice(0);
          var context = neighbours$1(input, column);
          var zero = function(array) {
            return map(array, constant(0));
          };
          var onNone = constant(zero(result));
          var onOnly = function(index) {
            return tableSize.singleColumnWidth(result[index], step);
          };
          var onChange = function(index, next2) {
            if (step >= 0) {
              var newNext = Math.max(tableSize.minCellWidth(), result[next2] - step);
              return zero(result.slice(0, index)).concat([
                step,
                newNext - result[next2]
              ]).concat(zero(result.slice(next2 + 1)));
            } else {
              var newThis = Math.max(tableSize.minCellWidth(), result[index] + step);
              var diffx = result[index] - newThis;
              return zero(result.slice(0, index)).concat([
                newThis - result[index],
                diffx
              ]).concat(zero(result.slice(next2 + 1)));
            }
          };
          var onLeft = onChange;
          var onMiddle = function(_prev, index, next2) {
            return onChange(index, next2);
          };
          var onRight = function(_prev, index) {
            if (step >= 0) {
              return zero(result.slice(0, index)).concat([step]);
            } else {
              var size = Math.max(tableSize.minCellWidth(), result[index] + step);
              return zero(result.slice(0, index)).concat([size - result[index]]);
            }
          };
          return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);
        };
        var Deltas = { determine };
        var getSpan$1 = function(cell2, type2) {
          return has(cell2, type2) && parseInt(get(cell2, type2), 10) > 1;
        };
        var hasColspan = function(cell2) {
          return getSpan$1(cell2, "colspan");
        };
        var hasRowspan = function(cell2) {
          return getSpan$1(cell2, "rowspan");
        };
        var getInt = function(element, property) {
          return parseInt(get$1(element, property), 10);
        };
        var CellUtils = {
          hasColspan,
          hasRowspan,
          minWidth: constant(10),
          minHeight: constant(10),
          getInt
        };
        var getRaw$1 = function(cell2, property, getter) {
          return getRaw(cell2, property).fold(function() {
            return getter(cell2) + "px";
          }, function(raw) {
            return raw;
          });
        };
        var getRawW = function(cell2, tableSize) {
          return getRaw$1(cell2, "width", function(e) {
            return Sizes.getPixelWidth(e, tableSize);
          });
        };
        var getRawH = function(cell2) {
          return getRaw$1(cell2, "height", Sizes.getHeight);
        };
        var getWidthFrom = function(warehouse, direction, getWidth2, fallback, tableSize) {
          var columns2 = Blocks.columns(warehouse);
          var backups = map(columns2, function(cellOption) {
            return cellOption.map(direction.edge);
          });
          return map(columns2, function(cellOption, c) {
            var columnCell = cellOption.filter(not(CellUtils.hasColspan));
            return columnCell.fold(function() {
              var deduced = deduce(backups, c);
              return fallback(deduced);
            }, function(cell2) {
              return getWidth2(cell2, tableSize);
            });
          });
        };
        var getDeduced = function(deduced) {
          return deduced.map(function(d) {
            return d + "px";
          }).getOr("");
        };
        var getRawWidths = function(warehouse, direction, tableSize) {
          return getWidthFrom(warehouse, direction, getRawW, getDeduced, tableSize);
        };
        var getPercentageWidths = function(warehouse, direction, tableSize) {
          return getWidthFrom(warehouse, direction, Sizes.getPercentageWidth, function(deduced) {
            return deduced.fold(function() {
              return tableSize.minCellWidth();
            }, function(cellWidth) {
              return cellWidth / tableSize.pixelWidth() * 100;
            });
          }, tableSize);
        };
        var getPixelWidths = function(warehouse, direction, tableSize) {
          return getWidthFrom(warehouse, direction, Sizes.getPixelWidth, function(deduced) {
            return deduced.getOrThunk(tableSize.minCellWidth);
          }, tableSize);
        };
        var getHeightFrom = function(warehouse, direction, getHeight2, fallback) {
          var rows2 = Blocks.rows(warehouse);
          var backups = map(rows2, function(cellOption) {
            return cellOption.map(direction.edge);
          });
          return map(rows2, function(cellOption, c) {
            var rowCell = cellOption.filter(not(CellUtils.hasRowspan));
            return rowCell.fold(function() {
              var deduced = deduce(backups, c);
              return fallback(deduced);
            }, function(cell2) {
              return getHeight2(cell2);
            });
          });
        };
        var getPixelHeights = function(warehouse, direction) {
          return getHeightFrom(warehouse, direction, Sizes.getHeight, function(deduced) {
            return deduced.getOrThunk(CellUtils.minHeight);
          });
        };
        var getRawHeights = function(warehouse, direction) {
          return getHeightFrom(warehouse, direction, getRawH, getDeduced);
        };
        var ColumnSizes = {
          getRawWidths,
          getPixelWidths,
          getPercentageWidths,
          getPixelHeights,
          getRawHeights
        };
        var total = function(start, end, measures) {
          var r2 = 0;
          for (var i = start; i < end; i++) {
            r2 += measures[i] !== void 0 ? measures[i] : 0;
          }
          return r2;
        };
        var recalculateWidth = function(warehouse, widths) {
          var all2 = Warehouse.justCells(warehouse);
          return map(all2, function(cell2) {
            var width = total(cell2.column(), cell2.column() + cell2.colspan(), widths);
            return {
              element: cell2.element,
              width: constant(width),
              colspan: cell2.colspan
            };
          });
        };
        var recalculateHeight = function(warehouse, heights) {
          var all2 = Warehouse.justCells(warehouse);
          return map(all2, function(cell2) {
            var height2 = total(cell2.row(), cell2.row() + cell2.rowspan(), heights);
            return {
              element: cell2.element,
              height: constant(height2),
              rowspan: cell2.rowspan
            };
          });
        };
        var matchRowHeight = function(warehouse, heights) {
          return map(warehouse.all(), function(row2, i) {
            return {
              element: row2.element,
              height: constant(heights[i])
            };
          });
        };
        var Recalculations = {
          recalculateWidth,
          recalculateHeight,
          matchRowHeight
        };
        var percentageSize = function(width, element) {
          var floatWidth = parseFloat(width);
          var pixelWidth = get$4(element);
          var getCellDelta = function(delta2) {
            return delta2 / pixelWidth * 100;
          };
          var singleColumnWidth = function(w, _delta) {
            return [100 - w];
          };
          var minCellWidth = function() {
            return CellUtils.minWidth() / pixelWidth * 100;
          };
          var setTableWidth = function(table3, _newWidths, delta2) {
            var ratio = delta2 / 100;
            var change = ratio * floatWidth;
            Sizes.setPercentageWidth(table3, floatWidth + change);
          };
          return {
            width: constant(floatWidth),
            pixelWidth: constant(pixelWidth),
            getWidths: ColumnSizes.getPercentageWidths,
            getCellDelta,
            singleColumnWidth,
            minCellWidth,
            setElementWidth: Sizes.setPercentageWidth,
            setTableWidth
          };
        };
        var pixelSize = function(width) {
          var getCellDelta = identity;
          var singleColumnWidth = function(w, delta2) {
            var newNext = Math.max(CellUtils.minWidth(), w + delta2);
            return [newNext - w];
          };
          var setTableWidth = function(table3, newWidths, _delta) {
            var total2 = foldr(newWidths, function(b, a) {
              return b + a;
            }, 0);
            Sizes.setPixelWidth(table3, total2);
          };
          return {
            width: constant(width),
            pixelWidth: constant(width),
            getWidths: ColumnSizes.getPixelWidths,
            getCellDelta,
            singleColumnWidth,
            minCellWidth: CellUtils.minWidth,
            setElementWidth: Sizes.setPixelWidth,
            setTableWidth
          };
        };
        var chooseSize = function(element, width) {
          var percentMatch = Sizes.percentageBasedSizeRegex().exec(width);
          if (percentMatch !== null) {
            return percentageSize(percentMatch[1], element);
          }
          var pixelMatch = Sizes.pixelBasedSizeRegex().exec(width);
          if (pixelMatch !== null) {
            var intWidth = parseInt(pixelMatch[1], 10);
            return pixelSize(intWidth);
          }
          var fallbackWidth = get$4(element);
          return pixelSize(fallbackWidth);
        };
        var getTableSize = function(element) {
          var width = Sizes.getRawWidth(element);
          return width.fold(function() {
            var fallbackWidth = get$4(element);
            return pixelSize(fallbackWidth);
          }, function(w) {
            return chooseSize(element, w);
          });
        };
        var TableSize = { getTableSize };
        var getWarehouse$1 = function(list) {
          return Warehouse.generate(list);
        };
        var sumUp = function(newSize) {
          return foldr(newSize, function(b, a) {
            return b + a;
          }, 0);
        };
        var getTableWarehouse = function(table3) {
          var list = DetailsList.fromTable(table3);
          return getWarehouse$1(list);
        };
        var adjustWidth = function(table3, delta2, index, direction) {
          var tableSize = TableSize.getTableSize(table3);
          var step = tableSize.getCellDelta(delta2);
          var warehouse = getTableWarehouse(table3);
          var widths = tableSize.getWidths(warehouse, direction, tableSize);
          var deltas = Deltas.determine(widths, index, step, tableSize);
          var newWidths = map(deltas, function(dx, i) {
            return dx + widths[i];
          });
          var newSizes = Recalculations.recalculateWidth(warehouse, newWidths);
          each(newSizes, function(cell2) {
            tableSize.setElementWidth(cell2.element(), cell2.width());
          });
          if (index === warehouse.grid().columns() - 1) {
            tableSize.setTableWidth(table3, newWidths, step);
          }
        };
        var adjustHeight = function(table3, delta2, index, direction) {
          var warehouse = getTableWarehouse(table3);
          var heights = ColumnSizes.getPixelHeights(warehouse, direction);
          var newHeights = map(heights, function(dy, i) {
            return index === i ? Math.max(delta2 + dy, CellUtils.minHeight()) : dy;
          });
          var newCellSizes = Recalculations.recalculateHeight(warehouse, newHeights);
          var newRowSizes = Recalculations.matchRowHeight(warehouse, newHeights);
          each(newRowSizes, function(row2) {
            Sizes.setHeight(row2.element(), row2.height());
          });
          each(newCellSizes, function(cell2) {
            Sizes.setHeight(cell2.element(), cell2.height());
          });
          var total2 = sumUp(newHeights);
          Sizes.setHeight(table3, total2);
        };
        var adjustWidthTo = function(table3, list, direction) {
          var tableSize = TableSize.getTableSize(table3);
          var warehouse = getWarehouse$1(list);
          var widths = tableSize.getWidths(warehouse, direction, tableSize);
          var newSizes = Recalculations.recalculateWidth(warehouse, widths);
          each(newSizes, function(cell2) {
            tableSize.setElementWidth(cell2.element(), cell2.width());
          });
          if (newSizes.length > 0) {
            tableSize.setTableWidth(table3, widths, tableSize.getCellDelta(0));
          }
        };
        var Adjustments = {
          adjustWidth,
          adjustHeight,
          adjustWidthTo
        };
        var Cell = function(initial) {
          var value2 = initial;
          var get2 = function() {
            return value2;
          };
          var set2 = function(v) {
            value2 = v;
          };
          var clone2 = function() {
            return Cell(get2());
          };
          return {
            get: get2,
            set: set2,
            clone: clone2
          };
        };
        var base = function(handleUnsupported, required) {
          return baseWith(handleUnsupported, required, {
            validate: isFunction,
            label: "function"
          });
        };
        var baseWith = function(handleUnsupported, required, pred) {
          if (required.length === 0) {
            throw new Error("You must specify at least one required field.");
          }
          validateStrArr("required", required);
          checkDupes(required);
          return function(obj) {
            var keys$1 = keys(obj);
            var allReqd = forall(required, function(req) {
              return contains(keys$1, req);
            });
            if (!allReqd) {
              reqMessage(required, keys$1);
            }
            handleUnsupported(required, keys$1);
            var invalidKeys = filter(required, function(key2) {
              return !pred.validate(obj[key2], key2);
            });
            if (invalidKeys.length > 0) {
              invalidTypeMessage(invalidKeys, pred.label);
            }
            return obj;
          };
        };
        var handleExact = function(required, keys2) {
          var unsupported = filter(keys2, function(key2) {
            return !contains(required, key2);
          });
          if (unsupported.length > 0) {
            unsuppMessage(unsupported);
          }
        };
        var exactly = function(required) {
          return base(handleExact, required);
        };
        var verifyGenerators = exactly([
          "cell",
          "row",
          "replace",
          "gap"
        ]);
        var elementToData = function(element) {
          var colspan = has(element, "colspan") ? parseInt(get(element, "colspan"), 10) : 1;
          var rowspan = has(element, "rowspan") ? parseInt(get(element, "rowspan"), 10) : 1;
          return {
            element: constant(element),
            colspan: constant(colspan),
            rowspan: constant(rowspan)
          };
        };
        var modification = function(generators, toData) {
          if (toData === void 0) {
            toData = elementToData;
          }
          verifyGenerators(generators);
          var position = Cell(Option.none());
          var nu2 = function(data) {
            return generators.cell(data);
          };
          var nuFrom = function(element) {
            var data = toData(element);
            return nu2(data);
          };
          var add2 = function(element) {
            var replacement = nuFrom(element);
            if (position.get().isNone()) {
              position.set(Option.some(replacement));
            }
            recent = Option.some({
              item: element,
              replacement
            });
            return replacement;
          };
          var recent = Option.none();
          var getOrInit = function(element, comparator) {
            return recent.fold(function() {
              return add2(element);
            }, function(p) {
              return comparator(element, p.item) ? p.replacement : add2(element);
            });
          };
          return {
            getOrInit,
            cursor: position.get
          };
        };
        var transform = function(scope, tag) {
          return function(generators) {
            var position = Cell(Option.none());
            verifyGenerators(generators);
            var list = [];
            var find$12 = function(element, comparator) {
              return find(list, function(x) {
                return comparator(x.item, element);
              });
            };
            var makeNew = function(element) {
              var attrs = { scope };
              var cell2 = generators.replace(element, tag, attrs);
              list.push({
                item: element,
                sub: cell2
              });
              if (position.get().isNone()) {
                position.set(Option.some(cell2));
              }
              return cell2;
            };
            var replaceOrInit = function(element, comparator) {
              return find$12(element, comparator).fold(function() {
                return makeNew(element);
              }, function(p) {
                return comparator(element, p.item) ? p.sub : makeNew(element);
              });
            };
            return {
              replaceOrInit,
              cursor: position.get
            };
          };
        };
        var merging = function(generators) {
          verifyGenerators(generators);
          var position = Cell(Option.none());
          var combine = function(cell2) {
            if (position.get().isNone()) {
              position.set(Option.some(cell2));
            }
            return function() {
              var raw = generators.cell({
                element: constant(cell2),
                colspan: constant(1),
                rowspan: constant(1)
              });
              remove$1(raw, "width");
              remove$1(cell2, "width");
              return raw;
            };
          };
          return {
            combine,
            cursor: position.get
          };
        };
        var Generators = {
          modification,
          transform,
          merging
        };
        var blockList = [
          "body",
          "p",
          "div",
          "article",
          "aside",
          "figcaption",
          "figure",
          "footer",
          "header",
          "nav",
          "section",
          "ol",
          "ul",
          "table",
          "thead",
          "tfoot",
          "tbody",
          "caption",
          "tr",
          "td",
          "th",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "blockquote",
          "pre",
          "address"
        ];
        var isList = function(universe2, item) {
          var tagName = universe2.property().name(item);
          return contains([
            "ol",
            "ul"
          ], tagName);
        };
        var isBlock = function(universe2, item) {
          var tagName = universe2.property().name(item);
          return contains(blockList, tagName);
        };
        var isFormatting = function(universe2, item) {
          var tagName = universe2.property().name(item);
          return contains([
            "address",
            "pre",
            "p",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6"
          ], tagName);
        };
        var isHeading = function(universe2, item) {
          var tagName = universe2.property().name(item);
          return contains([
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6"
          ], tagName);
        };
        var isContainer = function(universe2, item) {
          return contains([
            "div",
            "li",
            "td",
            "th",
            "blockquote",
            "body",
            "caption"
          ], universe2.property().name(item));
        };
        var isEmptyTag = function(universe2, item) {
          return contains([
            "br",
            "img",
            "hr",
            "input"
          ], universe2.property().name(item));
        };
        var isFrame = function(universe2, item) {
          return universe2.property().name(item) === "iframe";
        };
        var isInline = function(universe2, item) {
          return !(isBlock(universe2, item) || isEmptyTag(universe2, item)) && universe2.property().name(item) !== "li";
        };
        var Structure = {
          isBlock,
          isList,
          isFormatting,
          isHeading,
          isContainer,
          isEmptyTag,
          isFrame,
          isInline
        };
        var universe$1 = DomUniverse();
        var isBlock$1 = function(element) {
          return Structure.isBlock(universe$1, element);
        };
        var isList$1 = function(element) {
          return Structure.isList(universe$1, element);
        };
        var isFormatting$1 = function(element) {
          return Structure.isFormatting(universe$1, element);
        };
        var isHeading$1 = function(element) {
          return Structure.isHeading(universe$1, element);
        };
        var isContainer$1 = function(element) {
          return Structure.isContainer(universe$1, element);
        };
        var isEmptyTag$1 = function(element) {
          return Structure.isEmptyTag(universe$1, element);
        };
        var isFrame$1 = function(element) {
          return Structure.isFrame(universe$1, element);
        };
        var isInline$1 = function(element) {
          return Structure.isInline(universe$1, element);
        };
        var DomStructure = {
          isBlock: isBlock$1,
          isList: isList$1,
          isFormatting: isFormatting$1,
          isHeading: isHeading$1,
          isContainer: isContainer$1,
          isEmptyTag: isEmptyTag$1,
          isFrame: isFrame$1,
          isInline: isInline$1
        };
        var merge$2 = function(cells2) {
          var isBr2 = function(el) {
            return name(el) === "br";
          };
          var advancedBr = function(children2) {
            return forall(children2, function(c) {
              return isBr2(c) || isText(c) && get$2(c).trim().length === 0;
            });
          };
          var isListItem = function(el) {
            return name(el) === "li" || ancestor(el, DomStructure.isList).isSome();
          };
          var siblingIsBlock = function(el) {
            return nextSibling(el).map(function(rightSibling) {
              if (DomStructure.isBlock(rightSibling)) {
                return true;
              }
              if (DomStructure.isEmptyTag(rightSibling)) {
                return name(rightSibling) === "img" ? false : true;
              }
              return false;
            }).getOr(false);
          };
          var markCell = function(cell2) {
            return last$1(cell2).bind(function(rightEdge) {
              var rightSiblingIsBlock = siblingIsBlock(rightEdge);
              return parent(rightEdge).map(function(parent2) {
                return rightSiblingIsBlock === true || isListItem(parent2) || isBr2(rightEdge) || DomStructure.isBlock(parent2) && !eq(cell2, parent2) ? [] : [Element.fromTag("br")];
              });
            }).getOr([]);
          };
          var markContent = function() {
            var content = bind(cells2, function(cell2) {
              var children$12 = children(cell2);
              return advancedBr(children$12) ? [] : children$12.concat(markCell(cell2));
            });
            return content.length === 0 ? [Element.fromTag("br")] : content;
          };
          var contents = markContent();
          empty(cells2[0]);
          append$1(cells2[0], contents);
        };
        var TableContent = { merge: merge$2 };
        var prune = function(table3) {
          var cells2 = TableLookup.cells(table3);
          if (cells2.length === 0) {
            remove$2(table3);
          }
        };
        var outcome = Immutable("grid", "cursor");
        var elementFromGrid = function(grid2, row2, column) {
          return findIn(grid2, row2, column).orThunk(function() {
            return findIn(grid2, 0, 0);
          });
        };
        var findIn = function(grid2, row2, column) {
          return Option.from(grid2[row2]).bind(function(r2) {
            return Option.from(r2.cells()[column]).bind(function(c) {
              return Option.from(c.element());
            });
          });
        };
        var bundle = function(grid2, row2, column) {
          return outcome(grid2, findIn(grid2, row2, column));
        };
        var uniqueRows = function(details) {
          return foldl(details, function(rest, detail2) {
            return exists(rest, function(currentDetail) {
              return currentDetail.row() === detail2.row();
            }) ? rest : rest.concat([detail2]);
          }, []).sort(function(detailA, detailB) {
            return detailA.row() - detailB.row();
          });
        };
        var uniqueColumns = function(details) {
          return foldl(details, function(rest, detail2) {
            return exists(rest, function(currentDetail) {
              return currentDetail.column() === detail2.column();
            }) ? rest : rest.concat([detail2]);
          }, []).sort(function(detailA, detailB) {
            return detailA.column() - detailB.column();
          });
        };
        var insertRowBefore = function(grid2, detail2, comparator, genWrappers) {
          var example = detail2.row();
          var targetIndex = detail2.row();
          var newGrid = ModificationOperations.insertRowAt(grid2, targetIndex, example, comparator, genWrappers.getOrInit);
          return bundle(newGrid, targetIndex, detail2.column());
        };
        var insertRowsBefore = function(grid2, details, comparator, genWrappers) {
          var example = details[0].row();
          var targetIndex = details[0].row();
          var rows2 = uniqueRows(details);
          var newGrid = foldl(rows2, function(newG, _row) {
            return ModificationOperations.insertRowAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
          }, grid2);
          return bundle(newGrid, targetIndex, details[0].column());
        };
        var insertRowAfter = function(grid2, detail2, comparator, genWrappers) {
          var example = detail2.row();
          var targetIndex = detail2.row() + detail2.rowspan();
          var newGrid = ModificationOperations.insertRowAt(grid2, targetIndex, example, comparator, genWrappers.getOrInit);
          return bundle(newGrid, targetIndex, detail2.column());
        };
        var insertRowsAfter = function(grid2, details, comparator, genWrappers) {
          var rows2 = uniqueRows(details);
          var example = rows2[rows2.length - 1].row();
          var targetIndex = rows2[rows2.length - 1].row() + rows2[rows2.length - 1].rowspan();
          var newGrid = foldl(rows2, function(newG, _row) {
            return ModificationOperations.insertRowAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
          }, grid2);
          return bundle(newGrid, targetIndex, details[0].column());
        };
        var insertColumnBefore = function(grid2, detail2, comparator, genWrappers) {
          var example = detail2.column();
          var targetIndex = detail2.column();
          var newGrid = ModificationOperations.insertColumnAt(grid2, targetIndex, example, comparator, genWrappers.getOrInit);
          return bundle(newGrid, detail2.row(), targetIndex);
        };
        var insertColumnsBefore = function(grid2, details, comparator, genWrappers) {
          var columns2 = uniqueColumns(details);
          var example = columns2[0].column();
          var targetIndex = columns2[0].column();
          var newGrid = foldl(columns2, function(newG, _row) {
            return ModificationOperations.insertColumnAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
          }, grid2);
          return bundle(newGrid, details[0].row(), targetIndex);
        };
        var insertColumnAfter = function(grid2, detail2, comparator, genWrappers) {
          var example = detail2.column();
          var targetIndex = detail2.column() + detail2.colspan();
          var newGrid = ModificationOperations.insertColumnAt(grid2, targetIndex, example, comparator, genWrappers.getOrInit);
          return bundle(newGrid, detail2.row(), targetIndex);
        };
        var insertColumnsAfter = function(grid2, details, comparator, genWrappers) {
          var example = details[details.length - 1].column();
          var targetIndex = details[details.length - 1].column() + details[details.length - 1].colspan();
          var columns2 = uniqueColumns(details);
          var newGrid = foldl(columns2, function(newG, _row) {
            return ModificationOperations.insertColumnAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
          }, grid2);
          return bundle(newGrid, details[0].row(), targetIndex);
        };
        var makeRowHeader = function(grid2, detail2, comparator, genWrappers) {
          var newGrid = TransformOperations.replaceRow(grid2, detail2.row(), comparator, genWrappers.replaceOrInit);
          return bundle(newGrid, detail2.row(), detail2.column());
        };
        var makeColumnHeader = function(grid2, detail2, comparator, genWrappers) {
          var newGrid = TransformOperations.replaceColumn(grid2, detail2.column(), comparator, genWrappers.replaceOrInit);
          return bundle(newGrid, detail2.row(), detail2.column());
        };
        var unmakeRowHeader = function(grid2, detail2, comparator, genWrappers) {
          var newGrid = TransformOperations.replaceRow(grid2, detail2.row(), comparator, genWrappers.replaceOrInit);
          return bundle(newGrid, detail2.row(), detail2.column());
        };
        var unmakeColumnHeader = function(grid2, detail2, comparator, genWrappers) {
          var newGrid = TransformOperations.replaceColumn(grid2, detail2.column(), comparator, genWrappers.replaceOrInit);
          return bundle(newGrid, detail2.row(), detail2.column());
        };
        var splitCellIntoColumns$1 = function(grid2, detail2, comparator, genWrappers) {
          var newGrid = ModificationOperations.splitCellIntoColumns(grid2, detail2.row(), detail2.column(), comparator, genWrappers.getOrInit);
          return bundle(newGrid, detail2.row(), detail2.column());
        };
        var splitCellIntoRows$1 = function(grid2, detail2, comparator, genWrappers) {
          var newGrid = ModificationOperations.splitCellIntoRows(grid2, detail2.row(), detail2.column(), comparator, genWrappers.getOrInit);
          return bundle(newGrid, detail2.row(), detail2.column());
        };
        var eraseColumns = function(grid2, details, _comparator, _genWrappers) {
          var columns2 = uniqueColumns(details);
          var newGrid = ModificationOperations.deleteColumnsAt(grid2, columns2[0].column(), columns2[columns2.length - 1].column());
          var cursor = elementFromGrid(newGrid, details[0].row(), details[0].column());
          return outcome(newGrid, cursor);
        };
        var eraseRows = function(grid2, details, _comparator, _genWrappers) {
          var rows2 = uniqueRows(details);
          var newGrid = ModificationOperations.deleteRowsAt(grid2, rows2[0].row(), rows2[rows2.length - 1].row());
          var cursor = elementFromGrid(newGrid, details[0].row(), details[0].column());
          return outcome(newGrid, cursor);
        };
        var mergeCells = function(grid2, mergable2, comparator, _genWrappers) {
          var cells2 = mergable2.cells();
          TableContent.merge(cells2);
          var newGrid = MergingOperations.merge(grid2, mergable2.bounds(), comparator, constant(cells2[0]));
          return outcome(newGrid, Option.from(cells2[0]));
        };
        var unmergeCells = function(grid2, unmergable2, comparator, genWrappers) {
          var newGrid = foldr(unmergable2, function(b, cell2) {
            return MergingOperations.unmerge(b, cell2, comparator, genWrappers.combine(cell2));
          }, grid2);
          return outcome(newGrid, Option.from(unmergable2[0]));
        };
        var pasteCells = function(grid2, pasteDetails, comparator, _genWrappers) {
          var gridify = function(table3, generators) {
            var list = DetailsList.fromTable(table3);
            var wh = Warehouse.generate(list);
            return Transitions.toGrid(wh, generators, true);
          };
          var gridB = gridify(pasteDetails.clipboard(), pasteDetails.generators());
          var startAddress = address(pasteDetails.row(), pasteDetails.column());
          var mergedGrid = TableMerge.merge(startAddress, grid2, gridB, pasteDetails.generators(), comparator);
          return mergedGrid.fold(function() {
            return outcome(grid2, Option.some(pasteDetails.element()));
          }, function(nuGrid) {
            var cursor = elementFromGrid(nuGrid, pasteDetails.row(), pasteDetails.column());
            return outcome(nuGrid, cursor);
          });
        };
        var gridifyRows = function(rows2, generators, example) {
          var pasteDetails = DetailsList.fromPastedRows(rows2, example);
          var wh = Warehouse.generate(pasteDetails);
          return Transitions.toGrid(wh, generators, true);
        };
        var pasteRowsBefore = function(grid2, pasteDetails, comparator, _genWrappers) {
          var example = grid2[pasteDetails.cells[0].row()];
          var index = pasteDetails.cells[0].row();
          var gridB = gridifyRows(pasteDetails.clipboard(), pasteDetails.generators(), example);
          var mergedGrid = TableMerge.insert(index, grid2, gridB, pasteDetails.generators(), comparator);
          var cursor = elementFromGrid(mergedGrid, pasteDetails.cells[0].row(), pasteDetails.cells[0].column());
          return outcome(mergedGrid, cursor);
        };
        var pasteRowsAfter = function(grid2, pasteDetails, comparator, _genWrappers) {
          var example = grid2[pasteDetails.cells[0].row()];
          var index = pasteDetails.cells[pasteDetails.cells.length - 1].row() + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan();
          var gridB = gridifyRows(pasteDetails.clipboard(), pasteDetails.generators(), example);
          var mergedGrid = TableMerge.insert(index, grid2, gridB, pasteDetails.generators(), comparator);
          var cursor = elementFromGrid(mergedGrid, pasteDetails.cells[0].row(), pasteDetails.cells[0].column());
          return outcome(mergedGrid, cursor);
        };
        var resize = Adjustments.adjustWidthTo;
        var TableOperations = {
          insertRowBefore: run(insertRowBefore, onCell, noop, noop, Generators.modification),
          insertRowsBefore: run(insertRowsBefore, onCells, noop, noop, Generators.modification),
          insertRowAfter: run(insertRowAfter, onCell, noop, noop, Generators.modification),
          insertRowsAfter: run(insertRowsAfter, onCells, noop, noop, Generators.modification),
          insertColumnBefore: run(insertColumnBefore, onCell, resize, noop, Generators.modification),
          insertColumnsBefore: run(insertColumnsBefore, onCells, resize, noop, Generators.modification),
          insertColumnAfter: run(insertColumnAfter, onCell, resize, noop, Generators.modification),
          insertColumnsAfter: run(insertColumnsAfter, onCells, resize, noop, Generators.modification),
          splitCellIntoColumns: run(splitCellIntoColumns$1, onCell, resize, noop, Generators.modification),
          splitCellIntoRows: run(splitCellIntoRows$1, onCell, noop, noop, Generators.modification),
          eraseColumns: run(eraseColumns, onCells, resize, prune, Generators.modification),
          eraseRows: run(eraseRows, onCells, noop, prune, Generators.modification),
          makeColumnHeader: run(makeColumnHeader, onCell, noop, noop, Generators.transform("row", "th")),
          unmakeColumnHeader: run(unmakeColumnHeader, onCell, noop, noop, Generators.transform(null, "td")),
          makeRowHeader: run(makeRowHeader, onCell, noop, noop, Generators.transform("col", "th")),
          unmakeRowHeader: run(unmakeRowHeader, onCell, noop, noop, Generators.transform(null, "td")),
          mergeCells: run(mergeCells, onMergable, noop, noop, Generators.merging),
          unmergeCells: run(unmergeCells, onUnmergable, resize, noop, Generators.merging),
          pasteCells: run(pasteCells, onPaste, resize, noop, Generators.modification),
          pasteRowsBefore: run(pasteRowsBefore, onPasteRows, noop, noop, Generators.modification),
          pasteRowsAfter: run(pasteRowsAfter, onPasteRows, noop, noop, Generators.modification)
        };
        var getBody$1 = function(editor) {
          return Element.fromDom(editor.getBody());
        };
        var getPixelWidth$1 = function(elm) {
          return elm.getBoundingClientRect().width;
        };
        var getPixelHeight = function(elm) {
          return elm.getBoundingClientRect().height;
        };
        var getIsRoot = function(editor) {
          return function(element) {
            return eq(element, getBody$1(editor));
          };
        };
        var removePxSuffix = function(size) {
          return size ? size.replace(/px$/, "") : "";
        };
        var addSizeSuffix = function(size) {
          if (/^[0-9]+$/.test(size)) {
            size += "px";
          }
          return size;
        };
        var removeDataStyle = function(table3) {
          var dataStyleCells = descendants$1(table3, "td[data-mce-style],th[data-mce-style]");
          remove(table3, "data-mce-style");
          each(dataStyleCells, function(cell2) {
            remove(cell2, "data-mce-style");
          });
        };
        var getDirection = function(element) {
          return get$1(element, "direction") === "rtl" ? "rtl" : "ltr";
        };
        var ltr$1 = { isRtl: constant(false) };
        var rtl$1 = { isRtl: constant(true) };
        var directionAt = function(element) {
          var dir = getDirection(element);
          return dir === "rtl" ? rtl$1 : ltr$1;
        };
        var Direction = { directionAt };
        var defaultTableToolbar = [
          "tableprops",
          "tabledelete",
          "|",
          "tableinsertrowbefore",
          "tableinsertrowafter",
          "tabledeleterow",
          "|",
          "tableinsertcolbefore",
          "tableinsertcolafter",
          "tabledeletecol"
        ];
        var defaultStyles = {
          "border-collapse": "collapse",
          "width": "100%"
        };
        var defaultAttributes = { border: "1" };
        var getDefaultAttributes = function(editor) {
          return editor.getParam("table_default_attributes", defaultAttributes, "object");
        };
        var getDefaultStyles = function(editor) {
          return editor.getParam("table_default_styles", defaultStyles, "object");
        };
        var hasTableResizeBars = function(editor) {
          return editor.getParam("table_resize_bars", true, "boolean");
        };
        var hasTabNavigation = function(editor) {
          return editor.getParam("table_tab_navigation", true, "boolean");
        };
        var hasAdvancedCellTab = function(editor) {
          return editor.getParam("table_cell_advtab", true, "boolean");
        };
        var hasAdvancedRowTab = function(editor) {
          return editor.getParam("table_row_advtab", true, "boolean");
        };
        var hasAdvancedTableTab = function(editor) {
          return editor.getParam("table_advtab", true, "boolean");
        };
        var hasAppearanceOptions = function(editor) {
          return editor.getParam("table_appearance_options", true, "boolean");
        };
        var hasTableGrid = function(editor) {
          return editor.getParam("table_grid", true, "boolean");
        };
        var shouldStyleWithCss = function(editor) {
          return editor.getParam("table_style_by_css", false, "boolean");
        };
        var getCellClassList = function(editor) {
          return editor.getParam("table_cell_class_list", [], "array");
        };
        var getRowClassList = function(editor) {
          return editor.getParam("table_row_class_list", [], "array");
        };
        var getTableClassList = function(editor) {
          return editor.getParam("table_class_list", [], "array");
        };
        var getColorPickerCallback = function(editor) {
          return editor.getParam("color_picker_callback");
        };
        var isPixelsForced = function(editor) {
          return editor.getParam("table_responsive_width") === false;
        };
        var getCloneElements = function(editor) {
          var cloneElements = editor.getParam("table_clone_elements");
          if (isString(cloneElements)) {
            return Option.some(cloneElements.split(/[ ,]/));
          } else if (Array.isArray(cloneElements)) {
            return Option.some(cloneElements);
          } else {
            return Option.none();
          }
        };
        var hasObjectResizing = function(editor) {
          var objectResizing = editor.getParam("object_resizing", true);
          return objectResizing === "table" || objectResizing;
        };
        var getToolbar = function(editor) {
          var toolbar = editor.getParam("table_toolbar", defaultTableToolbar);
          if (toolbar === "" || toolbar === false) {
            return [];
          } else if (isString(toolbar)) {
            return toolbar.split(/[ ,]/);
          } else if (isArray(toolbar)) {
            return toolbar;
          } else {
            return [];
          }
        };
        var fireNewRow = function(editor, row2) {
          return editor.fire("newrow", { node: row2 });
        };
        var fireNewCell = function(editor, cell2) {
          return editor.fire("newcell", { node: cell2 });
        };
        var fireObjectResizeStart = function(editor, target, width, height2) {
          editor.fire("ObjectResizeStart", {
            target,
            width,
            height: height2
          });
        };
        var fireObjectResized = function(editor, target, width, height2) {
          editor.fire("ObjectResized", {
            target,
            width,
            height: height2
          });
        };
        var TableActions = function(editor, lazyWire) {
          var isTableBody = function(editor2) {
            return name(getBody$1(editor2)) === "table";
          };
          var lastRowGuard = function(table3) {
            var size = TableGridSize.getGridSize(table3);
            return isTableBody(editor) === false || size.rows() > 1;
          };
          var lastColumnGuard = function(table3) {
            var size = TableGridSize.getGridSize(table3);
            return isTableBody(editor) === false || size.columns() > 1;
          };
          var cloneFormats2 = getCloneElements(editor);
          var execute = function(operation, guard, mutate2, lazyWire2) {
            return function(table3, target) {
              removeDataStyle(table3);
              var wire = lazyWire2();
              var doc = Element.fromDom(editor.getDoc());
              var direction = TableDirection(Direction.directionAt);
              var generators = TableFill.cellOperations(mutate2, doc, cloneFormats2);
              return guard(table3) ? operation(wire, table3, target, generators, direction).bind(function(result) {
                each(result.newRows(), function(row2) {
                  fireNewRow(editor, row2.dom());
                });
                each(result.newCells(), function(cell2) {
                  fireNewCell(editor, cell2.dom());
                });
                return result.cursor().map(function(cell2) {
                  var rng = editor.dom.createRng();
                  rng.setStart(cell2.dom(), 0);
                  rng.setEnd(cell2.dom(), 0);
                  return rng;
                });
              }) : Option.none();
            };
          };
          var deleteRow = execute(TableOperations.eraseRows, lastRowGuard, noop, lazyWire);
          var deleteColumn = execute(TableOperations.eraseColumns, lastColumnGuard, noop, lazyWire);
          var insertRowsBefore2 = execute(TableOperations.insertRowsBefore, always, noop, lazyWire);
          var insertRowsAfter2 = execute(TableOperations.insertRowsAfter, always, noop, lazyWire);
          var insertColumnsBefore2 = execute(TableOperations.insertColumnsBefore, always, CellMutations.halve, lazyWire);
          var insertColumnsAfter2 = execute(TableOperations.insertColumnsAfter, always, CellMutations.halve, lazyWire);
          var mergeCells2 = execute(TableOperations.mergeCells, always, noop, lazyWire);
          var unmergeCells2 = execute(TableOperations.unmergeCells, always, noop, lazyWire);
          var pasteRowsBefore2 = execute(TableOperations.pasteRowsBefore, always, noop, lazyWire);
          var pasteRowsAfter2 = execute(TableOperations.pasteRowsAfter, always, noop, lazyWire);
          var pasteCells2 = execute(TableOperations.pasteCells, always, noop, lazyWire);
          return {
            deleteRow,
            deleteColumn,
            insertRowsBefore: insertRowsBefore2,
            insertRowsAfter: insertRowsAfter2,
            insertColumnsBefore: insertColumnsBefore2,
            insertColumnsAfter: insertColumnsAfter2,
            mergeCells: mergeCells2,
            unmergeCells: unmergeCells2,
            pasteRowsBefore: pasteRowsBefore2,
            pasteRowsAfter: pasteRowsAfter2,
            pasteCells: pasteCells2
          };
        };
        var copyRows = function(table3, target, generators) {
          var list = DetailsList.fromTable(table3);
          var house = Warehouse.generate(list);
          var details = onCells(house, target);
          return details.map(function(selectedCells) {
            var grid2 = Transitions.toGrid(house, generators, false);
            var slicedGrid = grid2.slice(selectedCells[0].row(), selectedCells[selectedCells.length - 1].row() + selectedCells[selectedCells.length - 1].rowspan());
            var slicedDetails = toDetailList(slicedGrid, generators);
            return Redraw.copy(slicedDetails);
          });
        };
        var CopyRows = { copyRows };
        var global$1 = tinymce.util.Tools.resolve("tinymce.util.Tools");
        var getTDTHOverallStyle = function(dom, elm, name2) {
          var cells2 = dom.select("td,th", elm);
          var firstChildStyle;
          var checkChildren = function(firstChildStyle2, elms) {
            for (var i = 0; i < elms.length; i++) {
              var currentStyle = dom.getStyle(elms[i], name2);
              if (typeof firstChildStyle2 === "undefined") {
                firstChildStyle2 = currentStyle;
              }
              if (firstChildStyle2 !== currentStyle) {
                return "";
              }
            }
            return firstChildStyle2;
          };
          firstChildStyle = checkChildren(firstChildStyle, cells2);
          return firstChildStyle;
        };
        var applyAlign = function(editor, elm, name2) {
          if (name2) {
            editor.formatter.apply("align" + name2, {}, elm);
          }
        };
        var applyVAlign = function(editor, elm, name2) {
          if (name2) {
            editor.formatter.apply("valign" + name2, {}, elm);
          }
        };
        var unApplyAlign = function(editor, elm) {
          global$1.each("left center right".split(" "), function(name2) {
            editor.formatter.remove("align" + name2, {}, elm);
          });
        };
        var unApplyVAlign = function(editor, elm) {
          global$1.each("top middle bottom".split(" "), function(name2) {
            editor.formatter.remove("valign" + name2, {}, elm);
          });
        };
        var Styles$1 = {
          applyAlign,
          applyVAlign,
          unApplyAlign,
          unApplyVAlign,
          getTDTHOverallStyle
        };
        var buildListItems = function(inputList, itemCallback, startItems) {
          var appendItems = function(values, output) {
            output = output || [];
            global$1.each(values, function(item) {
              var menuItem = { text: item.text || item.title };
              if (item.menu) {
                menuItem.menu = appendItems(item.menu);
              } else {
                menuItem.value = item.value;
                if (itemCallback) {
                  itemCallback(menuItem);
                }
              }
              output.push(menuItem);
            });
            return output;
          };
          return appendItems(inputList, startItems || []);
        };
        function styleFieldHasFocus(e) {
          return e.control.rootControl.find("#style")[0].getEl().isEqualNode(domGlobals.document.activeElement);
        }
        var syncAdvancedStyleFields = function(editor, evt) {
          if (styleFieldHasFocus(evt)) {
            updateAdvancedFields(editor, evt);
          } else {
            updateStyleField(editor, evt);
          }
        };
        var updateStyleField = function(editor, evt) {
          var dom = editor.dom;
          var rootControl = evt.control.rootControl;
          var data = rootControl.toJSON();
          var css2 = dom.parseStyle(data.style);
          css2["border-style"] = data.borderStyle;
          css2["border-color"] = data.borderColor;
          css2["background-color"] = data.backgroundColor;
          css2.width = data.width ? addSizeSuffix(data.width) : "";
          css2.height = data.height ? addSizeSuffix(data.height) : "";
          rootControl.find("#style").value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css2))));
        };
        var updateAdvancedFields = function(editor, evt) {
          var dom = editor.dom;
          var rootControl = evt.control.rootControl;
          var data = rootControl.toJSON();
          var css2 = dom.parseStyle(data.style);
          rootControl.find("#borderStyle").value(css2["border-style"] || "");
          rootControl.find("#borderColor").value(css2["border-color"] || "");
          rootControl.find("#backgroundColor").value(css2["background-color"] || "");
          rootControl.find("#width").value(css2.width || "");
          rootControl.find("#height").value(css2.height || "");
        };
        var extractAdvancedStyles = function(dom, elm) {
          var css2 = dom.parseStyle(dom.getAttrib(elm, "style"));
          var data = {};
          if (css2["border-style"]) {
            data.borderStyle = css2["border-style"];
          }
          if (css2["border-color"]) {
            data.borderColor = css2["border-color"];
          }
          if (css2["background-color"]) {
            data.backgroundColor = css2["background-color"];
          }
          data.style = dom.serializeStyle(css2);
          return data;
        };
        var createStyleForm = function(editor) {
          var createColorPickAction = function() {
            var colorPickerCallback = getColorPickerCallback(editor);
            if (colorPickerCallback) {
              return function(evt) {
                return colorPickerCallback.call(editor, function(value2) {
                  evt.control.value(value2).fire("change");
                }, evt.control.value());
              };
            }
          };
          return {
            title: "Advanced",
            type: "form",
            defaults: { onchange: curry(updateStyleField, editor) },
            items: [
              {
                label: "Style",
                name: "style",
                type: "textbox",
                onchange: curry(updateAdvancedFields, editor)
              },
              {
                type: "form",
                padding: 0,
                formItemDefaults: {
                  layout: "grid",
                  alignH: [
                    "start",
                    "right"
                  ]
                },
                defaults: { size: 7 },
                items: [
                  {
                    label: "Border style",
                    type: "listbox",
                    name: "borderStyle",
                    width: 90,
                    onselect: curry(updateStyleField, editor),
                    values: [
                      {
                        text: "Select...",
                        value: ""
                      },
                      {
                        text: "Solid",
                        value: "solid"
                      },
                      {
                        text: "Dotted",
                        value: "dotted"
                      },
                      {
                        text: "Dashed",
                        value: "dashed"
                      },
                      {
                        text: "Double",
                        value: "double"
                      },
                      {
                        text: "Groove",
                        value: "groove"
                      },
                      {
                        text: "Ridge",
                        value: "ridge"
                      },
                      {
                        text: "Inset",
                        value: "inset"
                      },
                      {
                        text: "Outset",
                        value: "outset"
                      },
                      {
                        text: "None",
                        value: "none"
                      },
                      {
                        text: "Hidden",
                        value: "hidden"
                      }
                    ]
                  },
                  {
                    label: "Border color",
                    type: "colorbox",
                    name: "borderColor",
                    onaction: createColorPickAction()
                  },
                  {
                    label: "Background color",
                    type: "colorbox",
                    name: "backgroundColor",
                    onaction: createColorPickAction()
                  }
                ]
              }
            ]
          };
        };
        var Helpers = {
          createStyleForm,
          buildListItems,
          updateStyleField,
          extractAdvancedStyles,
          updateAdvancedFields,
          syncAdvancedStyleFields
        };
        var updateStyles = function(elm, cssText) {
          delete elm.dataset.mceStyle;
          elm.style.cssText += ";" + cssText;
        };
        var extractDataFromElement = function(editor, elm) {
          var dom = editor.dom;
          var data = {
            width: dom.getStyle(elm, "width") || dom.getAttrib(elm, "width"),
            height: dom.getStyle(elm, "height") || dom.getAttrib(elm, "height"),
            scope: dom.getAttrib(elm, "scope"),
            class: dom.getAttrib(elm, "class"),
            type: elm.nodeName.toLowerCase(),
            style: "",
            align: "",
            valign: ""
          };
          global$1.each("left center right".split(" "), function(name2) {
            if (editor.formatter.matchNode(elm, "align" + name2)) {
              data.align = name2;
            }
          });
          global$1.each("top middle bottom".split(" "), function(name2) {
            if (editor.formatter.matchNode(elm, "valign" + name2)) {
              data.valign = name2;
            }
          });
          if (hasAdvancedCellTab(editor)) {
            global$1.extend(data, Helpers.extractAdvancedStyles(dom, elm));
          }
          return data;
        };
        var onSubmitCellForm = function(editor, cells2, evt) {
          var dom = editor.dom;
          var data;
          function setAttrib(elm, name2, value2) {
            if (cells2.length === 1 || value2) {
              dom.setAttrib(elm, name2, value2);
            }
          }
          function setStyle(elm, name2, value2) {
            if (cells2.length === 1 || value2) {
              dom.setStyle(elm, name2, value2);
            }
          }
          if (hasAdvancedCellTab(editor)) {
            Helpers.syncAdvancedStyleFields(editor, evt);
          }
          data = evt.control.rootControl.toJSON();
          editor.undoManager.transact(function() {
            global$1.each(cells2, function(cellElm) {
              setAttrib(cellElm, "scope", data.scope);
              if (cells2.length === 1) {
                setAttrib(cellElm, "style", data.style);
              } else {
                updateStyles(cellElm, data.style);
              }
              setAttrib(cellElm, "class", data.class);
              setStyle(cellElm, "width", addSizeSuffix(data.width));
              setStyle(cellElm, "height", addSizeSuffix(data.height));
              if (data.type && cellElm.nodeName.toLowerCase() !== data.type) {
                cellElm = dom.rename(cellElm, data.type);
              }
              if (cells2.length === 1) {
                Styles$1.unApplyAlign(editor, cellElm);
                Styles$1.unApplyVAlign(editor, cellElm);
              }
              if (data.align) {
                Styles$1.applyAlign(editor, cellElm, data.align);
              }
              if (data.valign) {
                Styles$1.applyVAlign(editor, cellElm, data.valign);
              }
            });
            editor.focus();
          });
        };
        var open = function(editor) {
          var cellElm, data, classListCtrl, cells2 = [];
          cells2 = editor.dom.select("td[data-mce-selected],th[data-mce-selected]");
          cellElm = editor.dom.getParent(editor.selection.getStart(), "td,th");
          if (!cells2.length && cellElm) {
            cells2.push(cellElm);
          }
          cellElm = cellElm || cells2[0];
          if (!cellElm) {
            return;
          }
          if (cells2.length > 1) {
            data = {
              width: "",
              height: "",
              scope: "",
              class: "",
              align: "",
              valign: "",
              style: "",
              type: cellElm.nodeName.toLowerCase()
            };
          } else {
            data = extractDataFromElement(editor, cellElm);
          }
          if (getCellClassList(editor).length > 0) {
            classListCtrl = {
              name: "class",
              type: "listbox",
              label: "Class",
              values: Helpers.buildListItems(getCellClassList(editor), function(item) {
                if (item.value) {
                  item.textStyle = function() {
                    return editor.formatter.getCssText({
                      block: "td",
                      classes: [item.value]
                    });
                  };
                }
              })
            };
          }
          var generalCellForm = {
            type: "form",
            layout: "flex",
            direction: "column",
            labelGapCalc: "children",
            padding: 0,
            items: [
              {
                type: "form",
                layout: "grid",
                columns: 2,
                labelGapCalc: false,
                padding: 0,
                defaults: {
                  type: "textbox",
                  maxWidth: 50
                },
                items: [
                  {
                    label: "Width",
                    name: "width",
                    onchange: curry(Helpers.updateStyleField, editor)
                  },
                  {
                    label: "Height",
                    name: "height",
                    onchange: curry(Helpers.updateStyleField, editor)
                  },
                  {
                    label: "Cell type",
                    name: "type",
                    type: "listbox",
                    text: "None",
                    minWidth: 90,
                    maxWidth: null,
                    values: [
                      {
                        text: "Cell",
                        value: "td"
                      },
                      {
                        text: "Header cell",
                        value: "th"
                      }
                    ]
                  },
                  {
                    label: "Scope",
                    name: "scope",
                    type: "listbox",
                    text: "None",
                    minWidth: 90,
                    maxWidth: null,
                    values: [
                      {
                        text: "None",
                        value: ""
                      },
                      {
                        text: "Row",
                        value: "row"
                      },
                      {
                        text: "Column",
                        value: "col"
                      },
                      {
                        text: "Row group",
                        value: "rowgroup"
                      },
                      {
                        text: "Column group",
                        value: "colgroup"
                      }
                    ]
                  },
                  {
                    label: "H Align",
                    name: "align",
                    type: "listbox",
                    text: "None",
                    minWidth: 90,
                    maxWidth: null,
                    values: [
                      {
                        text: "None",
                        value: ""
                      },
                      {
                        text: "Left",
                        value: "left"
                      },
                      {
                        text: "Center",
                        value: "center"
                      },
                      {
                        text: "Right",
                        value: "right"
                      }
                    ]
                  },
                  {
                    label: "V Align",
                    name: "valign",
                    type: "listbox",
                    text: "None",
                    minWidth: 90,
                    maxWidth: null,
                    values: [
                      {
                        text: "None",
                        value: ""
                      },
                      {
                        text: "Top",
                        value: "top"
                      },
                      {
                        text: "Middle",
                        value: "middle"
                      },
                      {
                        text: "Bottom",
                        value: "bottom"
                      }
                    ]
                  }
                ]
              },
              classListCtrl
            ]
          };
          if (hasAdvancedCellTab(editor)) {
            editor.windowManager.open({
              title: "Cell properties",
              bodyType: "tabpanel",
              data,
              body: [
                {
                  title: "General",
                  type: "form",
                  items: generalCellForm
                },
                Helpers.createStyleForm(editor)
              ],
              onsubmit: curry(onSubmitCellForm, editor, cells2)
            });
          } else {
            editor.windowManager.open({
              title: "Cell properties",
              data,
              body: generalCellForm,
              onsubmit: curry(onSubmitCellForm, editor, cells2)
            });
          }
        };
        var CellDialog = { open };
        var extractDataFromElement$1 = function(editor, elm) {
          var dom = editor.dom;
          var data = {
            height: dom.getStyle(elm, "height") || dom.getAttrib(elm, "height"),
            scope: dom.getAttrib(elm, "scope"),
            class: dom.getAttrib(elm, "class"),
            align: "",
            style: "",
            type: elm.parentNode.nodeName.toLowerCase()
          };
          global$1.each("left center right".split(" "), function(name2) {
            if (editor.formatter.matchNode(elm, "align" + name2)) {
              data.align = name2;
            }
          });
          if (hasAdvancedRowTab(editor)) {
            global$1.extend(data, Helpers.extractAdvancedStyles(dom, elm));
          }
          return data;
        };
        var switchRowType = function(dom, rowElm, toType) {
          var tableElm = dom.getParent(rowElm, "table");
          var oldParentElm = rowElm.parentNode;
          var parentElm = dom.select(toType, tableElm)[0];
          if (!parentElm) {
            parentElm = dom.create(toType);
            if (tableElm.firstChild) {
              if (tableElm.firstChild.nodeName === "CAPTION") {
                dom.insertAfter(parentElm, tableElm.firstChild);
              } else {
                tableElm.insertBefore(parentElm, tableElm.firstChild);
              }
            } else {
              tableElm.appendChild(parentElm);
            }
          }
          parentElm.appendChild(rowElm);
          if (!oldParentElm.hasChildNodes()) {
            dom.remove(oldParentElm);
          }
        };
        function onSubmitRowForm(editor, rows2, oldData, evt) {
          var dom = editor.dom;
          function setAttrib(elm, name2, value2) {
            if (rows2.length === 1 || value2) {
              dom.setAttrib(elm, name2, value2);
            }
          }
          function setStyle(elm, name2, value2) {
            if (rows2.length === 1 || value2) {
              dom.setStyle(elm, name2, value2);
            }
          }
          if (hasAdvancedRowTab(editor)) {
            Helpers.syncAdvancedStyleFields(editor, evt);
          }
          var data = evt.control.rootControl.toJSON();
          editor.undoManager.transact(function() {
            global$1.each(rows2, function(rowElm) {
              setAttrib(rowElm, "scope", data.scope);
              setAttrib(rowElm, "style", data.style);
              setAttrib(rowElm, "class", data.class);
              setStyle(rowElm, "height", addSizeSuffix(data.height));
              if (data.type !== rowElm.parentNode.nodeName.toLowerCase()) {
                switchRowType(editor.dom, rowElm, data.type);
              }
              if (data.align !== oldData.align) {
                Styles$1.unApplyAlign(editor, rowElm);
                Styles$1.applyAlign(editor, rowElm, data.align);
              }
            });
            editor.focus();
          });
        }
        var open$1 = function(editor) {
          var dom = editor.dom;
          var tableElm, cellElm, rowElm, classListCtrl, data;
          var rows2 = [];
          var generalRowForm;
          tableElm = dom.getParent(editor.selection.getStart(), "table");
          cellElm = dom.getParent(editor.selection.getStart(), "td,th");
          global$1.each(tableElm.rows, function(row2) {
            global$1.each(row2.cells, function(cell2) {
              if (dom.getAttrib(cell2, "data-mce-selected") || cell2 === cellElm) {
                rows2.push(row2);
                return false;
              }
            });
          });
          rowElm = rows2[0];
          if (!rowElm) {
            return;
          }
          if (rows2.length > 1) {
            data = {
              height: "",
              scope: "",
              style: "",
              class: "",
              align: "",
              type: rowElm.parentNode.nodeName.toLowerCase()
            };
          } else {
            data = extractDataFromElement$1(editor, rowElm);
          }
          if (getRowClassList(editor).length > 0) {
            classListCtrl = {
              name: "class",
              type: "listbox",
              label: "Class",
              values: Helpers.buildListItems(getRowClassList(editor), function(item) {
                if (item.value) {
                  item.textStyle = function() {
                    return editor.formatter.getCssText({
                      block: "tr",
                      classes: [item.value]
                    });
                  };
                }
              })
            };
          }
          generalRowForm = {
            type: "form",
            columns: 2,
            padding: 0,
            defaults: { type: "textbox" },
            items: [
              {
                type: "listbox",
                name: "type",
                label: "Row type",
                text: "Header",
                maxWidth: null,
                values: [
                  {
                    text: "Header",
                    value: "thead"
                  },
                  {
                    text: "Body",
                    value: "tbody"
                  },
                  {
                    text: "Footer",
                    value: "tfoot"
                  }
                ]
              },
              {
                type: "listbox",
                name: "align",
                label: "Alignment",
                text: "None",
                maxWidth: null,
                values: [
                  {
                    text: "None",
                    value: ""
                  },
                  {
                    text: "Left",
                    value: "left"
                  },
                  {
                    text: "Center",
                    value: "center"
                  },
                  {
                    text: "Right",
                    value: "right"
                  }
                ]
              },
              {
                label: "Height",
                name: "height"
              },
              classListCtrl
            ]
          };
          if (hasAdvancedRowTab(editor)) {
            editor.windowManager.open({
              title: "Row properties",
              data,
              bodyType: "tabpanel",
              body: [
                {
                  title: "General",
                  type: "form",
                  items: generalRowForm
                },
                Helpers.createStyleForm(editor)
              ],
              onsubmit: curry(onSubmitRowForm, editor, rows2, data)
            });
          } else {
            editor.windowManager.open({
              title: "Row properties",
              data,
              body: generalRowForm,
              onsubmit: curry(onSubmitRowForm, editor, rows2, data)
            });
          }
        };
        var RowDialog = { open: open$1 };
        var global$2 = tinymce.util.Tools.resolve("tinymce.Env");
        var DefaultRenderOptions = {
          styles: {
            "border-collapse": "collapse",
            "width": "100%"
          },
          attributes: { border: "1" },
          percentages: true
        };
        var makeTable = function() {
          return Element.fromTag("table");
        };
        var tableBody = function() {
          return Element.fromTag("tbody");
        };
        var tableRow = function() {
          return Element.fromTag("tr");
        };
        var tableHeaderCell = function() {
          return Element.fromTag("th");
        };
        var tableCell = function() {
          return Element.fromTag("td");
        };
        var render$1 = function(rows2, columns2, rowHeaders, columnHeaders, renderOpts) {
          if (renderOpts === void 0) {
            renderOpts = DefaultRenderOptions;
          }
          var table3 = makeTable();
          setAll$1(table3, renderOpts.styles);
          setAll(table3, renderOpts.attributes);
          var tbody = tableBody();
          append(table3, tbody);
          var trs = [];
          for (var i = 0; i < rows2; i++) {
            var tr = tableRow();
            for (var j = 0; j < columns2; j++) {
              var td = i < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();
              if (j < columnHeaders) {
                set(td, "scope", "row");
              }
              if (i < rowHeaders) {
                set(td, "scope", "col");
              }
              append(td, Element.fromTag("br"));
              if (renderOpts.percentages) {
                set$1(td, "width", 100 / columns2 + "%");
              }
              append(tr, td);
            }
            trs.push(tr);
          }
          append$1(tbody, trs);
          return table3;
        };
        var get$7 = function(element) {
          return element.dom().innerHTML;
        };
        var getOuter$2 = function(element) {
          var container = Element.fromTag("div");
          var clone2 = Element.fromDom(element.dom().cloneNode(true));
          append(container, clone2);
          return get$7(container);
        };
        var placeCaretInCell = function(editor, cell2) {
          editor.selection.select(cell2.dom(), true);
          editor.selection.collapse(true);
        };
        var selectFirstCellInTable = function(editor, tableElm) {
          descendant$1(tableElm, "td,th").each(curry(placeCaretInCell, editor));
        };
        var fireEvents = function(editor, table3) {
          each(descendants$1(table3, "tr"), function(row2) {
            fireNewRow(editor, row2.dom());
            each(descendants$1(row2, "th,td"), function(cell2) {
              fireNewCell(editor, cell2.dom());
            });
          });
        };
        var isPercentage = function(width) {
          return isString(width) && width.indexOf("%") !== -1;
        };
        var insert$1 = function(editor, columns2, rows2) {
          var defaultStyles2 = getDefaultStyles(editor);
          var options = {
            styles: defaultStyles2,
            attributes: getDefaultAttributes(editor),
            percentages: isPercentage(defaultStyles2.width) && !isPixelsForced(editor)
          };
          var table3 = render$1(rows2, columns2, 0, 0, options);
          set(table3, "data-mce-id", "__mce");
          var html = getOuter$2(table3);
          editor.insertContent(html);
          return descendant$1(getBody$1(editor), 'table[data-mce-id="__mce"]').map(function(table4) {
            if (isPixelsForced(editor)) {
              set$1(table4, "width", get$1(table4, "width"));
            }
            remove(table4, "data-mce-id");
            fireEvents(editor, table4);
            selectFirstCellInTable(editor, table4);
            return table4.dom();
          }).getOr(null);
        };
        var InsertTable = { insert: insert$1 };
        function styleTDTH(dom, elm, name2, value2) {
          if (elm.tagName === "TD" || elm.tagName === "TH") {
            dom.setStyle(elm, name2, value2);
          } else {
            if (elm.children) {
              for (var i = 0; i < elm.children.length; i++) {
                styleTDTH(dom, elm.children[i], name2, value2);
              }
            }
          }
        }
        var extractDataFromElement$2 = function(editor, tableElm) {
          var dom = editor.dom;
          var data = {
            width: dom.getStyle(tableElm, "width") || dom.getAttrib(tableElm, "width"),
            height: dom.getStyle(tableElm, "height") || dom.getAttrib(tableElm, "height"),
            cellspacing: dom.getStyle(tableElm, "border-spacing") || dom.getAttrib(tableElm, "cellspacing"),
            cellpadding: dom.getAttrib(tableElm, "data-mce-cell-padding") || dom.getAttrib(tableElm, "cellpadding") || Styles$1.getTDTHOverallStyle(editor.dom, tableElm, "padding"),
            border: dom.getAttrib(tableElm, "data-mce-border") || dom.getAttrib(tableElm, "border") || Styles$1.getTDTHOverallStyle(editor.dom, tableElm, "border"),
            borderColor: dom.getAttrib(tableElm, "data-mce-border-color"),
            caption: !!dom.select("caption", tableElm)[0],
            class: dom.getAttrib(tableElm, "class")
          };
          global$1.each("left center right".split(" "), function(name2) {
            if (editor.formatter.matchNode(tableElm, "align" + name2)) {
              data.align = name2;
            }
          });
          if (hasAdvancedTableTab(editor)) {
            global$1.extend(data, Helpers.extractAdvancedStyles(dom, tableElm));
          }
          return data;
        };
        var applyDataToElement = function(editor, tableElm, data) {
          var dom = editor.dom;
          var attrs = {};
          var styles2 = {};
          attrs.class = data.class;
          styles2.height = addSizeSuffix(data.height);
          if (dom.getAttrib(tableElm, "width") && !shouldStyleWithCss(editor)) {
            attrs.width = removePxSuffix(data.width);
          } else {
            styles2.width = addSizeSuffix(data.width);
          }
          if (shouldStyleWithCss(editor)) {
            styles2["border-width"] = addSizeSuffix(data.border);
            styles2["border-spacing"] = addSizeSuffix(data.cellspacing);
            global$1.extend(attrs, {
              "data-mce-border-color": data.borderColor,
              "data-mce-cell-padding": data.cellpadding,
              "data-mce-border": data.border
            });
          } else {
            global$1.extend(attrs, {
              border: data.border,
              cellpadding: data.cellpadding,
              cellspacing: data.cellspacing
            });
          }
          if (shouldStyleWithCss(editor)) {
            if (tableElm.children) {
              for (var i = 0; i < tableElm.children.length; i++) {
                styleTDTH(dom, tableElm.children[i], {
                  "border-width": addSizeSuffix(data.border),
                  "border-color": data.borderColor,
                  "padding": addSizeSuffix(data.cellpadding)
                });
              }
            }
          }
          if (data.style) {
            global$1.extend(styles2, dom.parseStyle(data.style));
          } else {
            styles2 = global$1.extend({}, dom.parseStyle(dom.getAttrib(tableElm, "style")), styles2);
          }
          attrs.style = dom.serializeStyle(styles2);
          dom.setAttribs(tableElm, attrs);
        };
        var onSubmitTableForm = function(editor, tableElm, evt) {
          var dom = editor.dom;
          var captionElm;
          var data;
          if (hasAdvancedTableTab(editor)) {
            Helpers.syncAdvancedStyleFields(editor, evt);
          }
          data = evt.control.rootControl.toJSON();
          if (data.class === false) {
            delete data.class;
          }
          editor.undoManager.transact(function() {
            if (!tableElm) {
              tableElm = InsertTable.insert(editor, data.cols || 1, data.rows || 1);
            }
            applyDataToElement(editor, tableElm, data);
            captionElm = dom.select("caption", tableElm)[0];
            if (captionElm && !data.caption) {
              dom.remove(captionElm);
            }
            if (!captionElm && data.caption) {
              captionElm = dom.create("caption");
              captionElm.innerHTML = !global$2.ie ? '<br data-mce-bogus="1"/>' : "\xA0";
              tableElm.insertBefore(captionElm, tableElm.firstChild);
            }
            Styles$1.unApplyAlign(editor, tableElm);
            if (data.align) {
              Styles$1.applyAlign(editor, tableElm, data.align);
            }
            editor.focus();
            editor.addVisual();
          });
        };
        var open$2 = function(editor, isProps) {
          var dom = editor.dom;
          var tableElm, colsCtrl, rowsCtrl, classListCtrl, data = {}, generalTableForm;
          if (isProps === true) {
            tableElm = dom.getParent(editor.selection.getStart(), "table");
            if (tableElm) {
              data = extractDataFromElement$2(editor, tableElm);
            }
          } else {
            colsCtrl = {
              label: "Cols",
              name: "cols"
            };
            rowsCtrl = {
              label: "Rows",
              name: "rows"
            };
          }
          if (getTableClassList(editor).length > 0) {
            if (data.class) {
              data.class = data.class.replace(/\s*mce\-item\-table\s*/g, "");
            }
            classListCtrl = {
              name: "class",
              type: "listbox",
              label: "Class",
              values: Helpers.buildListItems(getTableClassList(editor), function(item) {
                if (item.value) {
                  item.textStyle = function() {
                    return editor.formatter.getCssText({
                      block: "table",
                      classes: [item.value]
                    });
                  };
                }
              })
            };
          }
          generalTableForm = {
            type: "form",
            layout: "flex",
            direction: "column",
            labelGapCalc: "children",
            padding: 0,
            items: [
              {
                type: "form",
                labelGapCalc: false,
                padding: 0,
                layout: "grid",
                columns: 2,
                defaults: {
                  type: "textbox",
                  maxWidth: 50
                },
                items: hasAppearanceOptions(editor) ? [
                  colsCtrl,
                  rowsCtrl,
                  {
                    label: "Width",
                    name: "width",
                    onchange: curry(Helpers.updateStyleField, editor)
                  },
                  {
                    label: "Height",
                    name: "height",
                    onchange: curry(Helpers.updateStyleField, editor)
                  },
                  {
                    label: "Cell spacing",
                    name: "cellspacing"
                  },
                  {
                    label: "Cell padding",
                    name: "cellpadding"
                  },
                  {
                    label: "Border",
                    name: "border"
                  },
                  {
                    label: "Caption",
                    name: "caption",
                    type: "checkbox"
                  }
                ] : [
                  colsCtrl,
                  rowsCtrl,
                  {
                    label: "Width",
                    name: "width",
                    onchange: curry(Helpers.updateStyleField, editor)
                  },
                  {
                    label: "Height",
                    name: "height",
                    onchange: curry(Helpers.updateStyleField, editor)
                  }
                ]
              },
              {
                label: "Alignment",
                name: "align",
                type: "listbox",
                text: "None",
                values: [
                  {
                    text: "None",
                    value: ""
                  },
                  {
                    text: "Left",
                    value: "left"
                  },
                  {
                    text: "Center",
                    value: "center"
                  },
                  {
                    text: "Right",
                    value: "right"
                  }
                ]
              },
              classListCtrl
            ]
          };
          if (hasAdvancedTableTab(editor)) {
            editor.windowManager.open({
              title: "Table properties",
              data,
              bodyType: "tabpanel",
              body: [
                {
                  title: "General",
                  type: "form",
                  items: generalTableForm
                },
                Helpers.createStyleForm(editor)
              ],
              onsubmit: curry(onSubmitTableForm, editor, tableElm)
            });
          } else {
            editor.windowManager.open({
              title: "Table properties",
              data,
              body: generalTableForm,
              onsubmit: curry(onSubmitTableForm, editor, tableElm)
            });
          }
        };
        var TableDialog = { open: open$2 };
        var each$3 = global$1.each;
        var registerCommands = function(editor, actions, cellSelection, selections, clipboardRows) {
          var isRoot = getIsRoot(editor);
          var eraseTable = function() {
            getSelectionStartCell().orThunk(getSelectionStartCaption).each(function(cellOrCaption) {
              var table3 = TableLookup.table(cellOrCaption, isRoot);
              table3.filter(not(isRoot)).each(function(table4) {
                var cursor = Element.fromText("");
                after(table4, cursor);
                remove$2(table4);
                var rng = editor.dom.createRng();
                rng.setStart(cursor.dom(), 0);
                rng.setEnd(cursor.dom(), 0);
                editor.selection.setRng(rng);
              });
            });
          };
          var getSelectionStartFromSelector = function(selector) {
            return function() {
              return Option.from(editor.dom.getParent(editor.selection.getStart(), selector)).map(Element.fromDom);
            };
          };
          var getSelectionStartCaption = getSelectionStartFromSelector("caption");
          var getSelectionStartCell = getSelectionStartFromSelector("th,td");
          var getTableFromCell = function(cell2) {
            return TableLookup.table(cell2, isRoot);
          };
          var getSize = function(table3) {
            return {
              width: getPixelWidth$1(table3.dom()),
              height: getPixelWidth$1(table3.dom())
            };
          };
          var resizeChange = function(editor2, oldSize, table3) {
            var newSize = getSize(table3);
            if (oldSize.width !== newSize.width || oldSize.height !== newSize.height) {
              fireObjectResizeStart(editor2, table3.dom(), oldSize.width, oldSize.height);
              fireObjectResized(editor2, table3.dom(), newSize.width, newSize.height);
            }
          };
          var actOnSelection = function(execute) {
            getSelectionStartCell().each(function(cell2) {
              getTableFromCell(cell2).each(function(table3) {
                var targets = TableTargets.forMenu(selections, table3, cell2);
                var beforeSize = getSize(table3);
                execute(table3, targets).each(function(rng) {
                  resizeChange(editor, beforeSize, table3);
                  editor.selection.setRng(rng);
                  editor.focus();
                  cellSelection.clear(table3);
                  removeDataStyle(table3);
                });
              });
            });
          };
          var copyRowSelection = function(execute) {
            return getSelectionStartCell().bind(function(cell2) {
              return getTableFromCell(cell2).bind(function(table3) {
                var doc = Element.fromDom(editor.getDoc());
                var targets = TableTargets.forMenu(selections, table3, cell2);
                var generators = TableFill.cellOperations(noop, doc, Option.none());
                return CopyRows.copyRows(table3, targets, generators);
              });
            });
          };
          var pasteOnSelection = function(execute) {
            clipboardRows.get().each(function(rows2) {
              var clonedRows = map(rows2, function(row2) {
                return deep(row2);
              });
              getSelectionStartCell().each(function(cell2) {
                getTableFromCell(cell2).each(function(table3) {
                  var doc = Element.fromDom(editor.getDoc());
                  var generators = TableFill.paste(doc);
                  var targets = TableTargets.pasteRows(selections, table3, cell2, clonedRows, generators);
                  execute(table3, targets).each(function(rng) {
                    editor.selection.setRng(rng);
                    editor.focus();
                    cellSelection.clear(table3);
                  });
                });
              });
            });
          };
          each$3({
            mceTableSplitCells: function() {
              actOnSelection(actions.unmergeCells);
            },
            mceTableMergeCells: function() {
              actOnSelection(actions.mergeCells);
            },
            mceTableInsertRowBefore: function() {
              actOnSelection(actions.insertRowsBefore);
            },
            mceTableInsertRowAfter: function() {
              actOnSelection(actions.insertRowsAfter);
            },
            mceTableInsertColBefore: function() {
              actOnSelection(actions.insertColumnsBefore);
            },
            mceTableInsertColAfter: function() {
              actOnSelection(actions.insertColumnsAfter);
            },
            mceTableDeleteCol: function() {
              actOnSelection(actions.deleteColumn);
            },
            mceTableDeleteRow: function() {
              actOnSelection(actions.deleteRow);
            },
            mceTableCutRow: function(grid2) {
              clipboardRows.set(copyRowSelection());
              actOnSelection(actions.deleteRow);
            },
            mceTableCopyRow: function(grid2) {
              clipboardRows.set(copyRowSelection());
            },
            mceTablePasteRowBefore: function(grid2) {
              pasteOnSelection(actions.pasteRowsBefore);
            },
            mceTablePasteRowAfter: function(grid2) {
              pasteOnSelection(actions.pasteRowsAfter);
            },
            mceTableDelete: eraseTable
          }, function(func, name2) {
            editor.addCommand(name2, func);
          });
          each$3({
            mceInsertTable: curry(TableDialog.open, editor),
            mceTableProps: curry(TableDialog.open, editor, true),
            mceTableRowProps: curry(RowDialog.open, editor),
            mceTableCellProps: curry(CellDialog.open, editor)
          }, function(func, name2) {
            editor.addCommand(name2, function(ui, val) {
              func(val);
            });
          });
        };
        var Commands = { registerCommands };
        var only = function(element) {
          var parent2 = Option.from(element.dom().documentElement).map(Element.fromDom).getOr(element);
          return {
            parent: constant(parent2),
            view: constant(element),
            origin: constant(Position(0, 0))
          };
        };
        var detached = function(editable, chrome2) {
          var origin = function() {
            return absolute(chrome2);
          };
          return {
            parent: constant(chrome2),
            view: constant(editable),
            origin
          };
        };
        var body$1 = function(editable, chrome2) {
          return {
            parent: constant(chrome2),
            view: constant(editable),
            origin: constant(Position(0, 0))
          };
        };
        var ResizeWire = {
          only,
          detached,
          body: body$1
        };
        var Event = function(fields) {
          var struct = Immutable.apply(null, fields);
          var handlers = [];
          var bind2 = function(handler) {
            if (handler === void 0) {
              throw new Error("Event bind error: undefined handler");
            }
            handlers.push(handler);
          };
          var unbind2 = function(handler) {
            handlers = filter(handlers, function(h) {
              return h !== handler;
            });
          };
          var trigger = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var event = struct.apply(null, args);
            each(handlers, function(handler) {
              handler(event);
            });
          };
          return {
            bind: bind2,
            unbind: unbind2,
            trigger
          };
        };
        var create$1 = function(typeDefs) {
          var registry = map$1(typeDefs, function(event) {
            return {
              bind: event.bind,
              unbind: event.unbind
            };
          });
          var trigger = map$1(typeDefs, function(event) {
            return event.trigger;
          });
          return {
            registry,
            trigger
          };
        };
        var Events = { create: create$1 };
        var mkEvent = function(target, x, y, stop, prevent, kill, raw) {
          return {
            target: constant(target),
            x: constant(x),
            y: constant(y),
            stop,
            prevent,
            kill,
            raw: constant(raw)
          };
        };
        var handle = function(filter2, handler) {
          return function(rawEvent) {
            if (!filter2(rawEvent)) {
              return;
            }
            var target = Element.fromDom(rawEvent.target);
            var stop = function() {
              rawEvent.stopPropagation();
            };
            var prevent = function() {
              rawEvent.preventDefault();
            };
            var kill = compose(prevent, stop);
            var evt = mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
            handler(evt);
          };
        };
        var binder = function(element, event, filter2, handler, useCapture) {
          var wrapped = handle(filter2, handler);
          element.dom().addEventListener(event, wrapped, useCapture);
          return { unbind: curry(unbind, element, event, wrapped, useCapture) };
        };
        var bind$1 = function(element, event, filter2, handler) {
          return binder(element, event, filter2, handler, false);
        };
        var unbind = function(element, event, handler, useCapture) {
          element.dom().removeEventListener(event, handler, useCapture);
        };
        var filter$1 = constant(true);
        var bind$2 = function(element, event, handler) {
          return bind$1(element, event, filter$1, handler);
        };
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var shallow$1 = function(old, nu2) {
          return nu2;
        };
        var baseMerge = function(merger) {
          return function() {
            var objects = new Array(arguments.length);
            for (var i = 0; i < objects.length; i++) {
              objects[i] = arguments[i];
            }
            if (objects.length === 0) {
              throw new Error("Can't merge zero objects");
            }
            var ret = {};
            for (var j = 0; j < objects.length; j++) {
              var curObject = objects[j];
              for (var key2 in curObject) {
                if (hasOwnProperty.call(curObject, key2)) {
                  ret[key2] = merger(ret[key2], curObject[key2]);
                }
              }
            }
            return ret;
          };
        };
        var merge$3 = baseMerge(shallow$1);
        var styles$1 = css("ephox-dragster");
        var Styles$2 = { resolve: styles$1.resolve };
        var Blocker = function(options) {
          var settings = merge$3({ layerClass: Styles$2.resolve("blocker") }, options);
          var div = Element.fromTag("div");
          set(div, "role", "presentation");
          setAll$1(div, {
            position: "fixed",
            left: "0px",
            top: "0px",
            width: "100%",
            height: "100%"
          });
          add$2(div, Styles$2.resolve("blocker"));
          add$2(div, settings.layerClass);
          var element = function() {
            return div;
          };
          var destroy2 = function() {
            remove$2(div);
          };
          return {
            element,
            destroy: destroy2
          };
        };
        var DragMode = exactly([
          "compare",
          "extract",
          "mutate",
          "sink"
        ]);
        var DragSink = exactly([
          "element",
          "start",
          "stop",
          "destroy"
        ]);
        var DragApi = exactly([
          "forceDrop",
          "drop",
          "move",
          "delayDrop"
        ]);
        var compare = function(old, nu2) {
          return Position(nu2.left() - old.left(), nu2.top() - old.top());
        };
        var extract$1 = function(event) {
          return Option.some(Position(event.x(), event.y()));
        };
        var mutate = function(mutation, info) {
          mutation.mutate(info.left(), info.top());
        };
        var sink = function(dragApi, settings) {
          var blocker = Blocker(settings);
          var mdown = bind$2(blocker.element(), "mousedown", dragApi.forceDrop);
          var mup = bind$2(blocker.element(), "mouseup", dragApi.drop);
          var mmove = bind$2(blocker.element(), "mousemove", dragApi.move);
          var mout = bind$2(blocker.element(), "mouseout", dragApi.delayDrop);
          var destroy2 = function() {
            blocker.destroy();
            mup.unbind();
            mmove.unbind();
            mout.unbind();
            mdown.unbind();
          };
          var start = function(parent2) {
            append(parent2, blocker.element());
          };
          var stop = function() {
            remove$2(blocker.element());
          };
          return DragSink({
            element: blocker.element,
            start,
            stop,
            destroy: destroy2
          });
        };
        var MouseDrag = DragMode({
          compare,
          extract: extract$1,
          sink,
          mutate
        });
        var last$2 = function(fn, rate) {
          var timer = null;
          var cancel = function() {
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
              timer = null;
            }
          };
          var throttle = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
            }
            timer = domGlobals.setTimeout(function() {
              fn.apply(null, args);
              timer = null;
            }, rate);
          };
          return {
            cancel,
            throttle
          };
        };
        function InDrag() {
          var previous = Option.none();
          var reset = function() {
            previous = Option.none();
          };
          var update2 = function(mode, nu2) {
            var result = previous.map(function(old) {
              return mode.compare(old, nu2);
            });
            previous = Option.some(nu2);
            return result;
          };
          var onEvent = function(event, mode) {
            var dataOption = mode.extract(event);
            dataOption.each(function(data) {
              var offset = update2(mode, data);
              offset.each(function(d) {
                events.trigger.move(d);
              });
            });
          };
          var events = Events.create({ move: Event(["info"]) });
          return {
            onEvent,
            reset,
            events: events.registry
          };
        }
        function NoDrag() {
          return {
            onEvent: noop,
            reset: noop
          };
        }
        function Movement() {
          var noDragState = NoDrag();
          var inDragState = InDrag();
          var dragState = noDragState;
          var on2 = function() {
            dragState.reset();
            dragState = inDragState;
          };
          var off = function() {
            dragState.reset();
            dragState = noDragState;
          };
          var onEvent = function(event, mode) {
            dragState.onEvent(event, mode);
          };
          var isOn = function() {
            return dragState === inDragState;
          };
          return {
            on: on2,
            off,
            isOn,
            onEvent,
            events: inDragState.events
          };
        }
        var setup = function(mutation, mode, settings) {
          var active = false;
          var events = Events.create({
            start: Event([]),
            stop: Event([])
          });
          var movement = Movement();
          var drop = function() {
            sink2.stop();
            if (movement.isOn()) {
              movement.off();
              events.trigger.stop();
            }
          };
          var throttledDrop = last$2(drop, 200);
          var go2 = function(parent2) {
            sink2.start(parent2);
            movement.on();
            events.trigger.start();
          };
          var mousemove = function(event) {
            throttledDrop.cancel();
            movement.onEvent(event, mode);
          };
          movement.events.move.bind(function(event) {
            mode.mutate(mutation, event.info());
          });
          var on2 = function() {
            active = true;
          };
          var off = function() {
            active = false;
          };
          var runIfActive = function(f) {
            return function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              if (active) {
                f.apply(null, args);
              }
            };
          };
          var sink2 = mode.sink(DragApi({
            forceDrop: drop,
            drop: runIfActive(drop),
            move: runIfActive(mousemove),
            delayDrop: runIfActive(throttledDrop.throttle)
          }), settings);
          var destroy2 = function() {
            sink2.destroy();
          };
          return {
            element: sink2.element,
            go: go2,
            on: on2,
            off,
            destroy: destroy2,
            events: events.registry
          };
        };
        var Dragging = { setup };
        var transform$1 = function(mutation, settings) {
          if (settings === void 0) {
            settings = {};
          }
          var mode = settings.mode !== void 0 ? settings.mode : MouseDrag;
          return Dragging.setup(mutation, mode, settings);
        };
        var Dragger = { transform: transform$1 };
        var Mutation = function() {
          var events = Events.create({
            drag: Event([
              "xDelta",
              "yDelta"
            ])
          });
          var mutate2 = function(x, y) {
            events.trigger.drag(x, y);
          };
          return {
            mutate: mutate2,
            events: events.registry
          };
        };
        var BarMutation = function() {
          var events = Events.create({
            drag: Event([
              "xDelta",
              "yDelta",
              "target"
            ])
          });
          var target = Option.none();
          var delegate = Mutation();
          delegate.events.drag.bind(function(event) {
            target.each(function(t) {
              events.trigger.drag(event.xDelta(), event.yDelta(), t);
            });
          });
          var assign = function(t) {
            target = Option.some(t);
          };
          var get2 = function() {
            return target;
          };
          return {
            assign,
            get: get2,
            mutate: delegate.mutate,
            events: events.registry
          };
        };
        var isContentEditableTrue = function(elm) {
          return get(elm, "contenteditable") === "true";
        };
        var findClosestContentEditable = function(target, isRoot) {
          return closest$1(target, "[contenteditable]", isRoot);
        };
        var resizeBarDragging = Styles.resolve("resizer-bar-dragging");
        var BarManager = function(wire, direction, hdirection) {
          var mutation = BarMutation();
          var resizing = Dragger.transform(mutation, {});
          var hoverTable = Option.none();
          var getResizer = function(element, type2) {
            return Option.from(get(element, type2));
          };
          mutation.events.drag.bind(function(event) {
            getResizer(event.target(), "data-row").each(function(_dataRow) {
              var currentRow = CellUtils.getInt(event.target(), "top");
              set$1(event.target(), "top", currentRow + event.yDelta() + "px");
            });
            getResizer(event.target(), "data-column").each(function(_dataCol) {
              var currentCol = CellUtils.getInt(event.target(), "left");
              set$1(event.target(), "left", currentCol + event.xDelta() + "px");
            });
          });
          var getDelta = function(target, dir) {
            var newX = CellUtils.getInt(target, dir);
            var oldX = parseInt(get(target, "data-initial-" + dir), 10);
            return newX - oldX;
          };
          resizing.events.stop.bind(function() {
            mutation.get().each(function(target) {
              hoverTable.each(function(table3) {
                getResizer(target, "data-row").each(function(row2) {
                  var delta2 = getDelta(target, "top");
                  remove(target, "data-initial-top");
                  events.trigger.adjustHeight(table3, delta2, parseInt(row2, 10));
                });
                getResizer(target, "data-column").each(function(column) {
                  var delta2 = getDelta(target, "left");
                  remove(target, "data-initial-left");
                  events.trigger.adjustWidth(table3, delta2, parseInt(column, 10));
                });
                Bars.refresh(wire, table3, hdirection, direction);
              });
            });
          });
          var handler = function(target, dir) {
            events.trigger.startAdjust();
            mutation.assign(target);
            set(target, "data-initial-" + dir, parseInt(get$1(target, dir), 10));
            add$2(target, resizeBarDragging);
            set$1(target, "opacity", "0.2");
            resizing.go(wire.parent());
          };
          var mousedown = bind$2(wire.parent(), "mousedown", function(event) {
            if (Bars.isRowBar(event.target())) {
              handler(event.target(), "top");
            }
            if (Bars.isColBar(event.target())) {
              handler(event.target(), "left");
            }
          });
          var isRoot = function(e) {
            return eq(e, wire.view());
          };
          var findClosestEditableTable = function(target) {
            return closest$1(target, "table", isRoot).filter(function(table3) {
              return findClosestContentEditable(table3, isRoot).exists(isContentEditableTrue);
            });
          };
          var mouseover = bind$2(wire.view(), "mouseover", function(event) {
            findClosestEditableTable(event.target()).fold(function() {
              if (inBody(event.target())) {
                Bars.destroy(wire);
              }
            }, function(table3) {
              hoverTable = Option.some(table3);
              Bars.refresh(wire, table3, hdirection, direction);
            });
          });
          var destroy2 = function() {
            mousedown.unbind();
            mouseover.unbind();
            resizing.destroy();
            Bars.destroy(wire);
          };
          var refresh2 = function(tbl) {
            Bars.refresh(wire, tbl, hdirection, direction);
          };
          var events = Events.create({
            adjustHeight: Event([
              "table",
              "delta",
              "row"
            ]),
            adjustWidth: Event([
              "table",
              "delta",
              "column"
            ]),
            startAdjust: Event([])
          });
          return {
            destroy: destroy2,
            refresh: refresh2,
            on: resizing.on,
            off: resizing.off,
            hideBars: curry(Bars.hide, wire),
            showBars: curry(Bars.show, wire),
            events: events.registry
          };
        };
        var create$2 = function(wire, vdirection) {
          var hdirection = BarPositions.height;
          var manager = BarManager(wire, vdirection, hdirection);
          var events = Events.create({
            beforeResize: Event(["table"]),
            afterResize: Event(["table"]),
            startDrag: Event([])
          });
          manager.events.adjustHeight.bind(function(event) {
            events.trigger.beforeResize(event.table());
            var delta2 = hdirection.delta(event.delta(), event.table());
            Adjustments.adjustHeight(event.table(), delta2, event.row(), hdirection);
            events.trigger.afterResize(event.table());
          });
          manager.events.startAdjust.bind(function(event) {
            events.trigger.startDrag();
          });
          manager.events.adjustWidth.bind(function(event) {
            events.trigger.beforeResize(event.table());
            var delta2 = vdirection.delta(event.delta(), event.table());
            Adjustments.adjustWidth(event.table(), delta2, event.column(), vdirection);
            events.trigger.afterResize(event.table());
          });
          return {
            on: manager.on,
            off: manager.off,
            hideBars: manager.hideBars,
            showBars: manager.showBars,
            destroy: manager.destroy,
            events: events.registry
          };
        };
        var TableResize = { create: create$2 };
        var createContainer = function() {
          var container = Element.fromTag("div");
          setAll$1(container, {
            position: "static",
            height: "0",
            width: "0",
            padding: "0",
            margin: "0",
            border: "0"
          });
          append(body(), container);
          return container;
        };
        var get$8 = function(editor, container) {
          return editor.inline ? ResizeWire.body(getBody$1(editor), createContainer()) : ResizeWire.only(Element.fromDom(editor.getDoc()));
        };
        var remove$6 = function(editor, wire) {
          if (editor.inline) {
            remove$2(wire.parent());
          }
        };
        var TableWire = {
          get: get$8,
          remove: remove$6
        };
        var ResizeHandler = function(editor) {
          var selectionRng = Option.none();
          var resize2 = Option.none();
          var wire = Option.none();
          var percentageBasedSizeRegex2 = /(\d+(\.\d+)?)%/;
          var startW, startRawW;
          var isTable = function(elm) {
            return elm.nodeName === "TABLE";
          };
          var getRawWidth2 = function(elm) {
            return editor.dom.getStyle(elm, "width") || editor.dom.getAttrib(elm, "width");
          };
          var lazyResize = function() {
            return resize2;
          };
          var lazyWire = function() {
            return wire.getOr(ResizeWire.only(Element.fromDom(editor.getBody())));
          };
          var destroy2 = function() {
            resize2.each(function(sz) {
              sz.destroy();
            });
            wire.each(function(w) {
              TableWire.remove(editor, w);
            });
          };
          editor.on("init", function() {
            var direction = TableDirection(Direction.directionAt);
            var rawWire = TableWire.get(editor);
            wire = Option.some(rawWire);
            if (hasObjectResizing(editor) && hasTableResizeBars(editor)) {
              var sz = TableResize.create(rawWire, direction);
              sz.on();
              sz.events.startDrag.bind(function(event) {
                selectionRng = Option.some(editor.selection.getRng());
              });
              sz.events.beforeResize.bind(function(event) {
                var rawTable = event.table().dom();
                fireObjectResizeStart(editor, rawTable, getPixelWidth$1(rawTable), getPixelHeight(rawTable));
              });
              sz.events.afterResize.bind(function(event) {
                var table3 = event.table();
                var rawTable = table3.dom();
                removeDataStyle(table3);
                selectionRng.each(function(rng) {
                  editor.selection.setRng(rng);
                  editor.focus();
                });
                fireObjectResized(editor, rawTable, getPixelWidth$1(rawTable), getPixelHeight(rawTable));
                editor.undoManager.add();
              });
              resize2 = Option.some(sz);
            }
          });
          editor.on("ObjectResizeStart", function(e) {
            var targetElm = e.target;
            if (isTable(targetElm)) {
              startW = e.width;
              startRawW = getRawWidth2(targetElm);
            }
          });
          editor.on("ObjectResized", function(e) {
            var targetElm = e.target;
            if (isTable(targetElm)) {
              var table3 = targetElm;
              if (percentageBasedSizeRegex2.test(startRawW)) {
                var percentW = parseFloat(percentageBasedSizeRegex2.exec(startRawW)[1]);
                var targetPercentW = e.width * percentW / startW;
                editor.dom.setStyle(table3, "width", targetPercentW + "%");
              } else {
                var newCellSizes_1 = [];
                global$1.each(table3.rows, function(row2) {
                  global$1.each(row2.cells, function(cell2) {
                    var width = editor.dom.getStyle(cell2, "width", true);
                    newCellSizes_1.push({
                      cell: cell2,
                      width
                    });
                  });
                });
                global$1.each(newCellSizes_1, function(newCellSize) {
                  editor.dom.setStyle(newCellSize.cell, "width", newCellSize.width);
                  editor.dom.setAttrib(newCellSize.cell, "width", null);
                });
              }
            }
          });
          return {
            lazyResize,
            lazyWire,
            destroy: destroy2
          };
        };
        var adt$1 = Adt.generate([
          { none: ["current"] },
          { first: ["current"] },
          {
            middle: [
              "current",
              "target"
            ]
          },
          { last: ["current"] }
        ]);
        var none$1 = function(current) {
          if (current === void 0) {
            current = void 0;
          }
          return adt$1.none(current);
        };
        var CellLocation = __assign(__assign({}, adt$1), { none: none$1 });
        var detect$4 = function(current, isRoot) {
          return TableLookup.table(current, isRoot).bind(function(table3) {
            var all2 = TableLookup.cells(table3);
            var index = findIndex(all2, function(x) {
              return eq(current, x);
            });
            return index.map(function(ind) {
              return {
                index: constant(ind),
                all: constant(all2)
              };
            });
          });
        };
        var next = function(current, isRoot) {
          var detection2 = detect$4(current, isRoot);
          return detection2.fold(function() {
            return CellLocation.none(current);
          }, function(info) {
            return info.index() + 1 < info.all().length ? CellLocation.middle(current, info.all()[info.index() + 1]) : CellLocation.last(current);
          });
        };
        var prev = function(current, isRoot) {
          var detection2 = detect$4(current, isRoot);
          return detection2.fold(function() {
            return CellLocation.none();
          }, function(info) {
            return info.index() - 1 >= 0 ? CellLocation.middle(current, info.all()[info.index() - 1]) : CellLocation.first(current);
          });
        };
        var CellNavigation = {
          next,
          prev
        };
        var create$3 = Immutable("start", "soffset", "finish", "foffset");
        var SimRange = { create: create$3 };
        var adt$2 = Adt.generate([
          { before: ["element"] },
          {
            on: [
              "element",
              "offset"
            ]
          },
          { after: ["element"] }
        ]);
        var cata$1 = function(subject, onBefore, onOn, onAfter) {
          return subject.fold(onBefore, onOn, onAfter);
        };
        var getStart = function(situ) {
          return situ.fold(identity, identity, identity);
        };
        var before$2 = adt$2.before;
        var on = adt$2.on;
        var after$2 = adt$2.after;
        var Situ = {
          before: before$2,
          on,
          after: after$2,
          cata: cata$1,
          getStart
        };
        var adt$3 = Adt.generate([
          { domRange: ["rng"] },
          {
            relative: [
              "startSitu",
              "finishSitu"
            ]
          },
          {
            exact: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          }
        ]);
        var exactFromRange = function(simRange) {
          return adt$3.exact(simRange.start(), simRange.soffset(), simRange.finish(), simRange.foffset());
        };
        var getStart$1 = function(selection2) {
          return selection2.match({
            domRange: function(rng) {
              return Element.fromDom(rng.startContainer);
            },
            relative: function(startSitu, finishSitu) {
              return Situ.getStart(startSitu);
            },
            exact: function(start, soffset, finish, foffset) {
              return start;
            }
          });
        };
        var domRange = adt$3.domRange;
        var relative = adt$3.relative;
        var exact = adt$3.exact;
        var getWin = function(selection2) {
          var start = getStart$1(selection2);
          return defaultView(start);
        };
        var range$1 = SimRange.create;
        var Selection = {
          domRange,
          relative,
          exact,
          exactFromRange,
          getWin,
          range: range$1
        };
        var selectNodeContents = function(win, element) {
          var rng = win.document.createRange();
          selectNodeContentsUsing(rng, element);
          return rng;
        };
        var selectNodeContentsUsing = function(rng, element) {
          rng.selectNodeContents(element.dom());
        };
        var setStart = function(rng, situ) {
          situ.fold(function(e) {
            rng.setStartBefore(e.dom());
          }, function(e, o) {
            rng.setStart(e.dom(), o);
          }, function(e) {
            rng.setStartAfter(e.dom());
          });
        };
        var setFinish = function(rng, situ) {
          situ.fold(function(e) {
            rng.setEndBefore(e.dom());
          }, function(e, o) {
            rng.setEnd(e.dom(), o);
          }, function(e) {
            rng.setEndAfter(e.dom());
          });
        };
        var relativeToNative = function(win, startSitu, finishSitu) {
          var range2 = win.document.createRange();
          setStart(range2, startSitu);
          setFinish(range2, finishSitu);
          return range2;
        };
        var exactToNative = function(win, start, soffset, finish, foffset) {
          var rng = win.document.createRange();
          rng.setStart(start.dom(), soffset);
          rng.setEnd(finish.dom(), foffset);
          return rng;
        };
        var toRect = function(rect) {
          return {
            left: constant(rect.left),
            top: constant(rect.top),
            right: constant(rect.right),
            bottom: constant(rect.bottom),
            width: constant(rect.width),
            height: constant(rect.height)
          };
        };
        var getFirstRect = function(rng) {
          var rects = rng.getClientRects();
          var rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
          return rect.width > 0 || rect.height > 0 ? Option.some(rect).map(toRect) : Option.none();
        };
        var adt$4 = Adt.generate([
          {
            ltr: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          },
          {
            rtl: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          }
        ]);
        var fromRange = function(win, type2, range2) {
          return type2(Element.fromDom(range2.startContainer), range2.startOffset, Element.fromDom(range2.endContainer), range2.endOffset);
        };
        var getRanges = function(win, selection2) {
          return selection2.match({
            domRange: function(rng) {
              return {
                ltr: constant(rng),
                rtl: Option.none
              };
            },
            relative: function(startSitu, finishSitu) {
              return {
                ltr: cached(function() {
                  return relativeToNative(win, startSitu, finishSitu);
                }),
                rtl: cached(function() {
                  return Option.some(relativeToNative(win, finishSitu, startSitu));
                })
              };
            },
            exact: function(start, soffset, finish, foffset) {
              return {
                ltr: cached(function() {
                  return exactToNative(win, start, soffset, finish, foffset);
                }),
                rtl: cached(function() {
                  return Option.some(exactToNative(win, finish, foffset, start, soffset));
                })
              };
            }
          });
        };
        var doDiagnose = function(win, ranges) {
          var rng = ranges.ltr();
          if (rng.collapsed) {
            var reversed = ranges.rtl().filter(function(rev) {
              return rev.collapsed === false;
            });
            return reversed.map(function(rev) {
              return adt$4.rtl(Element.fromDom(rev.endContainer), rev.endOffset, Element.fromDom(rev.startContainer), rev.startOffset);
            }).getOrThunk(function() {
              return fromRange(win, adt$4.ltr, rng);
            });
          } else {
            return fromRange(win, adt$4.ltr, rng);
          }
        };
        var diagnose = function(win, selection2) {
          var ranges = getRanges(win, selection2);
          return doDiagnose(win, ranges);
        };
        var asLtrRange = function(win, selection2) {
          var diagnosis = diagnose(win, selection2);
          return diagnosis.match({
            ltr: function(start, soffset, finish, foffset) {
              var rng = win.document.createRange();
              rng.setStart(start.dom(), soffset);
              rng.setEnd(finish.dom(), foffset);
              return rng;
            },
            rtl: function(start, soffset, finish, foffset) {
              var rng = win.document.createRange();
              rng.setStart(finish.dom(), foffset);
              rng.setEnd(start.dom(), soffset);
              return rng;
            }
          });
        };
        var searchForPoint = function(rectForOffset, x, y, maxX, length) {
          if (length === 0) {
            return 0;
          } else if (x === maxX) {
            return length - 1;
          }
          var xDelta = maxX;
          for (var i = 1; i < length; i++) {
            var rect = rectForOffset(i);
            var curDeltaX = Math.abs(x - rect.left);
            if (y <= rect.bottom) {
              if (y < rect.top || curDeltaX > xDelta) {
                return i - 1;
              } else {
                xDelta = curDeltaX;
              }
            }
          }
          return 0;
        };
        var inRect = function(rect, x, y) {
          return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        };
        var locateOffset = function(doc, textnode, x, y, rect) {
          var rangeForOffset = function(o) {
            var r2 = doc.dom().createRange();
            r2.setStart(textnode.dom(), o);
            r2.collapse(true);
            return r2;
          };
          var rectForOffset = function(o) {
            var r2 = rangeForOffset(o);
            return r2.getBoundingClientRect();
          };
          var length = get$2(textnode).length;
          var offset = searchForPoint(rectForOffset, x, y, rect.right, length);
          return rangeForOffset(offset);
        };
        var locate = function(doc, node2, x, y) {
          var r2 = doc.dom().createRange();
          r2.selectNode(node2.dom());
          var rects = r2.getClientRects();
          var foundRect = findMap(rects, function(rect) {
            return inRect(rect, x, y) ? Option.some(rect) : Option.none();
          });
          return foundRect.map(function(rect) {
            return locateOffset(doc, node2, x, y, rect);
          });
        };
        var searchInChildren = function(doc, node2, x, y) {
          var r2 = doc.dom().createRange();
          var nodes = children(node2);
          return findMap(nodes, function(n) {
            r2.selectNode(n.dom());
            return inRect(r2.getBoundingClientRect(), x, y) ? locateNode(doc, n, x, y) : Option.none();
          });
        };
        var locateNode = function(doc, node2, x, y) {
          return isText(node2) ? locate(doc, node2, x, y) : searchInChildren(doc, node2, x, y);
        };
        var locate$1 = function(doc, node2, x, y) {
          var r2 = doc.dom().createRange();
          r2.selectNode(node2.dom());
          var rect = r2.getBoundingClientRect();
          var boundedX = Math.max(rect.left, Math.min(rect.right, x));
          var boundedY = Math.max(rect.top, Math.min(rect.bottom, y));
          return locateNode(doc, node2, boundedX, boundedY);
        };
        var COLLAPSE_TO_LEFT = true;
        var COLLAPSE_TO_RIGHT = false;
        var getCollapseDirection = function(rect, x) {
          return x - rect.left < rect.right - x ? COLLAPSE_TO_LEFT : COLLAPSE_TO_RIGHT;
        };
        var createCollapsedNode = function(doc, target, collapseDirection) {
          var r2 = doc.dom().createRange();
          r2.selectNode(target.dom());
          r2.collapse(collapseDirection);
          return r2;
        };
        var locateInElement = function(doc, node2, x) {
          var cursorRange = doc.dom().createRange();
          cursorRange.selectNode(node2.dom());
          var rect = cursorRange.getBoundingClientRect();
          var collapseDirection = getCollapseDirection(rect, x);
          var f = collapseDirection === COLLAPSE_TO_LEFT ? first : last$1;
          return f(node2).map(function(target) {
            return createCollapsedNode(doc, target, collapseDirection);
          });
        };
        var locateInEmpty = function(doc, node2, x) {
          var rect = node2.dom().getBoundingClientRect();
          var collapseDirection = getCollapseDirection(rect, x);
          return Option.some(createCollapsedNode(doc, node2, collapseDirection));
        };
        var search = function(doc, node2, x) {
          var f = children(node2).length === 0 ? locateInEmpty : locateInElement;
          return f(doc, node2, x);
        };
        var caretPositionFromPoint = function(doc, x, y) {
          return Option.from(doc.dom().caretPositionFromPoint(x, y)).bind(function(pos) {
            if (pos.offsetNode === null) {
              return Option.none();
            }
            var r2 = doc.dom().createRange();
            r2.setStart(pos.offsetNode, pos.offset);
            r2.collapse();
            return Option.some(r2);
          });
        };
        var caretRangeFromPoint = function(doc, x, y) {
          return Option.from(doc.dom().caretRangeFromPoint(x, y));
        };
        var searchTextNodes = function(doc, node2, x, y) {
          var r2 = doc.dom().createRange();
          r2.selectNode(node2.dom());
          var rect = r2.getBoundingClientRect();
          var boundedX = Math.max(rect.left, Math.min(rect.right, x));
          var boundedY = Math.max(rect.top, Math.min(rect.bottom, y));
          return locate$1(doc, node2, boundedX, boundedY);
        };
        var searchFromPoint = function(doc, x, y) {
          return Element.fromPoint(doc, x, y).bind(function(elem) {
            var fallback = function() {
              return search(doc, elem, x);
            };
            return children(elem).length === 0 ? fallback() : searchTextNodes(doc, elem, x, y).orThunk(fallback);
          });
        };
        var availableSearch = document.caretPositionFromPoint ? caretPositionFromPoint : document.caretRangeFromPoint ? caretRangeFromPoint : searchFromPoint;
        var fromPoint$1 = function(win, x, y) {
          var doc = Element.fromDom(win.document);
          return availableSearch(doc, x, y).map(function(rng) {
            return SimRange.create(Element.fromDom(rng.startContainer), rng.startOffset, Element.fromDom(rng.endContainer), rng.endOffset);
          });
        };
        var beforeSpecial = function(element, offset) {
          var name$1 = name(element);
          if (name$1 === "input") {
            return Situ.after(element);
          } else if (!contains([
            "br",
            "img"
          ], name$1)) {
            return Situ.on(element, offset);
          } else {
            return offset === 0 ? Situ.before(element) : Situ.after(element);
          }
        };
        var preprocessRelative = function(startSitu, finishSitu) {
          var start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
          var finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
          return Selection.relative(start, finish);
        };
        var preprocessExact = function(start, soffset, finish, foffset) {
          var startSitu = beforeSpecial(start, soffset);
          var finishSitu = beforeSpecial(finish, foffset);
          return Selection.relative(startSitu, finishSitu);
        };
        var preprocess = function(selection2) {
          return selection2.match({
            domRange: function(rng) {
              var start = Element.fromDom(rng.startContainer);
              var finish = Element.fromDom(rng.endContainer);
              return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
            },
            relative: preprocessRelative,
            exact: preprocessExact
          });
        };
        var makeRange = function(start, soffset, finish, foffset) {
          var doc = owner(start);
          var rng = doc.dom().createRange();
          rng.setStart(start.dom(), soffset);
          rng.setEnd(finish.dom(), foffset);
          return rng;
        };
        var after$3 = function(start, soffset, finish, foffset) {
          var r2 = makeRange(start, soffset, finish, foffset);
          var same = eq(start, finish) && soffset === foffset;
          return r2.collapsed && !same;
        };
        var doSetNativeRange = function(win, rng) {
          Option.from(win.getSelection()).each(function(selection2) {
            selection2.removeAllRanges();
            selection2.addRange(rng);
          });
        };
        var doSetRange = function(win, start, soffset, finish, foffset) {
          var rng = exactToNative(win, start, soffset, finish, foffset);
          doSetNativeRange(win, rng);
        };
        var setLegacyRtlRange = function(win, selection2, start, soffset, finish, foffset) {
          selection2.collapse(start.dom(), soffset);
          selection2.extend(finish.dom(), foffset);
        };
        var setRangeFromRelative = function(win, relative2) {
          return diagnose(win, relative2).match({
            ltr: function(start, soffset, finish, foffset) {
              doSetRange(win, start, soffset, finish, foffset);
            },
            rtl: function(start, soffset, finish, foffset) {
              var selection2 = win.getSelection();
              if (selection2.setBaseAndExtent) {
                selection2.setBaseAndExtent(start.dom(), soffset, finish.dom(), foffset);
              } else if (selection2.extend) {
                try {
                  setLegacyRtlRange(win, selection2, start, soffset, finish, foffset);
                } catch (e) {
                  doSetRange(win, finish, foffset, start, soffset);
                }
              } else {
                doSetRange(win, finish, foffset, start, soffset);
              }
            }
          });
        };
        var setExact = function(win, start, soffset, finish, foffset) {
          var relative2 = preprocessExact(start, soffset, finish, foffset);
          setRangeFromRelative(win, relative2);
        };
        var setRelative = function(win, startSitu, finishSitu) {
          var relative2 = preprocessRelative(startSitu, finishSitu);
          setRangeFromRelative(win, relative2);
        };
        var toNative = function(selection2) {
          var win = Selection.getWin(selection2).dom();
          var getDomRange = function(start, soffset, finish, foffset) {
            return exactToNative(win, start, soffset, finish, foffset);
          };
          var filtered = preprocess(selection2);
          return diagnose(win, filtered).match({
            ltr: getDomRange,
            rtl: getDomRange
          });
        };
        var readRange = function(selection2) {
          if (selection2.rangeCount > 0) {
            var firstRng = selection2.getRangeAt(0);
            var lastRng = selection2.getRangeAt(selection2.rangeCount - 1);
            return Option.some(SimRange.create(Element.fromDom(firstRng.startContainer), firstRng.startOffset, Element.fromDom(lastRng.endContainer), lastRng.endOffset));
          } else {
            return Option.none();
          }
        };
        var doGetExact = function(selection2) {
          var anchor = Element.fromDom(selection2.anchorNode);
          var focus = Element.fromDom(selection2.focusNode);
          return after$3(anchor, selection2.anchorOffset, focus, selection2.focusOffset) ? Option.some(SimRange.create(anchor, selection2.anchorOffset, focus, selection2.focusOffset)) : readRange(selection2);
        };
        var setToElement = function(win, element) {
          var rng = selectNodeContents(win, element);
          doSetNativeRange(win, rng);
        };
        var getExact = function(win) {
          return Option.from(win.getSelection()).filter(function(sel) {
            return sel.rangeCount > 0;
          }).bind(doGetExact);
        };
        var get$9 = function(win) {
          return getExact(win).map(function(range2) {
            return Selection.exact(range2.start(), range2.soffset(), range2.finish(), range2.foffset());
          });
        };
        var getFirstRect$1 = function(win, selection2) {
          var rng = asLtrRange(win, selection2);
          return getFirstRect(rng);
        };
        var getAtPoint = function(win, x, y) {
          return fromPoint$1(win, x, y);
        };
        var clear = function(win) {
          var selection2 = win.getSelection();
          selection2.removeAllRanges();
        };
        var global$3 = tinymce.util.Tools.resolve("tinymce.util.VK");
        var forward = function(editor, isRoot, cell2, lazyWire) {
          return go(editor, isRoot, CellNavigation.next(cell2), lazyWire);
        };
        var backward = function(editor, isRoot, cell2, lazyWire) {
          return go(editor, isRoot, CellNavigation.prev(cell2), lazyWire);
        };
        var getCellFirstCursorPosition = function(editor, cell2) {
          var selection2 = Selection.exact(cell2, 0, cell2, 0);
          return toNative(selection2);
        };
        var getNewRowCursorPosition = function(editor, table3) {
          var rows2 = descendants$1(table3, "tr");
          return last(rows2).bind(function(last2) {
            return descendant$1(last2, "td,th").map(function(first2) {
              return getCellFirstCursorPosition(editor, first2);
            });
          });
        };
        var go = function(editor, isRoot, cell2, actions, lazyWire) {
          return cell2.fold(Option.none, Option.none, function(current, next2) {
            return first(next2).map(function(cell3) {
              return getCellFirstCursorPosition(editor, cell3);
            });
          }, function(current) {
            return TableLookup.table(current, isRoot).bind(function(table3) {
              var targets = TableTargets.noMenu(current);
              editor.undoManager.transact(function() {
                actions.insertRowsAfter(table3, targets);
              });
              return getNewRowCursorPosition(editor, table3);
            });
          });
        };
        var rootElements = [
          "table",
          "li",
          "dl"
        ];
        var handle$1 = function(event, editor, actions, lazyWire) {
          if (event.keyCode === global$3.TAB) {
            var body_1 = getBody$1(editor);
            var isRoot_1 = function(element) {
              var name$1 = name(element);
              return eq(element, body_1) || contains(rootElements, name$1);
            };
            var rng = editor.selection.getRng();
            if (rng.collapsed) {
              var start = Element.fromDom(rng.startContainer);
              TableLookup.cell(start, isRoot_1).each(function(cell2) {
                event.preventDefault();
                var navigation = event.shiftKey ? backward : forward;
                var rng2 = navigation(editor, isRoot_1, cell2, actions, lazyWire);
                rng2.each(function(range2) {
                  editor.selection.setRng(range2);
                });
              });
            }
          }
        };
        var TabContext = { handle: handle$1 };
        var create$4 = Immutable("selection", "kill");
        var Response = { create: create$4 };
        var create$5 = function(start, soffset, finish, foffset) {
          return {
            start: constant(Situ.on(start, soffset)),
            finish: constant(Situ.on(finish, foffset))
          };
        };
        var Situs = { create: create$5 };
        var convertToRange = function(win, selection2) {
          var rng = asLtrRange(win, selection2);
          return SimRange.create(Element.fromDom(rng.startContainer), rng.startOffset, Element.fromDom(rng.endContainer), rng.endOffset);
        };
        var makeSitus = Situs.create;
        var Util = {
          convertToRange,
          makeSitus
        };
        var sync = function(container, isRoot, start, soffset, finish, foffset, selectRange) {
          if (!(eq(start, finish) && soffset === foffset)) {
            return closest$1(start, "td,th", isRoot).bind(function(s) {
              return closest$1(finish, "td,th", isRoot).bind(function(f) {
                return detect$5(container, isRoot, s, f, selectRange);
              });
            });
          } else {
            return Option.none();
          }
        };
        var detect$5 = function(container, isRoot, start, finish, selectRange) {
          if (!eq(start, finish)) {
            return CellSelection.identify(start, finish, isRoot).bind(function(cellSel) {
              var boxes = cellSel.boxes().getOr([]);
              if (boxes.length > 0) {
                selectRange(container, boxes, cellSel.start(), cellSel.finish());
                return Option.some(Response.create(Option.some(Util.makeSitus(start, 0, start, getEnd(start))), true));
              } else {
                return Option.none();
              }
            });
          } else {
            return Option.none();
          }
        };
        var update = function(rows2, columns2, container, selected2, annotations) {
          var updateSelection = function(newSels) {
            annotations.clear(container);
            annotations.selectRange(container, newSels.boxes(), newSels.start(), newSels.finish());
            return newSels.boxes();
          };
          return CellSelection.shiftSelection(selected2, rows2, columns2, annotations.firstSelectedSelector(), annotations.lastSelectedSelector()).map(updateSelection);
        };
        var KeySelection = {
          sync,
          detect: detect$5,
          update
        };
        var traverse = Immutable("item", "mode");
        var backtrack = function(universe2, item, _direction, transition) {
          if (transition === void 0) {
            transition = sidestep;
          }
          return universe2.property().parent(item).map(function(p) {
            return traverse(p, transition);
          });
        };
        var sidestep = function(universe2, item, direction, transition) {
          if (transition === void 0) {
            transition = advance;
          }
          return direction.sibling(universe2, item).map(function(p) {
            return traverse(p, transition);
          });
        };
        var advance = function(universe2, item, direction, transition) {
          if (transition === void 0) {
            transition = advance;
          }
          var children2 = universe2.property().children(item);
          var result = direction.first(children2);
          return result.map(function(r2) {
            return traverse(r2, transition);
          });
        };
        var successors = [
          {
            current: backtrack,
            next: sidestep,
            fallback: Option.none()
          },
          {
            current: sidestep,
            next: advance,
            fallback: Option.some(backtrack)
          },
          {
            current: advance,
            next: advance,
            fallback: Option.some(sidestep)
          }
        ];
        var go$1 = function(universe2, item, mode, direction, rules) {
          if (rules === void 0) {
            rules = successors;
          }
          var ruleOpt = find(rules, function(succ) {
            return succ.current === mode;
          });
          return ruleOpt.bind(function(rule) {
            return rule.current(universe2, item, direction, rule.next).orThunk(function() {
              return rule.fallback.bind(function(fb) {
                return go$1(universe2, item, fb, direction);
              });
            });
          });
        };
        var left = function() {
          var sibling = function(universe2, item) {
            return universe2.query().prevSibling(item);
          };
          var first2 = function(children2) {
            return children2.length > 0 ? Option.some(children2[children2.length - 1]) : Option.none();
          };
          return {
            sibling,
            first: first2
          };
        };
        var right = function() {
          var sibling = function(universe2, item) {
            return universe2.query().nextSibling(item);
          };
          var first2 = function(children2) {
            return children2.length > 0 ? Option.some(children2[0]) : Option.none();
          };
          return {
            sibling,
            first: first2
          };
        };
        var Walkers = {
          left,
          right
        };
        var hone = function(universe2, item, predicate, mode, direction, isRoot) {
          var next2 = go$1(universe2, item, mode, direction);
          return next2.bind(function(n) {
            if (isRoot(n.item())) {
              return Option.none();
            } else {
              return predicate(n.item()) ? Option.some(n.item()) : hone(universe2, n.item(), predicate, n.mode(), direction, isRoot);
            }
          });
        };
        var left$1 = function(universe2, item, predicate, isRoot) {
          return hone(universe2, item, predicate, sidestep, Walkers.left(), isRoot);
        };
        var right$1 = function(universe2, item, predicate, isRoot) {
          return hone(universe2, item, predicate, sidestep, Walkers.right(), isRoot);
        };
        var isLeaf = function(universe2) {
          return function(element) {
            return universe2.property().children(element).length === 0;
          };
        };
        var before$3 = function(universe2, item, isRoot) {
          return seekLeft(universe2, item, isLeaf(universe2), isRoot);
        };
        var after$4 = function(universe2, item, isRoot) {
          return seekRight(universe2, item, isLeaf(universe2), isRoot);
        };
        var seekLeft = left$1;
        var seekRight = right$1;
        var universe$2 = DomUniverse();
        var before$4 = function(element, isRoot) {
          return before$3(universe$2, element, isRoot);
        };
        var after$5 = function(element, isRoot) {
          return after$4(universe$2, element, isRoot);
        };
        var seekLeft$1 = function(element, predicate, isRoot) {
          return seekLeft(universe$2, element, predicate, isRoot);
        };
        var seekRight$1 = function(element, predicate, isRoot) {
          return seekRight(universe$2, element, predicate, isRoot);
        };
        var ancestor$2 = function(scope, predicate, isRoot) {
          return ancestor(scope, predicate, isRoot).isSome();
        };
        var point = Immutable("element", "offset");
        var delta = Immutable("element", "deltaOffset");
        var range$2 = Immutable("element", "start", "finish");
        var points = Immutable("begin", "end");
        var text = Immutable("element", "text");
        var adt$5 = Adt.generate([
          { none: ["message"] },
          { success: [] },
          { failedUp: ["cell"] },
          { failedDown: ["cell"] }
        ]);
        var isOverlapping = function(bridge, before2, after2) {
          var beforeBounds = bridge.getRect(before2);
          var afterBounds = bridge.getRect(after2);
          return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;
        };
        var isRow = function(elem) {
          return closest$1(elem, "tr");
        };
        var verify = function(bridge, before2, beforeOffset, after2, afterOffset, failure, isRoot) {
          return closest$1(after2, "td,th", isRoot).bind(function(afterCell) {
            return closest$1(before2, "td,th", isRoot).map(function(beforeCell) {
              if (!eq(afterCell, beforeCell)) {
                return DomParent.sharedOne(isRow, [
                  afterCell,
                  beforeCell
                ]).fold(function() {
                  return isOverlapping(bridge, beforeCell, afterCell) ? adt$5.success() : failure(beforeCell);
                }, function(_sharedRow) {
                  return failure(beforeCell);
                });
              } else {
                return eq(after2, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$5.none("in same cell");
              }
            });
          }).getOr(adt$5.none("default"));
        };
        var cata$2 = function(subject, onNone, onSuccess, onFailedUp, onFailedDown) {
          return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);
        };
        var BeforeAfter = __assign(__assign({}, adt$5), {
          verify,
          cata: cata$2
        });
        var inAncestor = Immutable("ancestor", "descendants", "element", "index");
        var inParent = Immutable("parent", "children", "element", "index");
        var indexInParent = function(element) {
          return parent(element).bind(function(parent2) {
            var children$12 = children(parent2);
            return indexOf(children$12, element).map(function(index) {
              return inParent(parent2, children$12, element, index);
            });
          });
        };
        var indexOf = function(elements, element) {
          return findIndex(elements, curry(eq, element));
        };
        var isBr = function(elem) {
          return name(elem) === "br";
        };
        var gatherer = function(cand, gather, isRoot) {
          return gather(cand, isRoot).bind(function(target) {
            return isText(target) && get$2(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Option.some(target);
          });
        };
        var handleBr = function(isRoot, element, direction) {
          return direction.traverse(element).orThunk(function() {
            return gatherer(element, direction.gather, isRoot);
          }).map(direction.relative);
        };
        var findBr = function(element, offset) {
          return child(element, offset).filter(isBr).orThunk(function() {
            return child(element, offset - 1).filter(isBr);
          });
        };
        var handleParent = function(isRoot, element, offset, direction) {
          return findBr(element, offset).bind(function(br) {
            return direction.traverse(br).fold(function() {
              return gatherer(br, direction.gather, isRoot).map(direction.relative);
            }, function(adjacent) {
              return indexInParent(adjacent).map(function(info) {
                return Situ.on(info.parent(), info.index());
              });
            });
          });
        };
        var tryBr = function(isRoot, element, offset, direction) {
          var target = isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction);
          return target.map(function(tgt) {
            return {
              start: constant(tgt),
              finish: constant(tgt)
            };
          });
        };
        var process = function(analysis) {
          return BeforeAfter.cata(analysis, function(message) {
            return Option.none();
          }, function() {
            return Option.none();
          }, function(cell2) {
            return Option.some(point(cell2, 0));
          }, function(cell2) {
            return Option.some(point(cell2, getEnd(cell2)));
          });
        };
        var BrTags = {
          tryBr,
          process
        };
        var nu$3 = MixedBag([
          "left",
          "top",
          "right",
          "bottom"
        ], []);
        var moveDown = function(caret, amount) {
          return nu$3({
            left: caret.left(),
            top: caret.top() + amount,
            right: caret.right(),
            bottom: caret.bottom() + amount
          });
        };
        var moveUp = function(caret, amount) {
          return nu$3({
            left: caret.left(),
            top: caret.top() - amount,
            right: caret.right(),
            bottom: caret.bottom() - amount
          });
        };
        var moveBottomTo = function(caret, bottom) {
          var height2 = caret.bottom() - caret.top();
          return nu$3({
            left: caret.left(),
            top: bottom - height2,
            right: caret.right(),
            bottom
          });
        };
        var moveTopTo = function(caret, top) {
          var height2 = caret.bottom() - caret.top();
          return nu$3({
            left: caret.left(),
            top,
            right: caret.right(),
            bottom: top + height2
          });
        };
        var translate = function(caret, xDelta, yDelta) {
          return nu$3({
            left: caret.left() + xDelta,
            top: caret.top() + yDelta,
            right: caret.right() + xDelta,
            bottom: caret.bottom() + yDelta
          });
        };
        var getTop$1 = function(caret) {
          return caret.top();
        };
        var getBottom = function(caret) {
          return caret.bottom();
        };
        var toString = function(caret) {
          return "(" + caret.left() + ", " + caret.top() + ") -> (" + caret.right() + ", " + caret.bottom() + ")";
        };
        var Carets = {
          nu: nu$3,
          moveUp,
          moveDown,
          moveBottomTo,
          moveTopTo,
          getTop: getTop$1,
          getBottom,
          translate,
          toString
        };
        var getPartialBox = function(bridge, element, offset) {
          if (offset >= 0 && offset < getEnd(element)) {
            return bridge.getRangedRect(element, offset, element, offset + 1);
          } else if (offset > 0) {
            return bridge.getRangedRect(element, offset - 1, element, offset);
          }
          return Option.none();
        };
        var toCaret = function(rect) {
          return Carets.nu({
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom
          });
        };
        var getElemBox = function(bridge, element) {
          return Option.some(bridge.getRect(element));
        };
        var getBoxAt = function(bridge, element, offset) {
          if (isElement(element)) {
            return getElemBox(bridge, element).map(toCaret);
          } else if (isText(element)) {
            return getPartialBox(bridge, element, offset).map(toCaret);
          } else {
            return Option.none();
          }
        };
        var getEntireBox = function(bridge, element) {
          if (isElement(element)) {
            return getElemBox(bridge, element).map(toCaret);
          } else if (isText(element)) {
            return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);
          } else {
            return Option.none();
          }
        };
        var Rectangles = {
          getBoxAt,
          getEntireBox
        };
        var JUMP_SIZE = 5;
        var NUM_RETRIES = 100;
        var adt$6 = Adt.generate([
          { none: [] },
          { retry: ["caret"] }
        ]);
        var isOutside = function(caret, box) {
          return caret.left() < box.left() || Math.abs(box.right() - caret.left()) < 1 || caret.left() > box.right();
        };
        var inOutsideBlock = function(bridge, element, caret) {
          return closest(element, DomStructure.isBlock).fold(constant(false), function(cell2) {
            return Rectangles.getEntireBox(bridge, cell2).exists(function(box) {
              return isOutside(caret, box);
            });
          });
        };
        var adjustDown = function(bridge, element, guessBox, original, caret) {
          var lowerCaret = Carets.moveDown(caret, JUMP_SIZE);
          if (Math.abs(guessBox.bottom() - original.bottom()) < 1) {
            return adt$6.retry(lowerCaret);
          } else if (guessBox.top() > caret.bottom()) {
            return adt$6.retry(lowerCaret);
          } else if (guessBox.top() === caret.bottom()) {
            return adt$6.retry(Carets.moveDown(caret, 1));
          } else {
            return inOutsideBlock(bridge, element, caret) ? adt$6.retry(Carets.translate(lowerCaret, JUMP_SIZE, 0)) : adt$6.none();
          }
        };
        var adjustUp = function(bridge, element, guessBox, original, caret) {
          var higherCaret = Carets.moveUp(caret, JUMP_SIZE);
          if (Math.abs(guessBox.top() - original.top()) < 1) {
            return adt$6.retry(higherCaret);
          } else if (guessBox.bottom() < caret.top()) {
            return adt$6.retry(higherCaret);
          } else if (guessBox.bottom() === caret.top()) {
            return adt$6.retry(Carets.moveUp(caret, 1));
          } else {
            return inOutsideBlock(bridge, element, caret) ? adt$6.retry(Carets.translate(higherCaret, JUMP_SIZE, 0)) : adt$6.none();
          }
        };
        var upMovement = {
          point: Carets.getTop,
          adjuster: adjustUp,
          move: Carets.moveUp,
          gather: before$4
        };
        var downMovement = {
          point: Carets.getBottom,
          adjuster: adjustDown,
          move: Carets.moveDown,
          gather: after$5
        };
        var isAtTable = function(bridge, x, y) {
          return bridge.elementFromPoint(x, y).filter(function(elm) {
            return name(elm) === "table";
          }).isSome();
        };
        var adjustForTable = function(bridge, movement, original, caret, numRetries) {
          return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);
        };
        var adjustTil = function(bridge, movement, original, caret, numRetries) {
          if (numRetries === 0) {
            return Option.some(caret);
          }
          if (isAtTable(bridge, caret.left(), movement.point(caret))) {
            return adjustForTable(bridge, movement, original, caret, numRetries - 1);
          }
          return bridge.situsFromPoint(caret.left(), movement.point(caret)).bind(function(guess) {
            return guess.start().fold(Option.none, function(element) {
              return Rectangles.getEntireBox(bridge, element).bind(function(guessBox) {
                return movement.adjuster(bridge, element, guessBox, original, caret).fold(Option.none, function(newCaret) {
                  return adjustTil(bridge, movement, original, newCaret, numRetries - 1);
                });
              }).orThunk(function() {
                return Option.some(caret);
              });
            }, Option.none);
          });
        };
        var ieTryDown = function(bridge, caret) {
          return bridge.situsFromPoint(caret.left(), caret.bottom() + JUMP_SIZE);
        };
        var ieTryUp = function(bridge, caret) {
          return bridge.situsFromPoint(caret.left(), caret.top() - JUMP_SIZE);
        };
        var checkScroll = function(movement, adjusted, bridge) {
          if (movement.point(adjusted) > bridge.getInnerHeight()) {
            return Option.some(movement.point(adjusted) - bridge.getInnerHeight());
          } else if (movement.point(adjusted) < 0) {
            return Option.some(-movement.point(adjusted));
          } else {
            return Option.none();
          }
        };
        var retry = function(movement, bridge, caret) {
          var moved = movement.move(caret, JUMP_SIZE);
          var adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);
          return checkScroll(movement, adjusted, bridge).fold(function() {
            return bridge.situsFromPoint(adjusted.left(), movement.point(adjusted));
          }, function(delta2) {
            bridge.scrollBy(0, delta2);
            return bridge.situsFromPoint(adjusted.left(), movement.point(adjusted) - delta2);
          });
        };
        var Retries = {
          tryUp: curry(retry, upMovement),
          tryDown: curry(retry, downMovement),
          ieTryUp,
          ieTryDown,
          getJumpSize: constant(JUMP_SIZE)
        };
        var MAX_RETRIES = 20;
        var platform$1 = PlatformDetection$1.detect();
        var findSpot = function(bridge, isRoot, direction) {
          return bridge.getSelection().bind(function(sel) {
            return BrTags.tryBr(isRoot, sel.finish(), sel.foffset(), direction).fold(function() {
              return Option.some(point(sel.finish(), sel.foffset()));
            }, function(brNeighbour) {
              var range2 = bridge.fromSitus(brNeighbour);
              var analysis = BeforeAfter.verify(bridge, sel.finish(), sel.foffset(), range2.finish(), range2.foffset(), direction.failure, isRoot);
              return BrTags.process(analysis);
            });
          });
        };
        var scan = function(bridge, isRoot, element, offset, direction, numRetries) {
          if (numRetries === 0) {
            return Option.none();
          }
          return tryCursor(bridge, isRoot, element, offset, direction).bind(function(situs) {
            var range2 = bridge.fromSitus(situs);
            var analysis = BeforeAfter.verify(bridge, element, offset, range2.finish(), range2.foffset(), direction.failure, isRoot);
            return BeforeAfter.cata(analysis, function() {
              return Option.none();
            }, function() {
              return Option.some(situs);
            }, function(cell2) {
              if (eq(element, cell2) && offset === 0) {
                return tryAgain(bridge, element, offset, Carets.moveUp, direction);
              } else {
                return scan(bridge, isRoot, cell2, 0, direction, numRetries - 1);
              }
            }, function(cell2) {
              if (eq(element, cell2) && offset === getEnd(cell2)) {
                return tryAgain(bridge, element, offset, Carets.moveDown, direction);
              } else {
                return scan(bridge, isRoot, cell2, getEnd(cell2), direction, numRetries - 1);
              }
            });
          });
        };
        var tryAgain = function(bridge, element, offset, move, direction) {
          return Rectangles.getBoxAt(bridge, element, offset).bind(function(box) {
            return tryAt(bridge, direction, move(box, Retries.getJumpSize()));
          });
        };
        var tryAt = function(bridge, direction, box) {
          if (platform$1.browser.isChrome() || platform$1.browser.isSafari() || platform$1.browser.isFirefox() || platform$1.browser.isEdge()) {
            return direction.otherRetry(bridge, box);
          } else if (platform$1.browser.isIE()) {
            return direction.ieRetry(bridge, box);
          } else {
            return Option.none();
          }
        };
        var tryCursor = function(bridge, isRoot, element, offset, direction) {
          return Rectangles.getBoxAt(bridge, element, offset).bind(function(box) {
            return tryAt(bridge, direction, box);
          });
        };
        var handle$2 = function(bridge, isRoot, direction) {
          return findSpot(bridge, isRoot, direction).bind(function(spot2) {
            return scan(bridge, isRoot, spot2.element(), spot2.offset(), direction, MAX_RETRIES).map(bridge.fromSitus);
          });
        };
        var TableKeys = { handle: handle$2 };
        var detection = PlatformDetection$1.detect();
        var inSameTable = function(elem, table3) {
          return ancestor$2(elem, function(e) {
            return parent(e).exists(function(p) {
              return eq(p, table3);
            });
          });
        };
        var simulate = function(bridge, isRoot, direction, initial, anchor) {
          return closest$1(initial, "td,th", isRoot).bind(function(start) {
            return closest$1(start, "table", isRoot).bind(function(table3) {
              if (!inSameTable(anchor, table3)) {
                return Option.none();
              }
              return TableKeys.handle(bridge, isRoot, direction).bind(function(range2) {
                return closest$1(range2.finish(), "td,th", isRoot).map(function(finish) {
                  return {
                    start: constant(start),
                    finish: constant(finish),
                    range: constant(range2)
                  };
                });
              });
            });
          });
        };
        var navigate = function(bridge, isRoot, direction, initial, anchor, precheck) {
          if (detection.browser.isIE()) {
            return Option.none();
          } else {
            return precheck(initial, isRoot).orThunk(function() {
              return simulate(bridge, isRoot, direction, initial, anchor).map(function(info) {
                var range2 = info.range();
                return Response.create(Option.some(Util.makeSitus(range2.start(), range2.soffset(), range2.finish(), range2.foffset())), true);
              });
            });
          }
        };
        var firstUpCheck = function(initial, isRoot) {
          return closest$1(initial, "tr", isRoot).bind(function(startRow) {
            return closest$1(startRow, "table", isRoot).bind(function(table3) {
              var rows2 = descendants$1(table3, "tr");
              if (eq(startRow, rows2[0])) {
                return seekLeft$1(table3, function(element) {
                  return last$1(element).isSome();
                }, isRoot).map(function(last2) {
                  var lastOffset = getEnd(last2);
                  return Response.create(Option.some(Util.makeSitus(last2, lastOffset, last2, lastOffset)), true);
                });
              } else {
                return Option.none();
              }
            });
          });
        };
        var lastDownCheck = function(initial, isRoot) {
          return closest$1(initial, "tr", isRoot).bind(function(startRow) {
            return closest$1(startRow, "table", isRoot).bind(function(table3) {
              var rows2 = descendants$1(table3, "tr");
              if (eq(startRow, rows2[rows2.length - 1])) {
                return seekRight$1(table3, function(element) {
                  return first(element).isSome();
                }, isRoot).map(function(first2) {
                  return Response.create(Option.some(Util.makeSitus(first2, 0, first2, 0)), true);
                });
              } else {
                return Option.none();
              }
            });
          });
        };
        var select = function(bridge, container, isRoot, direction, initial, anchor, selectRange) {
          return simulate(bridge, isRoot, direction, initial, anchor).bind(function(info) {
            return KeySelection.detect(container, isRoot, info.start(), info.finish(), selectRange);
          });
        };
        var VerticalMovement = {
          navigate,
          select,
          firstUpCheck,
          lastDownCheck
        };
        var findCell = function(target, isRoot) {
          return closest$1(target, "td,th", isRoot);
        };
        function MouseSelection(bridge, container, isRoot, annotations) {
          var cursor = Option.none();
          var clearState = function() {
            cursor = Option.none();
          };
          var mousedown = function(event) {
            annotations.clear(container);
            cursor = findCell(event.target(), isRoot);
          };
          var mouseover = function(event) {
            cursor.each(function(start) {
              annotations.clear(container);
              findCell(event.target(), isRoot).each(function(finish) {
                CellSelection.identify(start, finish, isRoot).each(function(cellSel) {
                  var boxes = cellSel.boxes().getOr([]);
                  if (boxes.length > 1 || boxes.length === 1 && !eq(start, finish)) {
                    annotations.selectRange(container, boxes, cellSel.start(), cellSel.finish());
                    bridge.selectContents(finish);
                  }
                });
              });
            });
          };
          var mouseup = function(_event) {
            cursor.each(clearState);
          };
          return {
            mousedown,
            mouseover,
            mouseup
          };
        }
        var down = {
          traverse: nextSibling,
          gather: after$5,
          relative: Situ.before,
          otherRetry: Retries.tryDown,
          ieRetry: Retries.ieTryDown,
          failure: BeforeAfter.failedDown
        };
        var up = {
          traverse: prevSibling,
          gather: before$4,
          relative: Situ.before,
          otherRetry: Retries.tryUp,
          ieRetry: Retries.ieTryUp,
          failure: BeforeAfter.failedUp
        };
        var KeyDirection = {
          down,
          up
        };
        var isKey = function(key2) {
          return function(keycode) {
            return keycode === key2;
          };
        };
        var isUp = isKey(38);
        var isDown = isKey(40);
        var isNavigation = function(keycode) {
          return keycode >= 37 && keycode <= 40;
        };
        var SelectionKeys = {
          ltr: {
            isBackward: isKey(37),
            isForward: isKey(39)
          },
          rtl: {
            isBackward: isKey(39),
            isForward: isKey(37)
          },
          isUp,
          isDown,
          isNavigation
        };
        var toRaw = function(sr) {
          return {
            left: sr.left(),
            top: sr.top(),
            right: sr.right(),
            bottom: sr.bottom(),
            width: sr.width(),
            height: sr.height()
          };
        };
        var Rect = { toRaw };
        var isSafari = PlatformDetection$1.detect().browser.isSafari();
        var get$a = function(_DOC) {
          var doc = _DOC !== void 0 ? _DOC.dom() : domGlobals.document;
          var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
          var y = doc.body.scrollTop || doc.documentElement.scrollTop;
          return Position(x, y);
        };
        var by = function(x, y, _DOC) {
          var doc = _DOC !== void 0 ? _DOC.dom() : domGlobals.document;
          var win = doc.defaultView;
          win.scrollBy(x, y);
        };
        var WindowBridge = function(win) {
          var elementFromPoint = function(x, y) {
            return Element.fromPoint(Element.fromDom(win.document), x, y);
          };
          var getRect = function(element) {
            return element.dom().getBoundingClientRect();
          };
          var getRangedRect = function(start, soffset, finish, foffset) {
            var sel = Selection.exact(start, soffset, finish, foffset);
            return getFirstRect$1(win, sel).map(Rect.toRaw);
          };
          var getSelection = function() {
            return get$9(win).map(function(exactAdt) {
              return Util.convertToRange(win, exactAdt);
            });
          };
          var fromSitus = function(situs) {
            var relative2 = Selection.relative(situs.start(), situs.finish());
            return Util.convertToRange(win, relative2);
          };
          var situsFromPoint = function(x, y) {
            return getAtPoint(win, x, y).map(function(exact2) {
              return Situs.create(exact2.start(), exact2.soffset(), exact2.finish(), exact2.foffset());
            });
          };
          var clearSelection = function() {
            clear(win);
          };
          var selectContents = function(element) {
            setToElement(win, element);
          };
          var setSelection = function(sel) {
            setExact(win, sel.start(), sel.soffset(), sel.finish(), sel.foffset());
          };
          var setRelativeSelection = function(start, finish) {
            setRelative(win, start, finish);
          };
          var getInnerHeight = function() {
            return win.innerHeight;
          };
          var getScrollY = function() {
            var pos = get$a(Element.fromDom(win.document));
            return pos.top();
          };
          var scrollBy = function(x, y) {
            by(x, y, Element.fromDom(win.document));
          };
          return {
            elementFromPoint,
            getRect,
            getRangedRect,
            getSelection,
            fromSitus,
            situsFromPoint,
            clearSelection,
            setSelection,
            setRelativeSelection,
            selectContents,
            getInnerHeight,
            getScrollY,
            scrollBy
          };
        };
        var rc = Immutable("rows", "cols");
        var mouse = function(win, container, isRoot, annotations) {
          var bridge = WindowBridge(win);
          var handlers = MouseSelection(bridge, container, isRoot, annotations);
          return {
            mousedown: handlers.mousedown,
            mouseover: handlers.mouseover,
            mouseup: handlers.mouseup
          };
        };
        var keyboard = function(win, container, isRoot, annotations) {
          var bridge = WindowBridge(win);
          var clearToNavigate = function() {
            annotations.clear(container);
            return Option.none();
          };
          var keydown = function(event, start, soffset, finish, foffset, direction) {
            var realEvent = event.raw();
            var keycode = realEvent.which;
            var shiftKey = realEvent.shiftKey === true;
            var handler = CellSelection.retrieve(container, annotations.selectedSelector()).fold(function() {
              if (SelectionKeys.isDown(keycode) && shiftKey) {
                return curry(VerticalMovement.select, bridge, container, isRoot, KeyDirection.down, finish, start, annotations.selectRange);
              } else if (SelectionKeys.isUp(keycode) && shiftKey) {
                return curry(VerticalMovement.select, bridge, container, isRoot, KeyDirection.up, finish, start, annotations.selectRange);
              } else if (SelectionKeys.isDown(keycode)) {
                return curry(VerticalMovement.navigate, bridge, isRoot, KeyDirection.down, finish, start, VerticalMovement.lastDownCheck);
              } else if (SelectionKeys.isUp(keycode)) {
                return curry(VerticalMovement.navigate, bridge, isRoot, KeyDirection.up, finish, start, VerticalMovement.firstUpCheck);
              } else {
                return Option.none;
              }
            }, function(selected2) {
              var update2 = function(attempts) {
                return function() {
                  var navigation = findMap(attempts, function(delta2) {
                    return KeySelection.update(delta2.rows(), delta2.cols(), container, selected2, annotations);
                  });
                  return navigation.fold(function() {
                    return CellSelection.getEdges(container, annotations.firstSelectedSelector(), annotations.lastSelectedSelector()).map(function(edges) {
                      var relative2 = SelectionKeys.isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;
                      bridge.setRelativeSelection(Situ.on(edges.first(), 0), relative2(edges.table()));
                      annotations.clear(container);
                      return Response.create(Option.none(), true);
                    });
                  }, function(_) {
                    return Option.some(Response.create(Option.none(), true));
                  });
                };
              };
              if (SelectionKeys.isDown(keycode) && shiftKey) {
                return update2([rc(1, 0)]);
              } else if (SelectionKeys.isUp(keycode) && shiftKey) {
                return update2([rc(-1, 0)]);
              } else if (direction.isBackward(keycode) && shiftKey) {
                return update2([
                  rc(0, -1),
                  rc(-1, 0)
                ]);
              } else if (direction.isForward(keycode) && shiftKey) {
                return update2([
                  rc(0, 1),
                  rc(1, 0)
                ]);
              } else if (SelectionKeys.isNavigation(keycode) && shiftKey === false) {
                return clearToNavigate;
              } else {
                return Option.none;
              }
            });
            return handler();
          };
          var keyup = function(event, start, soffset, finish, foffset) {
            return CellSelection.retrieve(container, annotations.selectedSelector()).fold(function() {
              var realEvent = event.raw();
              var keycode = realEvent.which;
              var shiftKey = realEvent.shiftKey === true;
              if (shiftKey === false) {
                return Option.none();
              }
              if (SelectionKeys.isNavigation(keycode)) {
                return KeySelection.sync(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);
              } else {
                return Option.none();
              }
            }, Option.none);
          };
          return {
            keydown,
            keyup
          };
        };
        var InputHandlers = {
          mouse,
          keyboard
        };
        var remove$7 = function(element, classes) {
          each(classes, function(x) {
            remove$5(element, x);
          });
        };
        var addClass = function(clazz) {
          return function(element) {
            add$2(element, clazz);
          };
        };
        var removeClasses = function(classes) {
          return function(element) {
            remove$7(element, classes);
          };
        };
        var byClass = function(ephemera) {
          var addSelectionClass = addClass(ephemera.selected());
          var removeSelectionClasses = removeClasses([
            ephemera.selected(),
            ephemera.lastSelected(),
            ephemera.firstSelected()
          ]);
          var clear2 = function(container) {
            var sels = descendants$1(container, ephemera.selectedSelector());
            each(sels, removeSelectionClasses);
          };
          var selectRange = function(container, cells2, start, finish) {
            clear2(container);
            each(cells2, addSelectionClass);
            add$2(start, ephemera.firstSelected());
            add$2(finish, ephemera.lastSelected());
          };
          return {
            clear: clear2,
            selectRange,
            selectedSelector: ephemera.selectedSelector,
            firstSelectedSelector: ephemera.firstSelectedSelector,
            lastSelectedSelector: ephemera.lastSelectedSelector
          };
        };
        var byAttr = function(ephemera) {
          var removeSelectionAttributes = function(element) {
            remove(element, ephemera.selected());
            remove(element, ephemera.firstSelected());
            remove(element, ephemera.lastSelected());
          };
          var addSelectionAttribute = function(element) {
            set(element, ephemera.selected(), "1");
          };
          var clear2 = function(container) {
            var sels = descendants$1(container, ephemera.selectedSelector());
            each(sels, removeSelectionAttributes);
          };
          var selectRange = function(container, cells2, start, finish) {
            clear2(container);
            each(cells2, addSelectionAttribute);
            set(start, ephemera.firstSelected(), "1");
            set(finish, ephemera.lastSelected(), "1");
          };
          return {
            clear: clear2,
            selectRange,
            selectedSelector: ephemera.selectedSelector,
            firstSelectedSelector: ephemera.firstSelectedSelector,
            lastSelectedSelector: ephemera.lastSelectedSelector
          };
        };
        var SelectionAnnotation = {
          byClass,
          byAttr
        };
        var hasInternalTarget = function(e) {
          return has$1(Element.fromDom(e.target), "ephox-snooker-resizer-bar") === false;
        };
        function CellSelection$1(editor, lazyResize) {
          var handlerStruct = MixedBag([
            "mousedown",
            "mouseover",
            "mouseup",
            "keyup",
            "keydown"
          ], []);
          var handlers = Option.none();
          var annotations = SelectionAnnotation.byAttr(Ephemera);
          editor.on("init", function(e) {
            var win = editor.getWin();
            var body2 = getBody$1(editor);
            var isRoot = getIsRoot(editor);
            var syncSelection = function() {
              var sel = editor.selection;
              var start = Element.fromDom(sel.getStart());
              var end = Element.fromDom(sel.getEnd());
              var shared = DomParent.sharedOne(TableLookup.table, [
                start,
                end
              ]);
              shared.fold(function() {
                annotations.clear(body2);
              }, noop);
            };
            var mouseHandlers = InputHandlers.mouse(win, body2, isRoot, annotations);
            var keyHandlers = InputHandlers.keyboard(win, body2, isRoot, annotations);
            var hasShiftKey = function(event) {
              return event.raw().shiftKey === true;
            };
            var handleResponse = function(event, response) {
              if (!hasShiftKey(event)) {
                return;
              }
              if (response.kill()) {
                event.kill();
              }
              response.selection().each(function(ns) {
                var relative2 = Selection.relative(ns.start(), ns.finish());
                var rng = asLtrRange(win, relative2);
                editor.selection.setRng(rng);
              });
            };
            var keyup = function(event) {
              var wrappedEvent = wrapEvent(event);
              if (wrappedEvent.raw().shiftKey && SelectionKeys.isNavigation(wrappedEvent.raw().which)) {
                var rng = editor.selection.getRng();
                var start = Element.fromDom(rng.startContainer);
                var end = Element.fromDom(rng.endContainer);
                keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each(function(response) {
                  handleResponse(wrappedEvent, response);
                });
              }
            };
            var keydown = function(event) {
              var wrappedEvent = wrapEvent(event);
              lazyResize().each(function(resize2) {
                resize2.hideBars();
              });
              var rng = editor.selection.getRng();
              var startContainer = Element.fromDom(editor.selection.getStart());
              var start = Element.fromDom(rng.startContainer);
              var end = Element.fromDom(rng.endContainer);
              var direction = Direction.directionAt(startContainer).isRtl() ? SelectionKeys.rtl : SelectionKeys.ltr;
              keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each(function(response) {
                handleResponse(wrappedEvent, response);
              });
              lazyResize().each(function(resize2) {
                resize2.showBars();
              });
            };
            var isMouseEvent = function(event) {
              return event.hasOwnProperty("x") && event.hasOwnProperty("y");
            };
            var wrapEvent = function(event) {
              var target = Element.fromDom(event.target);
              var stop = function() {
                event.stopPropagation();
              };
              var prevent = function() {
                event.preventDefault();
              };
              var kill = compose(prevent, stop);
              return {
                target: constant(target),
                x: constant(isMouseEvent(event) ? event.x : null),
                y: constant(isMouseEvent(event) ? event.y : null),
                stop,
                prevent,
                kill,
                raw: constant(event)
              };
            };
            var isLeftMouse = function(raw) {
              return raw.button === 0;
            };
            var isLeftButtonPressed = function(raw) {
              if (raw.buttons === void 0) {
                return true;
              }
              if (global$2.ie && global$2.ie >= 12 && raw.buttons === 0) {
                return true;
              }
              return (raw.buttons & 1) !== 0;
            };
            var mouseDown = function(e2) {
              if (isLeftMouse(e2) && hasInternalTarget(e2)) {
                mouseHandlers.mousedown(wrapEvent(e2));
              }
            };
            var mouseOver = function(e2) {
              if (isLeftButtonPressed(e2) && hasInternalTarget(e2)) {
                mouseHandlers.mouseover(wrapEvent(e2));
              }
            };
            var mouseUp = function(e2) {
              if (isLeftMouse(e2) && hasInternalTarget(e2)) {
                mouseHandlers.mouseup(wrapEvent(e2));
              }
            };
            editor.on("mousedown", mouseDown);
            editor.on("mouseover", mouseOver);
            editor.on("mouseup", mouseUp);
            editor.on("keyup", keyup);
            editor.on("keydown", keydown);
            editor.on("nodechange", syncSelection);
            handlers = Option.some(handlerStruct({
              mousedown: mouseDown,
              mouseover: mouseOver,
              mouseup: mouseUp,
              keyup,
              keydown
            }));
          });
          var destroy2 = function() {
            handlers.each(function(handlers2) {
            });
          };
          return {
            clear: annotations.clear,
            destroy: destroy2
          };
        }
        var Selections = function(editor) {
          var get2 = function() {
            var body2 = getBody$1(editor);
            return TableSelection.retrieve(body2, Ephemera.selectedSelector()).fold(function() {
              if (editor.selection.getStart() === void 0) {
                return SelectionTypes.none();
              } else {
                return SelectionTypes.single(editor.selection);
              }
            }, function(cells2) {
              return SelectionTypes.multiple(cells2);
            });
          };
          return { get: get2 };
        };
        var each$4 = global$1.each;
        var addButtons = function(editor) {
          var menuItems = [];
          each$4("inserttable tableprops deletetable | cell row column".split(" "), function(name2) {
            if (name2 === "|") {
              menuItems.push({ text: "-" });
            } else {
              menuItems.push(editor.menuItems[name2]);
            }
          });
          editor.addButton("table", {
            type: "menubutton",
            title: "Table",
            menu: menuItems
          });
          function cmd(command) {
            return function() {
              editor.execCommand(command);
            };
          }
          editor.addButton("tableprops", {
            title: "Table properties",
            onclick: cmd("mceTableProps"),
            icon: "table"
          });
          editor.addButton("tabledelete", {
            title: "Delete table",
            onclick: cmd("mceTableDelete")
          });
          editor.addButton("tablecellprops", {
            title: "Cell properties",
            onclick: cmd("mceTableCellProps")
          });
          editor.addButton("tablemergecells", {
            title: "Merge cells",
            onclick: cmd("mceTableMergeCells")
          });
          editor.addButton("tablesplitcells", {
            title: "Split cell",
            onclick: cmd("mceTableSplitCells")
          });
          editor.addButton("tableinsertrowbefore", {
            title: "Insert row before",
            onclick: cmd("mceTableInsertRowBefore")
          });
          editor.addButton("tableinsertrowafter", {
            title: "Insert row after",
            onclick: cmd("mceTableInsertRowAfter")
          });
          editor.addButton("tabledeleterow", {
            title: "Delete row",
            onclick: cmd("mceTableDeleteRow")
          });
          editor.addButton("tablerowprops", {
            title: "Row properties",
            onclick: cmd("mceTableRowProps")
          });
          editor.addButton("tablecutrow", {
            title: "Cut row",
            onclick: cmd("mceTableCutRow")
          });
          editor.addButton("tablecopyrow", {
            title: "Copy row",
            onclick: cmd("mceTableCopyRow")
          });
          editor.addButton("tablepasterowbefore", {
            title: "Paste row before",
            onclick: cmd("mceTablePasteRowBefore")
          });
          editor.addButton("tablepasterowafter", {
            title: "Paste row after",
            onclick: cmd("mceTablePasteRowAfter")
          });
          editor.addButton("tableinsertcolbefore", {
            title: "Insert column before",
            onclick: cmd("mceTableInsertColBefore")
          });
          editor.addButton("tableinsertcolafter", {
            title: "Insert column after",
            onclick: cmd("mceTableInsertColAfter")
          });
          editor.addButton("tabledeletecol", {
            title: "Delete column",
            onclick: cmd("mceTableDeleteCol")
          });
        };
        var addToolbars = function(editor) {
          var isTable = function(table3) {
            var selectorMatched = editor.dom.is(table3, "table") && editor.getBody().contains(table3);
            return selectorMatched;
          };
          var toolbar = getToolbar(editor);
          if (toolbar.length > 0) {
            editor.addContextToolbar(isTable, toolbar.join(" "));
          }
        };
        var Buttons = {
          addButtons,
          addToolbars
        };
        var addMenuItems = function(editor, selections) {
          var targets = Option.none();
          var tableCtrls = [];
          var cellCtrls = [];
          var mergeCtrls = [];
          var unmergeCtrls = [];
          var noTargetDisable = function(ctrl) {
            ctrl.disabled(true);
          };
          var ctrlEnable = function(ctrl) {
            ctrl.disabled(false);
          };
          var pushTable = function() {
            var self = this;
            tableCtrls.push(self);
            targets.fold(function() {
              noTargetDisable(self);
            }, function(targets2) {
              ctrlEnable(self);
            });
          };
          var pushCell = function() {
            var self = this;
            cellCtrls.push(self);
            targets.fold(function() {
              noTargetDisable(self);
            }, function(targets2) {
              ctrlEnable(self);
            });
          };
          var pushMerge = function() {
            var self = this;
            mergeCtrls.push(self);
            targets.fold(function() {
              noTargetDisable(self);
            }, function(targets2) {
              self.disabled(targets2.mergable().isNone());
            });
          };
          var pushUnmerge = function() {
            var self = this;
            unmergeCtrls.push(self);
            targets.fold(function() {
              noTargetDisable(self);
            }, function(targets2) {
              self.disabled(targets2.unmergable().isNone());
            });
          };
          var setDisabledCtrls = function() {
            targets.fold(function() {
              each(tableCtrls, noTargetDisable);
              each(cellCtrls, noTargetDisable);
              each(mergeCtrls, noTargetDisable);
              each(unmergeCtrls, noTargetDisable);
            }, function(targets2) {
              each(tableCtrls, ctrlEnable);
              each(cellCtrls, ctrlEnable);
              each(mergeCtrls, function(mergeCtrl) {
                mergeCtrl.disabled(targets2.mergable().isNone());
              });
              each(unmergeCtrls, function(unmergeCtrl) {
                unmergeCtrl.disabled(targets2.unmergable().isNone());
              });
            });
          };
          editor.on("init", function() {
            editor.on("nodechange", function(e) {
              var cellOpt = Option.from(editor.dom.getParent(editor.selection.getStart(), "th,td"));
              targets = cellOpt.bind(function(cellDom) {
                var cell3 = Element.fromDom(cellDom);
                var table3 = TableLookup.table(cell3);
                return table3.map(function(table4) {
                  return TableTargets.forMenu(selections, table4, cell3);
                });
              });
              setDisabledCtrls();
            });
          });
          var generateTableGrid = function() {
            var html = "";
            html = '<table role="grid" class="mce-grid mce-grid-border" aria-readonly="true">';
            for (var y = 0; y < 10; y++) {
              html += "<tr>";
              for (var x = 0; x < 10; x++) {
                html += '<td role="gridcell" tabindex="-1"><a id="mcegrid' + (y * 10 + x) + '" href="#" data-mce-x="' + x + '" data-mce-y="' + y + '"></a></td>';
              }
              html += "</tr>";
            }
            html += "</table>";
            html += '<div class="mce-text-center" role="presentation">1 x 1</div>';
            return html;
          };
          var selectGrid = function(editor2, tx, ty, control) {
            var table3 = control.getEl().getElementsByTagName("table")[0];
            var x, y, focusCell, cell3, active;
            var rtl2 = control.isRtl() || control.parent().rel === "tl-tr";
            table3.nextSibling.innerHTML = tx + 1 + " x " + (ty + 1);
            if (rtl2) {
              tx = 9 - tx;
            }
            for (y = 0; y < 10; y++) {
              for (x = 0; x < 10; x++) {
                cell3 = table3.rows[y].childNodes[x].firstChild;
                active = (rtl2 ? x >= tx : x <= tx) && y <= ty;
                editor2.dom.toggleClass(cell3, "mce-active", active);
                if (active) {
                  focusCell = cell3;
                }
              }
            }
            return focusCell.parentNode;
          };
          var insertTable = hasTableGrid(editor) === false ? {
            text: "Table",
            icon: "table",
            context: "table",
            onclick: cmd("mceInsertTable")
          } : {
            text: "Table",
            icon: "table",
            context: "table",
            ariaHideMenu: true,
            onclick: function(e) {
              if (e.aria) {
                this.parent().hideAll();
                e.stopImmediatePropagation();
                editor.execCommand("mceInsertTable");
              }
            },
            onshow: function() {
              selectGrid(editor, 0, 0, this.menu.items()[0]);
            },
            onhide: function() {
              var elements = this.menu.items()[0].getEl().getElementsByTagName("a");
              editor.dom.removeClass(elements, "mce-active");
              editor.dom.addClass(elements[0], "mce-active");
            },
            menu: [{
              type: "container",
              html: generateTableGrid(),
              onPostRender: function() {
                this.lastX = this.lastY = 0;
              },
              onmousemove: function(e) {
                var target = e.target;
                var x, y;
                if (target.tagName.toUpperCase() === "A") {
                  x = parseInt(target.getAttribute("data-mce-x"), 10);
                  y = parseInt(target.getAttribute("data-mce-y"), 10);
                  if (this.isRtl() || this.parent().rel === "tl-tr") {
                    x = 9 - x;
                  }
                  if (x !== this.lastX || y !== this.lastY) {
                    selectGrid(editor, x, y, e.control);
                    this.lastX = x;
                    this.lastY = y;
                  }
                }
              },
              onclick: function(e) {
                var self = this;
                if (e.target.tagName.toUpperCase() === "A") {
                  e.preventDefault();
                  e.stopPropagation();
                  self.parent().cancel();
                  editor.undoManager.transact(function() {
                    InsertTable.insert(editor, self.lastX + 1, self.lastY + 1);
                  });
                  editor.addVisual();
                }
              }
            }]
          };
          function cmd(command) {
            return function() {
              editor.execCommand(command);
            };
          }
          var tableProperties = {
            text: "Table properties",
            context: "table",
            onPostRender: pushTable,
            onclick: cmd("mceTableProps")
          };
          var deleteTable = {
            text: "Delete table",
            context: "table",
            onPostRender: pushTable,
            cmd: "mceTableDelete"
          };
          var row2 = {
            text: "Row",
            context: "table",
            menu: [
              {
                text: "Insert row before",
                onclick: cmd("mceTableInsertRowBefore"),
                onPostRender: pushCell
              },
              {
                text: "Insert row after",
                onclick: cmd("mceTableInsertRowAfter"),
                onPostRender: pushCell
              },
              {
                text: "Delete row",
                onclick: cmd("mceTableDeleteRow"),
                onPostRender: pushCell
              },
              {
                text: "Row properties",
                onclick: cmd("mceTableRowProps"),
                onPostRender: pushCell
              },
              { text: "-" },
              {
                text: "Cut row",
                onclick: cmd("mceTableCutRow"),
                onPostRender: pushCell
              },
              {
                text: "Copy row",
                onclick: cmd("mceTableCopyRow"),
                onPostRender: pushCell
              },
              {
                text: "Paste row before",
                onclick: cmd("mceTablePasteRowBefore"),
                onPostRender: pushCell
              },
              {
                text: "Paste row after",
                onclick: cmd("mceTablePasteRowAfter"),
                onPostRender: pushCell
              }
            ]
          };
          var column = {
            text: "Column",
            context: "table",
            menu: [
              {
                text: "Insert column before",
                onclick: cmd("mceTableInsertColBefore"),
                onPostRender: pushCell
              },
              {
                text: "Insert column after",
                onclick: cmd("mceTableInsertColAfter"),
                onPostRender: pushCell
              },
              {
                text: "Delete column",
                onclick: cmd("mceTableDeleteCol"),
                onPostRender: pushCell
              }
            ]
          };
          var cell2 = {
            separator: "before",
            text: "Cell",
            context: "table",
            menu: [
              {
                text: "Cell properties",
                onclick: cmd("mceTableCellProps"),
                onPostRender: pushCell
              },
              {
                text: "Merge cells",
                onclick: cmd("mceTableMergeCells"),
                onPostRender: pushMerge
              },
              {
                text: "Split cell",
                onclick: cmd("mceTableSplitCells"),
                onPostRender: pushUnmerge
              }
            ]
          };
          editor.addMenuItem("inserttable", insertTable);
          editor.addMenuItem("tableprops", tableProperties);
          editor.addMenuItem("deletetable", deleteTable);
          editor.addMenuItem("row", row2);
          editor.addMenuItem("column", column);
          editor.addMenuItem("cell", cell2);
        };
        var MenuItems = { addMenuItems };
        var getClipboardRows = function(clipboardRows) {
          return clipboardRows.get().fold(function() {
            return;
          }, function(rows2) {
            return map(rows2, function(row2) {
              return row2.dom();
            });
          });
        };
        var setClipboardRows = function(rows2, clipboardRows) {
          var sugarRows = map(rows2, Element.fromDom);
          clipboardRows.set(Option.from(sugarRows));
        };
        var getApi = function(editor, clipboardRows) {
          return {
            insertTable: function(columns2, rows2) {
              return InsertTable.insert(editor, columns2, rows2);
            },
            setClipboardRows: function(rows2) {
              return setClipboardRows(rows2, clipboardRows);
            },
            getClipboardRows: function() {
              return getClipboardRows(clipboardRows);
            }
          };
        };
        function Plugin(editor) {
          var resizeHandler = ResizeHandler(editor);
          var cellSelection = CellSelection$1(editor, resizeHandler.lazyResize);
          var actions = TableActions(editor, resizeHandler.lazyWire);
          var selections = Selections(editor);
          var clipboardRows = Cell(Option.none());
          Commands.registerCommands(editor, actions, cellSelection, selections, clipboardRows);
          Clipboard.registerEvents(editor, selections, actions, cellSelection);
          MenuItems.addMenuItems(editor, selections);
          Buttons.addButtons(editor);
          Buttons.addToolbars(editor);
          editor.on("PreInit", function() {
            editor.serializer.addTempAttr(Ephemera.firstSelected());
            editor.serializer.addTempAttr(Ephemera.lastSelected());
          });
          if (hasTabNavigation(editor)) {
            editor.on("keydown", function(e) {
              TabContext.handle(e, editor, actions, resizeHandler.lazyWire);
            });
          }
          editor.on("remove", function() {
            resizeHandler.destroy();
            cellSelection.destroy();
          });
          return getApi(editor, clipboardRows);
        }
        global.add("table", Plugin);
        function Plugin$1() {
        }
        return Plugin$1;
      }(window);
    })();
  }
});

// node_modules/tinymce/plugins/table/index.js
var require_table = __commonJS({
  "node_modules/tinymce/plugins/table/index.js"() {
    require_plugin();
  }
});

// dep:tinymce_plugins_table_index
var tinymce_plugins_table_index_default = require_table();
export {
  tinymce_plugins_table_index_default as default
};
//# sourceMappingURL=tinymce_plugins_table_index.js.map
